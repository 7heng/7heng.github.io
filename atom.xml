<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Heng</title>
  
  
  <link href="https://7heng.github.io/atom.xml" rel="self"/>
  
  <link href="https://7heng.github.io/"/>
  <updated>2021-03-28T12:05:43.299Z</updated>
  <id>https://7heng.github.io/</id>
  
  <author>
    <name>7heng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java常见异常</title>
    <link href="https://7heng.github.io/2021/03/28/java%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8/"/>
    <id>https://7heng.github.io/2021/03/28/java%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8/</id>
    <published>2021-03-28T11:44:57.000Z</published>
    <updated>2021-03-28T12:05:43.299Z</updated>
    
    <content type="html"><![CDATA[<h6 id="java异常体系结构："><a href="#java异常体系结构：" class="headerlink" title="java异常体系结构："></a>java异常体系结构：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* java.lang.Throwable</span><br><span class="line">*     |-----java.lang.Error:一般不编写针对性的代码进行处理。</span><br><span class="line">*     |-----java.lang.Exception:可以进行异常的处理</span><br><span class="line">*        |------编译时异常(checked)</span><br><span class="line">*              |-----IOException</span><br><span class="line">*                 |-----FileNotFoundException</span><br><span class="line">*              |-----ClassNotFoundException</span><br><span class="line">*        |------运行时异常(unchecked,RuntimeException)</span><br><span class="line">*              |-----NullPointerException</span><br><span class="line">*              |-----ArrayIndexOutOfBoundsException</span><br><span class="line">*              |-----ClassCastException</span><br><span class="line">*              |-----NumberFormatException</span><br><span class="line">*              |-----InputMismatchException</span><br><span class="line">*              |-----ArithmeticException</span><br></pre></td></tr></table></figure><h6 id="java常见异常举例："><a href="#java常见异常举例：" class="headerlink" title="java常见异常举例："></a>java常见异常举例：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">下例为编译时异常：</span><br><span class="line">public void test7()&#123;</span><br><span class="line">    File file &#x3D; new File(&quot;hello.txt&quot;);</span><br><span class="line">    FileInputStream fis &#x3D; new FileInputStream(file);</span><br><span class="line">    </span><br><span class="line">    int data &#x3D; fis.read();</span><br><span class="line">    while(data !&#x3D; -1)&#123;</span><br><span class="line">       System.out.print((char)data);</span><br><span class="line">       data &#x3D; fis.read();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fis.close();</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">下例运行时异常：</span><br><span class="line">1：AirthmeticExctption算数异常：</span><br><span class="line"></span><br><span class="line">public void test6()&#123;</span><br><span class="line">int a &#x3D; 10;</span><br><span class="line">int b &#x3D; 0;</span><br><span class="line">System.out.println(a &#x2F; b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2：InputMismatchException输入类型不匹配异常：</span><br><span class="line"></span><br><span class="line">public void test5()&#123;</span><br><span class="line">Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">int score &#x3D; scanner.nextInt();</span><br><span class="line">System.out.println(score);</span><br><span class="line"></span><br><span class="line">scanner.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3：NumberFormatException数字格式异常：</span><br><span class="line"></span><br><span class="line">public void test4()&#123;</span><br><span class="line">    </span><br><span class="line">String str &#x3D; &quot;123&quot;;</span><br><span class="line">str &#x3D; &quot;abc&quot;;</span><br><span class="line">int num &#x3D; Integer.parseInt(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4：ClassCastException类型转换异常：</span><br><span class="line"></span><br><span class="line">public void test3()&#123;</span><br><span class="line">Object obj &#x3D; new Date();</span><br><span class="line">String str &#x3D; (String)obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5：IndexOutOfBoundsException数组下标越界异常：</span><br><span class="line"></span><br><span class="line">public void test2()&#123;</span><br><span class="line">&#x2F;&#x2F;  ArrayIndexOutOfBoundsException</span><br><span class="line">&#x2F;&#x2F;int[] arr &#x3D; new int[10];</span><br><span class="line">&#x2F;&#x2F;System.out.println(arr[10]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  StringIndexOutOfBoundsException</span><br><span class="line">String str &#x3D; &quot;abc&quot;;</span><br><span class="line">System.out.println(str.charAt(3));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6：NullPointerException空指针异常：</span><br><span class="line"></span><br><span class="line">public void test1()&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;int[] arr &#x3D; null;</span><br><span class="line">&#x2F;&#x2F;System.out.println(arr[3]);</span><br><span class="line"></span><br><span class="line">String str &#x3D; &quot;abc&quot;;</span><br><span class="line">str &#x3D; null;</span><br><span class="line">System.out.println(str.charAt(0));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;java异常体系结构：&quot;&gt;&lt;a href=&quot;#java异常体系结构：&quot; class=&quot;headerlink&quot; title=&quot;java异常体系结构：&quot;&gt;&lt;/a&gt;java异常体系结构：&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL-DDL</title>
    <link href="https://7heng.github.io/2021/03/28/MySQL-DDL/"/>
    <id>https://7heng.github.io/2021/03/28/MySQL-DDL/</id>
    <published>2021-03-28T07:03:02.000Z</published>
    <updated>2021-03-28T07:49:28.040Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据定义语言：</span><br><span class="line">创建：create</span><br><span class="line">修改：alter</span><br><span class="line">删除：drop</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">库的创建</span><br><span class="line">语法：select database [if not exists] 库名;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例1：创建库bleach</span><br><span class="line">CREATE DATABASE IF NOT EXISTS bleach;</span><br><span class="line"></span><br><span class="line">2：库的修改 (MySQL已经移除)</span><br><span class="line">RENAME DATABASE bleach TO 新库名;</span><br><span class="line"></span><br><span class="line">3：更改库的字符集</span><br><span class="line">ALTER DATABASE bleach CHARACTER SET gbk</span><br><span class="line"></span><br><span class="line">4：库的删除</span><br><span class="line">DROP DATABASE IF EXISTS bleach；</span><br></pre></td></tr></table></figure><h6 id="表的管理："><a href="#表的管理：" class="headerlink" title="表的管理："></a>表的管理：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">create table 表名(</span><br><span class="line">列名 列的类型【(长度) 约束】,</span><br><span class="line">列名 列的类型【(长度) 约束】,</span><br><span class="line">列名 列的类型【(长度) 约束】,</span><br><span class="line">...</span><br><span class="line">列名 列的类型【(长度) 约束】</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">例1：创建表bleach</span><br><span class="line">CREATE TABLE bleach&#123;</span><br><span class="line">id INT,#编号</span><br><span class="line">bName VARCHAR(20),#图书名</span><br><span class="line">price DOUBLE,#价格</span><br><span class="line">authorId  INT,#作者编号</span><br><span class="line">publishDate DATETIME#出版日期</span><br><span class="line">&#125;;</span><br><span class="line">DESC bleach;</span><br><span class="line"></span><br><span class="line">例2：创建表author</span><br><span class="line">CREATE TABLE IF NOT EXISTS author(</span><br><span class="line">id INT,</span><br><span class="line">au_name VARCHAR(20),</span><br><span class="line">nation VARCHAR(10)</span><br><span class="line">)</span><br><span class="line">DESC author;</span><br><span class="line"></span><br><span class="line">3:表的修改</span><br><span class="line">语法：alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;</span><br><span class="line"></span><br><span class="line">①修改列名</span><br><span class="line">ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;</span><br><span class="line"></span><br><span class="line">②修改列的类型或约束</span><br><span class="line">ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;</span><br><span class="line"></span><br><span class="line">③添加新列</span><br><span class="line">ALTER TABLE author ADD COLUMN annual DOUBLE; </span><br><span class="line"></span><br><span class="line">④删除列</span><br><span class="line">ALTER TABLE book_author DROP COLUMN  annual;</span><br><span class="line"></span><br><span class="line">⑤修改表名</span><br><span class="line">ALTER TABLE author RENAME TO book_author;</span><br><span class="line"></span><br><span class="line">DESC book;</span><br><span class="line"></span><br><span class="line">4：表的删除</span><br><span class="line">DROP TABLE IF EXISTS book_author;</span><br><span class="line"></span><br><span class="line">SHOW TABLES;</span><br><span class="line"></span><br><span class="line">#通用的写法：</span><br><span class="line">DROP DATABASE IF EXISTS 旧库名;</span><br><span class="line">CREATE DATABASE 新库名;</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS 旧表名;</span><br><span class="line">CREATE TABLE  表名();</span><br><span class="line"></span><br><span class="line">5：表的复制</span><br><span class="line">INSERT INTO author VALUES</span><br><span class="line">(1,&#39;姜文&#39;,&#39;中国&#39;),</span><br><span class="line">(2,&#39;恒子&#39;,&#39;中国&#39;),</span><br><span class="line">(3,&#39;胡歌&#39;,&#39;中国&#39;),</span><br><span class="line">(4,&#39;彭于晏&#39;,&#39;中国&#39;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM Author;</span><br><span class="line">SELECT * FROM copy2;</span><br><span class="line"></span><br><span class="line">#仅仅复制表的结构</span><br><span class="line">CREATE TABLE copy LIKE author;</span><br><span class="line"></span><br><span class="line">#复制表的结构+数据</span><br><span class="line">CREATE TABLE copy2 </span><br><span class="line">SELECT * FROM author;</span><br><span class="line"></span><br><span class="line">#只复制部分数据</span><br><span class="line">CREATE TABLE copy3</span><br><span class="line">SELECT id,au_name</span><br><span class="line">FROM author </span><br><span class="line">WHERE nation&#x3D;&#39;中国&#39;;</span><br><span class="line"></span><br><span class="line">#仅仅复制某些字段</span><br><span class="line">CREATE TABLE copy4 </span><br><span class="line">SELECT id,au_name</span><br><span class="line">FROM author</span><br><span class="line">WHERE 0;</span><br></pre></td></tr></table></figure><h6 id="库和表的管理例题："><a href="#库和表的管理例题：" class="headerlink" title="库和表的管理例题："></a>库和表的管理例题：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">1：创建表dept1</span><br><span class="line">NAMENULL?TYPE</span><br><span class="line">idINT(7)</span><br><span class="line">NAMEVARCHAR(25)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">USE test;</span><br><span class="line"></span><br><span class="line">CREATE TABLE dept1(</span><br><span class="line">id INT(7),</span><br><span class="line">NAME VARCHAR(25)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">2：将表departments中的数据插入新表dept2中</span><br><span class="line">CREATE TABLE dept2</span><br><span class="line">SELECT department_id,department_name</span><br><span class="line">FROM myemployees.departments;</span><br><span class="line"></span><br><span class="line">3：创建表emp5</span><br><span class="line">NAMENULL?TYPE</span><br><span class="line">idINT(7)</span><br><span class="line">First_nameVARCHAR (25)</span><br><span class="line">Last_nameVARCHAR(25)</span><br><span class="line">Dept_idINT(7)</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp5(</span><br><span class="line">id INT(7),</span><br><span class="line">first_name VARCHAR(25),</span><br><span class="line">last_name VARCHAR(25),</span><br><span class="line">dept_id INT(7)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">4：将列Last_name的长度增加到50</span><br><span class="line">ALTER TABLE emp5 MODIFY COLUMN last_name VARCHAR(50);</span><br><span class="line"></span><br><span class="line">5：根据表employees创建employees2</span><br><span class="line">CREATE TABLE employees2 LIKE myemployees.employees;</span><br><span class="line"></span><br><span class="line">6：删除表emp5</span><br><span class="line">DROP TABLE IF EXISTS emp5;</span><br><span class="line"></span><br><span class="line">7：将表employees2重命名为emp5</span><br><span class="line">ALTER TABLE employees2 RENAME TO emp5;</span><br><span class="line"></span><br><span class="line">8：在表dept和emp5中添加新列test_column，并检查所作的操作</span><br><span class="line">ALTER TABLE emp5 ADD COLUMN test_column INT;</span><br><span class="line"></span><br><span class="line">9；直接删除表emp5中的列 dept_id</span><br><span class="line">DESC emp5;</span><br><span class="line">ALTER TABLE emp5 DROP COLUMN test_column;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL-DML</title>
    <link href="https://7heng.github.io/2021/03/28/MySQL-DML/"/>
    <id>https://7heng.github.io/2021/03/28/MySQL-DML/</id>
    <published>2021-03-28T06:21:11.000Z</published>
    <updated>2021-03-28T07:02:33.745Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据操作语言：</span><br><span class="line">插入：insert</span><br><span class="line">修改：update</span><br><span class="line">删除：delete</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">插入语句</span><br><span class="line">语法：insert into 表名(列名...) values(值1，...);</span><br><span class="line"></span><br><span class="line">#方式一：</span><br><span class="line">例1：</span><br><span class="line">SELECT * FROM beauty;</span><br><span class="line">INSER INTO beauty(id,NAME,sex,borndate,phone,girlfriend_name,girlfriend_id)插入的值的类型要与列的类型一致或兼容</span><br><span class="line">VALUES(22,&#39;恒子&#39;，‘男’,&#39;2000-12-22&#39;,&#39;17513077777&#39;,&#39;null&#39;,&#39;1&#39;);日期和字符串需要加单引号或双引号。</span><br><span class="line"></span><br><span class="line">2：不可以为null的列必须插入值，可以为null的列如何插入值？</span><br><span class="line">#方式一：</span><br><span class="line">INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)</span><br><span class="line">VALUES(18,&#39;贝尔摩德&#39;,&#39;女&#39;,&#39;1999-11-11&#39;,&#39;3333333333&#39;,NULL,7);</span><br><span class="line"></span><br><span class="line">#方式二：</span><br><span class="line">INSERT INTO beauty(id,NAME,sex,phone)</span><br><span class="line">VALUES(15,&#39;灰原哀&#39;,&#39;女&#39;,&#39;77777777777&#39;);</span><br><span class="line"></span><br><span class="line">3：列的顺序是否可以调换</span><br><span class="line">INSERT INTO beauty(NAME,sex,id,phone)</span><br><span class="line">VALUES(&#39;步美&#39;,&#39;女&#39;,10,&#39;777&#39;);</span><br><span class="line"></span><br><span class="line">4：列数和值的个数必须一致</span><br><span class="line">INSERT INTO beauty(NAME,sex,id,phone)</span><br><span class="line">VALUES(&#39;世良&#39;,&#39;女&#39;,18,&#39;111&#39;);</span><br><span class="line"></span><br><span class="line">5：可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致</span><br><span class="line">INSERT INTO beauty</span><br><span class="line">VALUES(18,&#39;柯南&#39;,&#39;男&#39;,NULL,&#39;110&#39;,NULL,NULL);</span><br><span class="line"></span><br><span class="line">#方式二：</span><br><span class="line">语法：</span><br><span class="line">insert into 表名</span><br><span class="line">set 列名&#x3D;值，列名&#x3D;值...;</span><br><span class="line"></span><br><span class="line">方式一和方式二对比：</span><br><span class="line">1：方式一支持插入多行,方式二不支持</span><br><span class="line">INSERT INTO beauty</span><br><span class="line">VALUES(16,&#39;灰原哀&#39;,&#39;女&#39;,&#39;1999-7-7&#39;,&#39;8888888&#39;,NULL,1),</span><br><span class="line">(17,&#39;柯南&#39;,&#39;男&#39;,&#39;1990-7-7&#39;,&#39;8888888&#39;,NULL,2),</span><br><span class="line">(18,&#39;小兰&#39;,&#39;女&#39;,&#39;1990-7-7&#39;,&#39;8888888&#39;,NULL,1);</span><br><span class="line"></span><br><span class="line">2：方式一支持子查询，方式二不支持</span><br><span class="line">INSERT INTO beauty(id,NAME,phone)</span><br><span class="line">SELECT 18,&#39;秀一&#39;,&#39;99999999&#39;;</span><br><span class="line"></span><br><span class="line">INSERT INTO beauty(id,NAME,phone)</span><br><span class="line">SELECT id,boyname,&#39;6666666&#39;</span><br><span class="line">FROM boys WHERE id&lt;3;</span><br><span class="line"></span><br><span class="line">修改语句：</span><br><span class="line">1.修改单表的记录★</span><br><span class="line">语法：</span><br><span class="line">update 表名</span><br><span class="line">set 列&#x3D;新值,列&#x3D;新值,...</span><br><span class="line">where 筛选条件;</span><br><span class="line"></span><br><span class="line">2.修改多表的记录【补充】</span><br><span class="line">sql92语法：</span><br><span class="line">update 表1 别名,表2 别名</span><br><span class="line">set 列&#x3D;值,...</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件;</span><br><span class="line"></span><br><span class="line">sql99语法：</span><br><span class="line">update 表1 别名</span><br><span class="line">inner|left|right join 表2 别名</span><br><span class="line">on 连接条件</span><br><span class="line">set 列&#x3D;值,...</span><br><span class="line">where 筛选条件;</span><br><span class="line"></span><br><span class="line">修改单表的记录</span><br><span class="line">例1：修改beauty表中姓玛的女神的电话为7777777</span><br><span class="line">UPDATE beauty SET phone &#x3D; &#39;7777777&#39;</span><br><span class="line">WHERE NAME LIKE &#39;玛%&#39;;</span><br><span class="line"></span><br><span class="line">2：修改boys表中id号为2的名称为秀一，魅力值 100</span><br><span class="line">UPDATE boys SET boyname&#x3D;&#39;秀一&#39;,usercp&#x3D;100</span><br><span class="line">WHERE id&#x3D;2;</span><br><span class="line"></span><br><span class="line">3：修改多表的记录</span><br><span class="line">修改柯南的女朋友的手机号为777</span><br><span class="line">UPDATE boys bo</span><br><span class="line">INNER JOIN beauty b ON bo.&#96;id&#96;&#x3D;b.&#96;boyfriend_id&#96;</span><br><span class="line">SET b.&#96;phone&#96;&#x3D;&#39;777&#39;,bo.&#96;userCP&#96;&#x3D;1000</span><br><span class="line">WHERE bo.&#96;boyName&#96;&#x3D;&#39;柯南&#39;;</span><br><span class="line"></span><br><span class="line">4：修改没有男朋友的女神的男朋友编号都为2号</span><br><span class="line">UPDATE boys bo</span><br><span class="line">RIGHT JOIN beauty b ON bo.&#96;id&#96;&#x3D;b.&#96;boyfriend_id&#96;</span><br><span class="line">SET b.&#96;boyfriend_id&#96;&#x3D;2</span><br><span class="line">WHERE bo.&#96;id&#96; IS NULL;</span><br><span class="line"></span><br><span class="line">删除语句：</span><br><span class="line">方式一：delete</span><br><span class="line"></span><br><span class="line">1、单表的删除【★】</span><br><span class="line">delete from 表名 where 筛选条件</span><br><span class="line"></span><br><span class="line">2、多表的删除【补充】</span><br><span class="line">sql92语法：</span><br><span class="line">delete 表1的别名,表2的别名</span><br><span class="line">from 表1 别名,表2 别名</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件;</span><br><span class="line"></span><br><span class="line">sql99语法：</span><br><span class="line">delete 表1的别名,表2的别名</span><br><span class="line">from 表1 别名</span><br><span class="line">inner|left|right join 表2 别名 on 连接条件</span><br><span class="line">where 筛选条件;</span><br><span class="line"></span><br><span class="line">方式二：truncate</span><br><span class="line">语法：truncate table 表名;</span><br><span class="line"></span><br><span class="line">(delete)</span><br><span class="line">例1：单表的删除</span><br><span class="line">删除手机号以9结尾的女神信息</span><br><span class="line">DELETE FROM beauty WHERE phone LIKE &#39;%9&#39;;</span><br><span class="line">SELECT * FROM beauty;</span><br><span class="line"></span><br><span class="line">2：多表的删除</span><br><span class="line">删除秀一的女朋友的信息</span><br><span class="line">DELETE b</span><br><span class="line">FROM beauty b</span><br><span class="line">INNER JOIN boys bo ON b.&#96;boyfriend_id&#96; &#x3D; bo.&#96;id&#96;</span><br><span class="line">WHERE bo.&#96;boyName&#96;&#x3D;&#39;秀一&#39;;</span><br><span class="line"></span><br><span class="line">3：删除安室透的信息以及他女朋友的信息</span><br><span class="line">DELETE b,bo</span><br><span class="line">FROM beauty b</span><br><span class="line">INNER JOIN boys bo ON b.&#96;boyfriend_id&#96;&#x3D;bo.&#96;id&#96;</span><br><span class="line">WHERE bo.&#96;boyName&#96;&#x3D;&#39;安室透&#39;;</span><br><span class="line"></span><br><span class="line">(truncate)</span><br><span class="line">例1：将魅力值&gt;100的男神信息删除</span><br><span class="line">TRUNCATE TABLE boys;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【delete和truncate的区别：】</span><br><span class="line"></span><br><span class="line">1.delete 可以加where 条件，truncate不能加。</span><br><span class="line">2.truncate删除，效率高一丢丢。</span><br><span class="line">3.假如要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点开始，而truncate删除后，再插入数据，自增长列的值从1开始。</span><br><span class="line">4.truncate删除没有返回值，delete删除有返回值。</span><br><span class="line">5.truncate删除不能回滚，delete删除可以回滚。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java设计模式</title>
    <link href="https://7heng.github.io/2021/03/27/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://7heng.github.io/2021/03/27/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-27T12:00:11.000Z</published>
    <updated>2021-03-27T12:22:03.640Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">单例设计模式：</span><br><span class="line"></span><br><span class="line">1：所谓类的单例设计模式，就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例。</span><br><span class="line"></span><br><span class="line">2：常见的设计模式有懒汉式和饿汉式。</span><br><span class="line"></span><br><span class="line">3：饿汉式：</span><br><span class="line">坏处：对象加载时间过长。</span><br><span class="line">好处:饿汉式是线程安全的。</span><br><span class="line">4：懒汉式：</span><br><span class="line">好处：延迟对象的创建。</span><br><span class="line">坏处：会存在线程不安全的情况。</span><br><span class="line">5：饿汉式是创建类的同时就已经创建好了一个静态的对象供系统使用，以后不再改变。</span><br><span class="line">6：懒汉式是真正用到的时候才建单例对象，做到了延时加载。也因为如此，才会线程不安全。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">饿汉式：</span><br><span class="line">public class SingletonTest1 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;    Bank bank1 &#x3D; new Bank(); 构造器是私有化的，无法new出对象。</span><br><span class="line">&#x2F;&#x2F;    Bank bank2 &#x3D; new Bank(); 构造器是私有化的，无法new出对象。</span><br><span class="line">      </span><br><span class="line">      Bank bank1 &#x3D; Bank.getInstance();</span><br><span class="line">      Bank bank2 &#x3D; Bank.getInstance();</span><br><span class="line">      </span><br><span class="line">      System.out.println(bank1 &#x3D;&#x3D; bank2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bank&#123;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;1.私有化类的构造器</span><br><span class="line">   private Bank()&#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;2.内部创建类的对象</span><br><span class="line">   &#x2F;&#x2F;4.要求此对象也必须声明为静态的</span><br><span class="line">   private static Bank instance &#x3D; new Bank();</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;3.提供公共的静态的方法，返回类的对象</span><br><span class="line">   public static Bank getInstance()&#123;</span><br><span class="line">      return instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">懒汉式之线程不安全写法：</span><br><span class="line">public class SingletonTest2 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      </span><br><span class="line">      Order order1 &#x3D; Order.getInstance();</span><br><span class="line">      Order order2 &#x3D; Order.getInstance();</span><br><span class="line">      </span><br><span class="line">      System.out.println(order1 &#x3D;&#x3D; order2);</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Order&#123;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;1.私有化类的构造器</span><br><span class="line">   private Order()&#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;2.声明当前类对象，没有初始化</span><br><span class="line">   &#x2F;&#x2F;4.此对象也必须声明为static的</span><br><span class="line">   private static Order instance &#x3D; null;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;3.声明public、static的返回当前类对象的方法</span><br><span class="line">   public static Order getInstance()&#123;</span><br><span class="line">      </span><br><span class="line">      if(instance &#x3D;&#x3D; null)&#123;</span><br><span class="line">         </span><br><span class="line">         instance &#x3D; new Order();</span><br><span class="line">         </span><br><span class="line">      &#125;</span><br><span class="line">      return instance;</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">利用同步机制实现线程安全的懒汉式：</span><br><span class="line">public class BankTest &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bank&#123;</span><br><span class="line">&#x2F;&#x2F; 私有化类的构造器</span><br><span class="line">private Bank()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">private static Bank instance &#x3D; null;</span><br><span class="line">public static Bank getInstance()&#123;</span><br><span class="line">&#x2F;&#x2F;方式一：效率稍差</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;       synchronized (Bank.class) &#123;</span><br><span class="line">&#x2F;&#x2F;           if(instance &#x3D;&#x3D; null)&#123;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;               instance &#x3D; new Bank();</span><br><span class="line">&#x2F;&#x2F;           &#125;</span><br><span class="line">&#x2F;&#x2F;           return instance;</span><br><span class="line">&#x2F;&#x2F;       &#125;</span><br><span class="line">&#x2F;&#x2F;方式二：效率更高</span><br><span class="line">        if(instance &#x3D;&#x3D; null)&#123;</span><br><span class="line"></span><br><span class="line">        synchronized (Bank.class) &#123;</span><br><span class="line">            if(instance &#x3D;&#x3D; null)&#123;</span><br><span class="line"></span><br><span class="line">                instance &#x3D; new Bank();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL分页查询</title>
    <link href="https://7heng.github.io/2021/03/27/MySQL%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/"/>
    <id>https://7heng.github.io/2021/03/27/MySQL%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</id>
    <published>2021-03-27T11:18:38.000Z</published>
    <updated>2021-03-27T11:35:42.397Z</updated>
    
    <content type="html"><![CDATA[<p><em>当要显示的数据，一页显示不全，需要分页提交sql请求。</em></p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表</span><br><span class="line">【 join type join 表2</span><br><span class="line">on 连接条件</span><br><span class="line">where 筛选条件</span><br><span class="line">group by 分组字段</span><br><span class="line">having 分组后的筛选</span><br><span class="line">order by 排序后的字段】</span><br><span class="line">limit [offset],size；</span><br></pre></td></tr></table></figure><p>offset 要显示条目的起始索引 (起始索引从0开始)</p><p>size 要显示的条目个数</p><p><strong>特点：</strong></p><p>&emsp;①：limit语句放在查询语句的最后</p><p>&emsp;②公式：要显示的页数page，每页的条目数size</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表</span><br><span class="line">limit (page-1) * size,size;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">例1：查询前五条员工信息</span><br><span class="line">SELECT * FROM employees LIMIT 0,5;</span><br><span class="line">SELECT * FROM employees LIMIE 5;</span><br><span class="line"></span><br><span class="line">2：查询第11条---&gt;第25条</span><br><span class="line">SELECT * FROM employees LIMIT 10,15;</span><br><span class="line"></span><br><span class="line">3：有奖金的员工信息，并且工资较高的前10名显示出来</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">ORDER BY salary DESC</span><br><span class="line">LIMIT 10;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;当要显示的数据，一页显示不全，需要分页提交sql请求。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL子查询</title>
    <link href="https://7heng.github.io/2021/03/27/MySQL%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
    <id>https://7heng.github.io/2021/03/27/MySQL%E5%AD%90%E6%9F%A5%E8%AF%A2/</id>
    <published>2021-03-27T07:05:34.000Z</published>
    <updated>2021-03-28T06:18:10.606Z</updated>
    
    <content type="html"><![CDATA[<h6 id="子查询："><a href="#子查询：" class="headerlink" title="子查询："></a>子查询：</h6><p>&emsp;<em>&emsp;一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询，在外面的查询语句，称为主查询或外查询。</em></p><p><strong>分类：</strong></p><p>按子查询出现的位置：</p><p>&emsp;&emsp;&emsp;&emsp;select后面：<strong>仅仅支持标量子查询。</strong></p><p>&emsp;&emsp;&emsp;&emsp;from后面：<strong>支持表子查询。</strong></p><p>&emsp;&emsp;&emsp;&emsp;where或having后面：<strong>标量子查询 (单行子查询)、列子查询 (多行子查询)、行子查询(多行多列)。</strong></p><p>&emsp;&emsp;&emsp;&emsp;exists后面(也称相关子查询)：<strong>表子查询。</strong></p><p>按结果集的行列数不同：</p><p>&emsp;&emsp;&emsp;&emsp;标量子查询（结果集只有一行一列）</p><p>&emsp;&emsp;&emsp;&emsp;列子查询（结果集只有一列多行）</p><p>&emsp;&emsp;&emsp;&emsp;行子查询（结果集有一行多列）</p><p>&emsp;&emsp;&emsp;&emsp;表子查询（结果集一般为多行多列）</p><p><strong>特点：</strong></p><p>1：子查询都放在小括号内。</p><p>2：子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧。</p><p>3：子查询优先于主查询执行，主查询使用了子查询的执行结果。</p><p>4：子查询根据查询结果的行数不同分为以下两类：</p><p>&emsp;&emsp;①：单行子查询：</p><p>&emsp;&emsp;&emsp;&emsp;结果只有一行，一般搭配单行操作符使用：&gt; &lt; = &gt;= &lt;=</p><p>&emsp;&emsp;&emsp;&emsp;非法使用子查询的情况：a：子查询的结果为一组值。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;b：子查询的结果为空。</p><p>&emsp;&emsp;②：多行子查询：</p><p>&emsp;&emsp;&emsp;&emsp;结果集有多行，一般搭配多行操作符使用：any、all、in、not、in</p><p>&emsp;&emsp;&emsp;&emsp;in：属于子查询结果中任意一个就行。</p><p>&emsp;&emsp;&emsp;&emsp;any和all往往可以用其他查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line">标量子查询</span><br><span class="line">例1：谁的工资比Angel高。</span><br><span class="line">①查询Angel的工资</span><br><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name &#x3D; &#39;Angel&#39;;</span><br><span class="line"></span><br><span class="line">②：查询员工的信息，满足salary&gt;①的结果</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&gt;&#123;</span><br><span class="line">SELECT salary</span><br><span class="line">    FROM employees</span><br><span class="line">    WHERE last_name &#x3D; &#39;Angel&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">2：返回job_id与141号员工相同，salary比143号员工多的员工，job_id和工资。</span><br><span class="line">①：查询141号员工的job_id</span><br><span class="line">SELECT job_id </span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id &#x3D; 141</span><br><span class="line"></span><br><span class="line">②：查询143号员工的salary</span><br><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id &#x3D; 143</span><br><span class="line"></span><br><span class="line">③：查询员工的姓名，job_id和工资，要求job_id&#x3D;①并且salary&gt;②</span><br><span class="line">SELECT last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id &#x3D; &#123;</span><br><span class="line">    SELECT job_id </span><br><span class="line">    FROM employees</span><br><span class="line">    WHERE employee_id &#x3D; 141</span><br><span class="line">&#125;</span><br><span class="line">AND salary&gt;&#123;</span><br><span class="line">    SELECT salary</span><br><span class="line">    FROM employees</span><br><span class="line">    WHERE employee_id &#x3D; 143</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">3：返回公司工资最少的员工的last_name,job_id和salary</span><br><span class="line">①：查询公司的最低工资</span><br><span class="line">SELECT MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">②：查询last_name,job_id和salary,要求salary&#x3D;①</span><br><span class="line">SELECT last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&#x3D;&#123;</span><br><span class="line">SELECT MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">4：查询最低工资大于50号部门最低工资的部门id和其最低工资</span><br><span class="line">①：查询50号部门的最低工资</span><br><span class="line">SELECT MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE depertment_id &#x3D; 50</span><br><span class="line"></span><br><span class="line">②：查询每个部门的最低工资</span><br><span class="line">SELECT MIN(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">③：在②的基础上筛选，满足min(salary)&gt;①</span><br><span class="line">SELECT MIN(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MIN(salary)&gt;&#123;</span><br><span class="line">    SELECT MIN(salary)</span><br><span class="line">    FROM employees</span><br><span class="line">    WHERE department_id &#x3D; 50</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">列子查询(多行子查询)：</span><br><span class="line">例1：返回location_id是1400或1700的部门中的所有员工姓名</span><br><span class="line">①：查询locati_id是1400或1700的部门编号</span><br><span class="line">SELECT DISTINCT department_id</span><br><span class="line">FROM depertments</span><br><span class="line">WHERE location_id IN (1400,1700)</span><br><span class="line"></span><br><span class="line">②：查询员工姓名，要求部门号是①列表中的某一个</span><br><span class="line">SELECT last_name</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id &lt;&gt;ALL&#123;</span><br><span class="line">    SELECT DISTINCT department_id</span><br><span class="line">    FROM depertments</span><br><span class="line">    WHERE location_id IN (1400,1700)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">2：返回其它工种中比job_id为&#39;IT_PROG&#39;工种任一工资低的员工的员工号、姓名、job_id以及salary</span><br><span class="line">①：查询job_id为&#39;IT_PROG&#39;部门任一工资</span><br><span class="line">SELECT DISTINCT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id &#x3D; &#39;IT_PROG&#39;</span><br><span class="line"></span><br><span class="line">②：查询员工号、姓名、job_id以及salary，salary&lt;①中的任意一个</span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;ANY(</span><br><span class="line">SELECT DISTINCT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id &#x3D; &#39;IT_PROG&#39;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&#39;IT_PROG&#39;;</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;(</span><br><span class="line">SELECT MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id &#x3D; &#39;IT_PROG&#39;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&#39;IT_PROG&#39;;</span><br><span class="line"></span><br><span class="line">3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工   的员工号、姓名、job_id 以及salary</span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;ALL(</span><br><span class="line">SELECT DISTINCT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id &#x3D; &#39;IT_PROG&#39;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&#39;IT_PROG&#39;;</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;(</span><br><span class="line">SELECT MIN( salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id &#x3D; &#39;IT_PROG&#39;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&#39;IT_PROG&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">行子查询（结果集一行多列或多行多列）</span><br><span class="line">例1：查询员工编号最小并且工资最高的员工信息</span><br><span class="line">SELECT * </span><br><span class="line">FROM employees</span><br><span class="line">WHERE (employee_id,salary)&#x3D;(</span><br><span class="line">SELECT MIN(employee_id),MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">①：查询最小的员工编号</span><br><span class="line">SELECT MIN(employee_id)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#②查询最高工资</span><br><span class="line">SELECT MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">#③：查询员工信息</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id&#x3D;(</span><br><span class="line">SELECT MIN(employee_id)</span><br><span class="line">FROM employees</span><br><span class="line">)AND salary&#x3D;(</span><br><span class="line">SELECT MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select后面仅仅支持标量子查询</span><br><span class="line">例1：查询每个部门的员工个数</span><br><span class="line">SELECT d.*,(</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*)</span><br><span class="line">FROM employees e</span><br><span class="line">WHERE e.department_id &#x3D; d.&#96;department_id&#96;</span><br><span class="line"> ) 个数</span><br><span class="line"> FROM departments d;</span><br><span class="line"> </span><br><span class="line"> 2：查询员工号&#x3D;102的部门名</span><br><span class="line">SELECT (</span><br><span class="line">SELECT department_name,e.department_id</span><br><span class="line">FROM departments d</span><br><span class="line">INNER JOIN employees e</span><br><span class="line">ON d.department_id&#x3D;e.department_id</span><br><span class="line">WHERE e.employee_id&#x3D;102</span><br><span class="line"></span><br><span class="line">) 部门名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from后面将子查询结果充当一张表，要求必须起别名</span><br><span class="line">例1：查询每个部门的平均工资的工资等级</span><br><span class="line">①：查询每个部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">②：连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_sal</span><br><span class="line">SELECT  ag_dep.*,g.&#96;grade_level&#96;</span><br><span class="line">FROM (</span><br><span class="line">SELECT AVG(salary) ag,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">) ag_dep</span><br><span class="line">INNER JOIN job_grades g</span><br><span class="line">ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exists后面（相关子查询）</span><br><span class="line">语法：</span><br><span class="line">exists(完整的查询语句)</span><br><span class="line">结果：1或0</span><br><span class="line">SELECT EXISTS(SELECT employee_id FROM employees WHERE salary&#x3D;300000);</span><br><span class="line">例1：查询有员工的部门名</span><br><span class="line">#in</span><br><span class="line">SELECT department_name</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE d.&#96;department_id&#96; IN(</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#exists</span><br><span class="line">SELECT department_name</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE EXISTS(</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees e</span><br><span class="line">WHERE d.&#96;department_id&#96;&#x3D;e.&#96;department_id&#96;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">2：查询没有女朋友的男神信息</span><br><span class="line">#in</span><br><span class="line">SELECT bo.*</span><br><span class="line">FROM boys bo</span><br><span class="line">WHERE bo.id NOT IN(</span><br><span class="line">SELECT boyfriend_id</span><br><span class="line">FROM beauty</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#exists</span><br><span class="line">SELECT bo.*</span><br><span class="line">FROM boys bo</span><br><span class="line">WHERE NOT EXISTS(</span><br><span class="line">SELECT boyfriend_id</span><br><span class="line">FROM beauty b</span><br><span class="line">WHERE bo.&#96;id&#96;&#x3D;b.&#96;boyfriend_id&#96;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line">经典例题：</span><br><span class="line">1：查询工资最低的员工信息: last_name, salary</span><br><span class="line">①：查询最低的工资</span><br><span class="line">SELECT MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">②：查询</span><br><span class="line">last_name,salary，要求salary&#x3D;①</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&#x3D;(</span><br><span class="line">SELECT MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">2：查询平均工资最低的部门信息</span><br><span class="line"></span><br><span class="line">#方式一：</span><br><span class="line">①：各部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">②：查询①结果上的最低平均工资</span><br><span class="line">SELECT MIN(ag)</span><br><span class="line">FROM (</span><br><span class="line">SELECT AVG(salary) ag,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">) ag_dep</span><br><span class="line"></span><br><span class="line">③：查询哪个部门的平均工资&#x3D;②</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary)&#x3D;(</span><br><span class="line">SELECT MIN(ag)</span><br><span class="line">FROM (</span><br><span class="line">SELECT AVG(salary) ag,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">) ag_dep</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">④：查询部门信息</span><br><span class="line">SELECT d.*</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE d.&#96;department_id&#96;&#x3D;(</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary)&#x3D;(</span><br><span class="line">SELECT MIN(ag)</span><br><span class="line">FROM (</span><br><span class="line">SELECT AVG(salary) ag,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">) ag_dep</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#方式二：</span><br><span class="line">①：各部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">②：求出最低平均工资的部门编号</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY AVG(salary) </span><br><span class="line">LIMIT 1;</span><br><span class="line"></span><br><span class="line">③：查询部门信息</span><br><span class="line">SELECT *</span><br><span class="line">FROM departments</span><br><span class="line">WHERE department_id&#x3D;(</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY AVG(salary) </span><br><span class="line">LIMIT 1</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">3：查询平均工资最低的部门信息和该部门的平均工资</span><br><span class="line">①：各部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">②：求出最低平均工资的部门编号</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY AVG(salary) </span><br><span class="line">LIMIT 1;</span><br><span class="line"></span><br><span class="line">③：查询部门信息</span><br><span class="line">SELECT d.*,ag</span><br><span class="line">FROM departments d</span><br><span class="line">JOIN (</span><br><span class="line">SELECT AVG(salary) ag,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY AVG(salary) </span><br><span class="line">LIMIT 1</span><br><span class="line"></span><br><span class="line">) ag_dep</span><br><span class="line">ON d.&#96;department_id&#96;&#x3D;ag_dep.department_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4：查询平均工资最高的 job 信息</span><br><span class="line">①：查询最高的job的平均工资</span><br><span class="line">SELECT AVG(salary),job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id</span><br><span class="line">ORDER BY AVG(salary) DESC</span><br><span class="line">LIMIT 1</span><br><span class="line"></span><br><span class="line">②：查询job信息</span><br><span class="line">SELECT * </span><br><span class="line">FROM jobs</span><br><span class="line">WHERE job_id&#x3D;(</span><br><span class="line">SELECT job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id</span><br><span class="line">ORDER BY AVG(salary) DESC</span><br><span class="line">LIMIT 1</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">5：查询平均工资高于公司平均工资的部门有哪些?</span><br><span class="line">①：查询平均工资</span><br><span class="line">SELECT AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">②：查询每个部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line"></span><br><span class="line">③：筛选②结果集，满足平均工资&gt;①</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary)&gt;(</span><br><span class="line">SELECT AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">6：查询出公司中所有 manager 的详细信息.</span><br><span class="line">①：查询所有manager的员工编号</span><br><span class="line">SELECT DISTINCT manager_id</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">②查询详细信息，满足employee_id&#x3D;①</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id &#x3D;ANY(</span><br><span class="line">SELECT DISTINCT manager_id</span><br><span class="line">FROM employees</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">7：各个部门中 最高工资中最低的那个部门的 最低工资是多少</span><br><span class="line">①：查询各部门的最高工资中最低的部门编号</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY MAX(salary)</span><br><span class="line">LIMIT 1</span><br><span class="line"></span><br><span class="line">②：查询①结果的那个部门的最低工资</span><br><span class="line">SELECT MIN(salary) ,department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id&#x3D;(</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">ORDER BY MAX(salary)</span><br><span class="line">LIMIT 1</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">8：查询平均工资最高的部门的 manager 的详细信息: last_name, department_id, email, salary</span><br><span class="line">①：查询平均工资最高的部门编号</span><br><span class="line">SELECT </span><br><span class="line">    department_id </span><br><span class="line">FROM</span><br><span class="line">    employees </span><br><span class="line">GROUP BY department_id </span><br><span class="line">ORDER BY AVG(salary) DESC </span><br><span class="line">LIMIT 1 </span><br><span class="line"></span><br><span class="line">②：将employees和departments连接查询，筛选条件是①</span><br><span class="line">    SELECT </span><br><span class="line">        last_name, d.department_id, email, salary </span><br><span class="line">    FROM</span><br><span class="line">        employees e </span><br><span class="line">        INNER JOIN departments d </span><br><span class="line">            ON d.manager_id &#x3D; e.employee_id </span><br><span class="line">    WHERE d.department_id &#x3D; </span><br><span class="line">        (SELECT </span><br><span class="line">            department_id </span><br><span class="line">        FROM</span><br><span class="line">            employees </span><br><span class="line">        GROUP BY department_id </span><br><span class="line">        ORDER BY AVG(salary) DESC </span><br><span class="line">        LIMIT 1) ;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;子查询：&quot;&gt;&lt;a href=&quot;#子查询：&quot; class=&quot;headerlink&quot; title=&quot;子查询：&quot;&gt;&lt;/a&gt;子查询：&lt;/h6&gt;&lt;p&gt;&amp;emsp;&lt;em&gt;&amp;emsp;一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL连接查询</title>
    <link href="https://7heng.github.io/2021/03/27/MySQL%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/"/>
    <id>https://7heng.github.io/2021/03/27/MySQL%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/</id>
    <published>2021-03-27T02:53:27.000Z</published>
    <updated>2021-03-28T06:19:31.060Z</updated>
    
    <content type="html"><![CDATA[<h6 id="多表连接查询："><a href="#多表连接查询：" class="headerlink" title="多表连接查询："></a>多表连接查询：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">笛卡尔乘积，如果连接条件省略或无效则会出现</span><br><span class="line">解决办法：添加上连接条件。</span><br></pre></td></tr></table></figure><h6 id="传统模式下的连接：等值连接—非等值连接："><a href="#传统模式下的连接：等值连接—非等值连接：" class="headerlink" title="传统模式下的连接：等值连接—非等值连接："></a>传统模式下的连接：等值连接—非等值连接：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：等值连接的结果 &#x3D; 多个表的交集。</span><br><span class="line">2：n表连接，至少需要n-1个连接条件。</span><br><span class="line">3：多个表不分主次，没有顺序要求。</span><br><span class="line">4：一般为表起别名，提高阅读性和性能。</span><br></pre></td></tr></table></figure><h6 id="sql99语法：通过join关键字实现连接。"><a href="#sql99语法：通过join关键字实现连接。" class="headerlink" title="sql99语法：通过join关键字实现连接。"></a>sql99语法：通过join关键字实现连接。</h6><p><em>支持：等值连接、非等值连接、内连接、外连接、交叉连接</em></p><p><em>语法 (好处：语句上，连接条件和筛选条件实现了分离，简洁明了)：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select 字段···</span><br><span class="line">from 表1</span><br><span class="line">[ inner | left outer | right outer | cross ] join 表2 on 连接条件</span><br><span class="line">[ inner | left outer | right outer | cross ] join 表3 on 连接条件</span><br><span class="line">where 筛选条件</span><br><span class="line">group by 分组字段</span><br><span class="line">having 分组后的筛选条件</span><br><span class="line">order by 排序的字段或表达式</span><br></pre></td></tr></table></figure><h6 id="自连接-起别名-："><a href="#自连接-起别名-：" class="headerlink" title="自连接(起别名)："></a>自连接(起别名)：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例：查询员工和直接上级的名称</span><br><span class="line">sql99：</span><br><span class="line"></span><br><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN employees m ON e.manager_id &#x3D; m.employee_id;</span><br><span class="line"></span><br><span class="line">sql92：</span><br><span class="line"></span><br><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e,employees m</span><br><span class="line">WHERE e.manager_id &#x3D; m.employee_id;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">例：等值连接</span><br><span class="line">1：查询员工名、部门名</span><br><span class="line">SELECT last_name,department_name</span><br><span class="line">FROM department d</span><br><span class="line">JOIN employees e</span><br><span class="line">ON e.department_id &#x3D; d.dempartment_id;</span><br><span class="line"></span><br><span class="line">2：查询名字中包含e的员工名和工种名(添加筛选)</span><br><span class="line">SELECT last_name,job_title</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN jobs j</span><br><span class="line">ON e.job_id &#x3D; j.job_id</span><br><span class="line">WHERE e.last_name LIKE &#39;%e%&#39;;</span><br><span class="line"></span><br><span class="line">3：查询部门个数&gt;3的城市名和部门个数(添加分组+筛选)</span><br><span class="line">①：查询每个城市的部门个数</span><br><span class="line">②：在①结果上筛选满足条件的</span><br><span class="line">SELECT city,COUNT(*) 部门个数</span><br><span class="line">FROM departments d</span><br><span class="line">INNER JOIN locations l</span><br><span class="line">ON d.location_id &#x3D; l.location_id</span><br><span class="line">GROUP BY city</span><br><span class="line">HAVING COUNT(*)&gt;3;</span><br><span class="line"></span><br><span class="line">4：查询哪个部门的员工个数&gt;3的部门名和员工个数，并按个数降序(添加排序)</span><br><span class="line">①：查询每个部门的员工个数</span><br><span class="line">SELECT COUNT(*),department_name</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN departments d</span><br><span class="line">ON e.department_id &#x3D; d.department_id</span><br><span class="line">GROUP BY departments_name</span><br><span class="line">②：在①结果上筛选员工个数&gt;3的记录，并排序</span><br><span class="line">SELECT COUNT(*) 个数，department_name</span><br><span class="line">FROM empioyees e</span><br><span class="line">INNER JOIN departments d</span><br><span class="line">ON e.department_id &#x3D; d,department_id</span><br><span class="line">GROUP BY department_name</span><br><span class="line">HAVING COUNT(*)&gt;3</span><br><span class="line">ORDER BY COUNT(*) DESC;</span><br><span class="line"></span><br><span class="line">5:查询员工名、部门名、工作名、并按部门名降序(添加三表连接)</span><br><span class="line">SELECT last_name,department_name,job_title</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN departmens d ON e.department_id &#x3D; d.deparment_id</span><br><span class="line">INNER JOIN jobs j ON e.job_id &#x3D; j.job_id&#x2F;&#x2F;第三个表要与前两个表有联系，否则会出错，顺序可以变。</span><br><span class="line">ORDER BY department_name DESC;</span><br><span class="line"></span><br><span class="line">例：非等值连接</span><br><span class="line">1：查询员工的工资级别</span><br><span class="line">SELECT salary,grade_lever</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN job_grades g</span><br><span class="line">ON e.salary BETWEEN g.lowest_sal AND g.highest_sal;</span><br><span class="line"></span><br><span class="line">2：查询工资级别的个数&gt;20的个数，并且按工资级别降序</span><br><span class="line">SELECT COUNT(*),grade_level</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN job_grades g</span><br><span class="line">ON e.salary BETWEEN g.lowest_sal AND g.highest_sal</span><br><span class="line">GROUP BY grade_leval</span><br><span class="line">HAVING COUNT(*)&gt;20</span><br><span class="line">ORDER BY grade_leval DESC;</span><br><span class="line"></span><br><span class="line">例：自连接</span><br><span class="line">查询员工的名字、上级的名字</span><br><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN employees m</span><br><span class="line">ON e.manager_id &#x3D; m.employee_id</span><br><span class="line">WHERE e.last_name LIKE &#39;%K%&#39;;</span><br></pre></td></tr></table></figure><h6 id="外连接："><a href="#外连接：" class="headerlink" title="外连接："></a>外连接：</h6><p><em>应用场景：用于查询一个表中有，另一个表中没有的记录</em></p><p><strong>特点：</strong></p><p>1：外连接的查询结果为主表中的所有记录</p><p>如果从表中有和它匹配的，则显示匹配的值</p><p>如果从表中没有和它匹配的，则显示null</p><p>外连接查询结果=内连接结果+主表中有而从表没有的记录</p><p>2：左外连接：left join左边的是主表</p><p>&emsp; 右外连接：right join右边的是主表</p><p>3：左外和右外交换两个表的顺序，可以实现同样的效果</p><p>4：全外连接=内连接的结果+表1中右但表2中没有的+表2中有但表1中没有的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">例：查询男友不在男神表的女神名</span><br><span class="line">左外连接：</span><br><span class="line">SELECT b.*,bo.*</span><br><span class="line">FROM boys bo</span><br><span class="line">LEFT OUTER JOIN beauty b</span><br><span class="line">ON b.boyfriend_id &#x3D; bo.id</span><br><span class="line">WHERE b.id IS NULL;</span><br><span class="line"></span><br><span class="line">查询哪个部门没有员工</span><br><span class="line">左外连接：</span><br><span class="line">SEKECT d.*,e.employee_id</span><br><span class="line">FROM departments d</span><br><span class="line">LEFT OUTER JOIN employees e</span><br><span class="line">ON d.department_id &#x3D; e.department_id</span><br><span class="line">WHERE e.enployee_id IS NULL;</span><br><span class="line"></span><br><span class="line">右外连接：</span><br><span class="line">SELECT d.*,e.employee_id</span><br><span class="line">FROM employees e</span><br><span class="line">RIGHT OUTER JOIN departments d</span><br><span class="line">ON d.department_id &#x3D; e.department_id</span><br><span class="line">WHERE e.employee_id IS NULL;</span><br><span class="line"></span><br><span class="line">全外连接：（MySQL中不支持全外连接）</span><br><span class="line">USE girls;</span><br><span class="line">SELECT b.*,bo.*</span><br><span class="line">FROM beayty b</span><br><span class="line">FULL OUTER JOIN boys bo</span><br><span class="line">ON b.boyfriend_id &#x3D; bo.id;</span><br><span class="line"></span><br><span class="line">MySQL中可以使用UNION达到全外连接的效果：</span><br><span class="line">UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</span><br><span class="line">注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。</span><br><span class="line">故实现全外连接可以使用：</span><br><span class="line">SELECT * FROM emp e LEFT JOIN dept d ON e.deptno&#x3D;d.deptno</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM emp e RIGHT JOIN dept d ON e.deptno&#x3D;d.deptno;</span><br><span class="line"></span><br><span class="line">交叉连接：</span><br><span class="line">SELECT b.*,bo.*</span><br><span class="line">FROM beauty b</span><br><span class="line">CROSS JOIN boys bo;</span><br></pre></td></tr></table></figure><h6 id="联合查询："><a href="#联合查询：" class="headerlink" title="联合查询："></a>联合查询：</h6><p><em>union 联合，合并，将多条查询语句的结果合并成为一个结果</em></p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查询语句1</span><br><span class="line">uinon</span><br><span class="line">查询语句2</span><br><span class="line">unoin</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong></p><p><em>要查询的结果来自于多个表</em>，且多个表没有直接的连接关系，但查询的信息一致时。</p><p><strong>特点：</strong></p><p>1：要求多条查询语句的查询列数是一致的。</p><p>2：要求多条查询语句的查询的每一列的类型和顺序最好一致。</p><p>3：union关键字默认去重，如果使用union all 可以包含重复项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例1：查询部门编号&gt;90或邮箱包含a的员工的信息。</span><br><span class="line">SEKECT * FROM employees WHERE email LIKE &#39;%a%&#39; OR department_id&gt;90;</span><br><span class="line">联合查询：</span><br><span class="line">SELECT * FROM employees WHERE email LIKE &#39;%a%&#39;</span><br><span class="line">UNION </span><br><span class="line">SELECT * FROM employees WHERE department_id&gt;90;</span><br><span class="line"></span><br><span class="line">2：查询中国用户中男性的信息以及外国用户中年男性的用户信息</span><br><span class="line">SELECT id_name,cname FROM t_ca WHERE csex&#x3D;&#39;男&#39;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT t_id,tname FROM t_id WHERE tGender&#x3D;&#39;male&#39;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;多表连接查询：&quot;&gt;&lt;a href=&quot;#多表连接查询：&quot; class=&quot;headerlink&quot; title=&quot;多表连接查询：&quot;&gt;&lt;/a&gt;多表连接查询：&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL函数</title>
    <link href="https://7heng.github.io/2021/03/26/MySQL%E5%87%BD%E6%95%B0/"/>
    <id>https://7heng.github.io/2021/03/26/MySQL%E5%87%BD%E6%95%B0/</id>
    <published>2021-03-26T12:15:20.000Z</published>
    <updated>2021-03-26T12:42:48.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h2><h6 id="字符函数："><a href="#字符函数：" class="headerlink" title="字符函数："></a>字符函数：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">concat 拼接</span><br><span class="line"></span><br><span class="line">substr 截取子串</span><br><span class="line"></span><br><span class="line">upper 转换成大写</span><br><span class="line"></span><br><span class="line">lower 转换成小写</span><br><span class="line"></span><br><span class="line">trim 去掉前后自定的空格和字符</span><br><span class="line"></span><br><span class="line">ltrim 去掉左边空格</span><br><span class="line"></span><br><span class="line">rtrim 去掉右边空格</span><br><span class="line"></span><br><span class="line">replace 替换</span><br><span class="line"></span><br><span class="line">lpad 左填充</span><br><span class="line"></span><br><span class="line">rpad 右填充</span><br><span class="line"></span><br><span class="line">instr 返回子串第一次出现的索引</span><br><span class="line"></span><br><span class="line">length 获取字节个数</span><br></pre></td></tr></table></figure><h6 id="数组函数："><a href="#数组函数：" class="headerlink" title="数组函数："></a><strong>数组函数：</strong></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">round 四舍五入</span><br><span class="line"></span><br><span class="line">rand 随机数</span><br><span class="line"></span><br><span class="line">ceil 向上取整</span><br><span class="line"></span><br><span class="line">floor 向下取整</span><br><span class="line"></span><br><span class="line">mod 取余()</span><br><span class="line"></span><br><span class="line">truncate 截断</span><br></pre></td></tr></table></figure><h6 id="日期函数："><a href="#日期函数：" class="headerlink" title="日期函数："></a><strong>日期函数：</strong></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">now 当前系统日期+时间</span><br><span class="line"></span><br><span class="line">curdate 当前系统日期</span><br><span class="line"></span><br><span class="line">curtime 当前系统时间</span><br><span class="line"></span><br><span class="line">str_to_date 将字符串转换成日期</span><br><span class="line"></span><br><span class="line">data_format 将日期转换成字符</span><br></pre></td></tr></table></figure><h6 id="分组函数："><a href="#分组函数：" class="headerlink" title="分组函数："></a>分组函数：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sum 求和</span><br><span class="line">max 最大值</span><br><span class="line">min 最小值</span><br><span class="line">avg 平均值</span><br><span class="line">count 计数</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">1：以上五个分组函数都忽略null值，除了count(*)</span><br><span class="line">2：sum和avg一般用于处理数值型。</span><br><span class="line">   max、min、count可以处理任何数据类型</span><br><span class="line">3：都可以搭配distinct使用，用于统计去重后的结果</span><br><span class="line">4：count的参数可以支持(建议使用*)：</span><br><span class="line">字段、*、常量值，一般放1</span><br></pre></td></tr></table></figure><h6 id="流程控制函数："><a href="#流程控制函数：" class="headerlink" title="流程控制函数："></a>流程控制函数：</h6><h6 id="if函数："><a href="#if函数：" class="headerlink" title="if函数："></a>if函数：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT IF (10&lt;5, &#39;大&#39; , &#39;小&#39;)；</span><br><span class="line"></span><br><span class="line">SELECT last_name,commission_pct,IF(commission_pct IS NULL,&#39;没奖金，呵呵&#39;,&#39;有奖金，嘻嘻&#39;) 备注</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><h6 id="case函数："><a href="#case函数：" class="headerlink" title="case函数："></a>case函数：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">case函数的使用一：</span><br><span class="line"></span><br><span class="line">case 要判断的字段或表达式</span><br><span class="line">when 常量1 then 要显示的值1或语句1;</span><br><span class="line">when 常量2 then 要显示的值2或语句2;</span><br><span class="line">...</span><br><span class="line">else 要显示的值n或语句n;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">例：查询员工的工资，要求</span><br><span class="line">部门号&#x3D;30，显示的工资为1.1倍</span><br><span class="line">部门号&#x3D;40，显示的工资为1.2倍</span><br><span class="line">部门号&#x3D;50，显示的工资为1.3倍</span><br><span class="line">其他部门，显示的工资为元工资</span><br><span class="line"></span><br><span class="line">SELECT salary 原始工资,department_id,</span><br><span class="line">CASE department_id</span><br><span class="line">WHEN 30 THEN salary*1.1</span><br><span class="line">WHEN 40 THEN salary*1.2</span><br><span class="line">WHEN 50 THEN salary*1.3</span><br><span class="line">ELSE salary</span><br><span class="line">END AS 新工资</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">case函数的使用二：类似于 多重if</span><br><span class="line"></span><br><span class="line">case </span><br><span class="line">when 条件1 then 要显示的值1或语句1</span><br><span class="line">when 条件2 then 要显示的值2或语句2</span><br><span class="line">。。。</span><br><span class="line">else 要显示的值n或语句n</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">例：查询员工的工资的情况</span><br><span class="line">如果工资&gt;20000,显示A级别</span><br><span class="line">如果工资&gt;15000,显示B级别</span><br><span class="line">如果工资&gt;10000,显示C级别</span><br><span class="line">否则，显示D级别</span><br><span class="line"></span><br><span class="line">SELECT salary</span><br><span class="line">CASE</span><br><span class="line">WHEN salary&gt;20000 THEN &#39;A&#39;</span><br><span class="line">WHEN salary&gt;15000 THEN &#39;B&#39;</span><br><span class="line">WHEN salary&gt;10000 THEN &#39;C&#39;</span><br><span class="line">ELSE &#39;D&#39;</span><br><span class="line">END AS 工资级别</span><br><span class="line">FROM emplyees;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;函数：&quot;&gt;&lt;a href=&quot;#函数：&quot; class=&quot;headerlink&quot; title=&quot;函数：&quot;&gt;&lt;/a&gt;函数：&lt;/h2&gt;&lt;h6 id=&quot;字符函数：&quot;&gt;&lt;a href=&quot;#字符函数：&quot; class=&quot;headerlink&quot; title=&quot;字符函数：&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java接口</title>
    <link href="https://7heng.github.io/2021/03/25/java%E6%8E%A5%E5%8F%A3/"/>
    <id>https://7heng.github.io/2021/03/25/java%E6%8E%A5%E5%8F%A3/</id>
    <published>2021-03-25T13:55:50.000Z</published>
    <updated>2021-03-25T14:16:32.068Z</updated>
    
    <content type="html"><![CDATA[<h6 id="接口的定义："><a href="#接口的定义：" class="headerlink" title="接口的定义："></a>接口的定义：</h6><p><strong>接口就是抽象方法和常量的集合，从本质上讲，接口是一种特殊的抽象类</strong>。</p><p>1：接口中定义的属性必须是public static final的，而接口中定义的方法必须是public abstract的，因此这些修饰符可以部分或全部忽略。</p><p>2：接口中定义的属性的值在实现类中不能被更改。</p><p>3：一个类中只能实现某个接口，不能继承某个接口。</p><p>4：接口可以继承接口，而且允许继承多个接口，即接口多继承 (一定程度上弥补了java不能多继承)。</p><p>5：如果一个类只实现了一个接口的部分方法，则该类必须声明为抽象类。</p><p>6：一个类可以在继承一个父类的同时实现一个或多个接口，但extends必须在implements之前。</p><p>7：不可以new接口，但可以定义一个接口引用类型的变量并将其指向实现接口对象，达到多态的目的。</p><h6 id="接口的作用："><a href="#接口的作用：" class="headerlink" title="接口的作用："></a>接口的作用：</h6><p>1：通过接口可以实现不相关类的相同行为。</p><p>&emsp;&emsp;例如java规定所有可以完成自我复制功能的类都必须实现java.lang.Colneable接口，但该接口缺是空的，该接口中没有任何内容，目的只是为了起个标志作用。</p><p>2：接口提供了不同对象进行协作的平台。</p><p>&emsp;&emsp;如事件处理</p><p>3：接口可以实现多继承，从一定程度上弥补了类只能单继承的缺陷。</p><p>4：接口时我们了解一个类功能的重要途径。</p><p>&emsp;&emsp;如：java整个容器框架就是以接口的方式建立起来的，实现不同接口的类完成的是不同的功能，接口是我们了解一个类功能的重要途径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">interface It&#123;</span><br><span class="line">int j &#x3D; 20;      &#x2F;&#x2F; 全称： public static final int j &#x3D; 20;</span><br><span class="line">public void f();&#x2F;&#x2F; 全称： public abstact void f();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface It2&#123;</span><br><span class="line">int i &#x3D; 20;</span><br><span class="line">void f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface It3 extends It, It2&#123;       &#x2F;&#x2F;  接口可以继承接口，而且允许继承多个接口，即接口多继承。</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">class A extends It2&#123;                error   类不能继承接口。</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">class A implements It2&#123;            &#x2F;&#x2F;   implements 不能改为extends。   类只能实现接口。</span><br><span class="line"></span><br><span class="line">public void f()&#123;  &#x2F;&#x2F;public 不可省略。(重写的权限不能低。)   如果方法不是接口中的方法或者只实现接口中的部分方法。 则该类必须是抽象类。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;i &#x3D; 99;       error。   i 为 final类型。</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A implements It, It2&#123; &#x2F;&#x2F; 一个类可以在继承一个父类的同时实现一个或多个接口，但extends关键字必须在implements之前。</span><br><span class="line">public void f()&#123;</span><br><span class="line"></span><br><span class="line">System.out.printf(&quot;恒子恒子恒子&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void g()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Interface1&#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">It it;</span><br><span class="line">it &#x3D; new B();</span><br><span class="line">it.f();&#x2F;&#x2F;  多态！！</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;it.g();  error 通过接口的引用，只能调用子类从父类继承过来的成员，不能调用子类特有的成员。</span><br><span class="line">&#x2F;&#x2F;It it &#x3D; new It();  error。</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;接口的定义：&quot;&gt;&lt;a href=&quot;#接口的定义：&quot; class=&quot;headerlink&quot; title=&quot;接口的定义：&quot;&gt;&lt;/a&gt;接口的定义：&lt;/h6&gt;&lt;p&gt;&lt;strong&gt;接口就是抽象方法和常量的集合，从本质上讲，接口是一种特殊的抽象类&lt;/strong&gt;。&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java线程</title>
    <link href="https://7heng.github.io/2021/03/24/java%E7%BA%BF%E7%A8%8B/"/>
    <id>https://7heng.github.io/2021/03/24/java%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-03-24T12:24:40.000Z</published>
    <updated>2021-03-24T13:25:15.170Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">例1：实现Runnable接口创建多线程；正确的程序。</span><br><span class="line">class A implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">public int tickets &#x3D; 10000;</span><br><span class="line">String str &#x3D; new String(&quot;恒恒恒&quot;);</span><br><span class="line"></span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">synchronized (str)&#x2F;&#x2F; 同步代码块。</span><br><span class="line">&#123;</span><br><span class="line">if (tickets &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">System.out.printf(&quot;%s线程正在卖出第%d张票\n&quot;,</span><br><span class="line">Thread.currentThread().getName(), tickets);</span><br><span class="line">--tickets;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestTickets_2</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">A aa &#x3D; new A();</span><br><span class="line">Thread t1 &#x3D; new Thread(aa);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">​Thread t2 &#x3D; new Thread(aa);</span><br><span class="line">​t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">理解：因为是实现了Runnable接口，所以不管是t1,t2都只是传递了类A造出来的一个对象aa,因此t1,t2所访问的tickets和str都是同一个类中的属性,并不用去设置为static。所以Tickets相同，同步代码块锁定的是同一个对象，因此程序正确。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">例2：直接继承Thread类的方法；正确的程序。</span><br><span class="line">class A extends Thread</span><br><span class="line">&#123;</span><br><span class="line">public static int tickets &#x3D; 1000;  &#x2F;&#x2F;static不能省</span><br><span class="line">public static String str &#x3D; new String(&quot;哈哈&quot;);  &#x2F;&#x2F;static不能省</span><br><span class="line"></span><br><span class="line">public void run()&#x2F;&#x2F;  重写Thread类中的run方法，所以上两行的static不能省略。</span><br><span class="line">&#123;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">synchronized (str)&#x2F;&#x2F; 同步代码块。</span><br><span class="line">&#123;</span><br><span class="line">if (tickets &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">System.out.printf(&quot;%s线程正在卖出第%d张票\n&quot;,</span><br><span class="line">Thread.currentThread().getName(), tickets);</span><br><span class="line">--tickets;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestTickets_3</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">A aa1 &#x3D; new A();</span><br><span class="line">aa1.start();</span><br><span class="line">&#x2F;&#x2F;  堆中存在两个对象  ok！</span><br><span class="line">A aa2 &#x3D; new A();</span><br><span class="line">aa2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">理解：继承Thread类的A类new出来两个对象aa1和aa2,本该是每个对象都有一个类A的属性，但因为类A中的属性是static,所以aa1和aa2共同拥有tickets和str,所以同步代码块的对象相同，出售的tickets相同，因此程序正确。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">例3：直接继承Thread类的方法；正确的程序。</span><br><span class="line">class A extends Thread</span><br><span class="line">&#123;</span><br><span class="line">public static int tickets &#x3D; 1000;  &#x2F;&#x2F;static不能省</span><br><span class="line">public String str &#x3D; new String(&quot;恒恒恒&quot;);  &#x2F;&#x2F;static不能省</span><br><span class="line"></span><br><span class="line">public void run()&#x2F;&#x2F; 重写Thread类中的run方法，所以上两行的static不能省略。</span><br><span class="line">&#123;</span><br><span class="line">String str &#x3D; &quot;恒子&quot;;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">synchronized (str)&#x2F;&#x2F; 同步代码块。</span><br><span class="line">&#123;</span><br><span class="line">if (tickets &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">System.out.printf(&quot;%s线程正在卖出第%d张票\n&quot;,</span><br><span class="line">Thread.currentThread().getName(), tickets);</span><br><span class="line">--tickets;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestTickets_4</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">A aa1 &#x3D; new A();</span><br><span class="line">aa1.start();</span><br><span class="line">&#x2F;&#x2F; 堆中存在两个对象</span><br><span class="line">A aa2 &#x3D; new A();</span><br><span class="line">aa2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">理解：继承Thread类的A类new出来两个对象aa1和aa2,本该是每个对象都有一个类A的属性，但因为类A中的tickets属性是static,所以aa1和aa2共拥tickets属性，但str是非static的，所以同步代码块中的对象并不是同一个对象，但是在执行run()方法时,又重新定义了在数据区的str,所以同步代码块绑定的还是同一个对象，因此该程序正确。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">例4：调用Runnable接口的方法；正确的程序。</span><br><span class="line">class A implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">public static int tickets &#x3D; 1000;</span><br><span class="line">String  str &#x3D; new String(&quot;恒&quot;);&#x2F;&#x2F;   new出来的str在堆区，两种调用的话会不是同一个str;</span><br><span class="line"></span><br><span class="line">public void run()  </span><br><span class="line">&#123;</span><br><span class="line">String str &#x3D; &quot;恒子&quot;;  &#x2F;&#x2F; 局部变量str， 在数据区，是同一个str;</span><br><span class="line"></span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">synchronized (str)    &#x2F;&#x2F; 需要synchronized(类对象名)</span><br><span class="line">&#123;</span><br><span class="line">if (tickets &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">System.out.printf(&quot;%s线程正在卖出第%d张票\n&quot;,</span><br><span class="line">Thread.currentThread().getName(), tickets);</span><br><span class="line">--tickets;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestTickets_9</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">A aa &#x3D; new A();</span><br><span class="line">A bb &#x3D; new A();</span><br><span class="line">Thread t1 &#x3D; new Thread(aa);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​Thread t2 &#x3D; new Thread(bb);</span><br><span class="line">​t2.start();</span><br><span class="line">​</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">理解：类A实现了Runnable接口，该程序与例1相似，但该程序类A new出了两个对象，因此开辟了两块空间，t1,t2的引用分别是aa和bb,并非同一个引用，但在类A中，Tickets是static的，所以t1,t2还是共同拥有同一个Tickets,但str对于t1,t2来说就不是同一个属性，可是，在执行run()方法的时候，里面定义了在数据区的局部变量str,这又重新使得同步代码块中t1,t2所绑定的对象是同一个对象。因此该程序也是正确的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">例5：实现Runnable接口的方法；错误的程序。</span><br><span class="line">class A implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">public static int tickets &#x3D; 1000;</span><br><span class="line">String  str &#x3D; new String(&quot;恒恒恒恒&quot;);&#x2F;&#x2F;   new出来的str在堆区，两种调用的话会不是同一个str;</span><br><span class="line"></span><br><span class="line">public void run()  </span><br><span class="line">&#123;</span><br><span class="line">​while (true)</span><br><span class="line">​&#123;</span><br><span class="line">​synchronized (str)    &#x2F;&#x2F; 需要synchronized(类对象名)</span><br><span class="line">​&#123;</span><br><span class="line">​if (tickets &gt; 0)</span><br><span class="line">​&#123;</span><br><span class="line">​System.out.printf(&quot;%s线程正在卖出第%d张票\n&quot;,</span><br><span class="line">​Thread.currentThread().getName(), tickets);</span><br><span class="line">​--tickets;</span><br><span class="line">​&#125;</span><br><span class="line">​else</span><br><span class="line">​&#123;</span><br><span class="line">​break;</span><br><span class="line">​&#125;</span><br><span class="line">​&#125;</span><br><span class="line">​&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestTickets_9</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">A aa &#x3D; new A();</span><br><span class="line">A bb &#x3D; new A();</span><br><span class="line">Thread t1 &#x3D; new Thread(aa);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">​Thread t2 &#x3D; new Thread(bb);</span><br><span class="line">​t2.start();</span><br><span class="line">​</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">理解：(对比例4)，少了run()方法中的String str &#x3D; &quot;恒子&quot;;所以同步代码块中的对象并未是统一对象，因此该程序错误。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">例6：直接继承Thread类的方法；错误的程序。</span><br><span class="line">class A extends Thread</span><br><span class="line">&#123;</span><br><span class="line">public static int tickets &#x3D; 1000;  &#x2F;&#x2F;static不能省</span><br><span class="line">public String str &#x3D; new String(&quot;恒恒恒&quot;);  &#x2F;&#x2F;static不能省</span><br><span class="line"></span><br><span class="line">public void run()&#x2F;&#x2F; 重写Thread类中的run方法，所以上两行的static不能省略。</span><br><span class="line">&#123;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">synchronized (str)&#x2F;&#x2F; 同步代码块。</span><br><span class="line">&#123;</span><br><span class="line">if (tickets &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">System.out.printf(&quot;%s线程正在卖出第%d张票\n&quot;,</span><br><span class="line">Thread.currentThread().getName(), tickets);</span><br><span class="line">--tickets;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestTickets_4</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">A aa1 &#x3D; new A();</span><br><span class="line">aa1.start();</span><br><span class="line">&#x2F;&#x2F; 堆中存在两个对象</span><br><span class="line">A aa2 &#x3D; new A();</span><br><span class="line">aa2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">理解：(对比例3)继承Thread类的A类new出来两个对象aa1和aa2,本该是每个对象都有一个类A的属性，但因为类A中的tickets属性是static,所以aa1和aa2共拥tickets属性，但str是非static的，所以同步代码块中的对象并不是同一个对象，因此该程序错误。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL基础查询</title>
    <link href="https://7heng.github.io/2021/03/24/MySQL%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2/"/>
    <id>https://7heng.github.io/2021/03/24/MySQL%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2/</id>
    <published>2021-03-24T05:49:23.000Z</published>
    <updated>2021-03-27T11:46:20.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h2><h6 id="基础查询："><a href="#基础查询：" class="headerlink" title="基础查询："></a>基础查询：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 要查询的内容 from 表名;</span><br></pre></td></tr></table></figure><h6 id="条件查询："><a href="#条件查询：" class="headerlink" title="条件查询："></a>条件查询：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 要查询的字段|表达式|常量值|函数</span><br><span class="line"></span><br><span class="line"> from 表名</span><br><span class="line"></span><br><span class="line">where 条件;</span><br></pre></td></tr></table></figure><h6 id="模糊查询："><a href="#模糊查询：" class="headerlink" title="模糊查询："></a>模糊查询：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(LIKE):一般和通配符% _搭配使用。</span><br><span class="line">例：查询员工名中包含字符a的员工信息。</span><br><span class="line">SELECT  *</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE</span><br><span class="line">last_name like &#39;%a%&#39;;</span><br><span class="line">查询员工名中第三个字符为e,第五个字符为a的员工名和工资</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name LIKE &#39;__e_a%&#39;;（%:任意多个字符,包含0个字符。_:任意单个字符）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(BETWEEN AND):包含两个临界值;两个临界值不能调换顺序。</span><br><span class="line">例：查询员工编号在100~200之间的员工信息</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employees_id &gt;&#x3D; 100 AND employees_id &lt;&#x3D;200;</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employees_id BETWEEN 100 AND  200;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(IN):用来判断某字段的值是否属于IN列表中的某一项;IN列表的值类型必须一致或兼容;IN列表中不支持通配符。</span><br><span class="line">例：查询员工的工种编号是IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号</span><br><span class="line">SELECT last_name,job_id</span><br><span class="line">FROM emplyoees</span><br><span class="line">WHERE job_id &#x3D; &#39;IT_PROG&#39; OR jod_id &#x3D; &#39;AD_VP&#39; OR job_id &#x3D; &#39;AD_PRES&#39;;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">SELECT</span><br><span class="line">last_name,</span><br><span class="line">job_id</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE</span><br><span class="line">job_id IN( &#39;IT_PROT&#39; ,&#39;AD_VP&#39;,&#39;AD_PRES&#39;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(IS NULL):&#x3D;或!&#x3D;和&lt;&gt;不能用来判断NULL值，IS NULL或IS NOT NULL可以判断NULL值。</span><br><span class="line">例：查询没有奖金的员工名和奖金率</span><br><span class="line">SELECT</span><br><span class="line">last_name,</span><br><span class="line">commission_pct</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE</span><br><span class="line">commission_pct IS NULL;</span><br><span class="line">例：查询有奖金的员工和奖金率</span><br><span class="line">SELECT</span><br><span class="line">last_name,</span><br><span class="line">commission_pct</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE</span><br><span class="line">commission_pct IS NOT NULL;</span><br><span class="line">----------------------------------</span><br><span class="line">SELECT</span><br><span class="line">last_name,</span><br><span class="line">commission_pct</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE </span><br><span class="line">salary IS 12000;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">安全等于&lt;&#x3D;&gt;</span><br><span class="line">例：查询没有奖金的员工和奖金率</span><br><span class="line">SELECT</span><br><span class="line">last_name,</span><br><span class="line">commission_pct</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE</span><br><span class="line">commission_pct &lt;&#x3D;&gt;NULL;</span><br><span class="line">例：查询工资为12000的员工信息</span><br><span class="line">SELECT</span><br><span class="line">last_name,</span><br><span class="line">salary</span><br><span class="line">FROM</span><br><span class="line">employees</span><br><span class="line">WHERE </span><br><span class="line">salary &lt;&#x3D;&gt; 12000;</span><br></pre></td></tr></table></figure><p><strong>IS NULL：仅仅可以判断NULL值，可读性较高(建议使用)。</strong></p><p><strong>&lt;=&gt;：既可以判断NULL值，又可以判断普通的数值，可读性较低。</strong></p><h6 id="排序查询："><a href="#排序查询：" class="headerlink" title="排序查询："></a>排序查询：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 要查询的内容 from 表</span><br><span class="line"></span><br><span class="line">where 条件</span><br><span class="line"></span><br><span class="line">order by 排序的字段|表达式|函数|别名 asc(默认升序)或desc(降序)</span><br></pre></td></tr></table></figure><h6 id="分组查询："><a href="#分组查询：" class="headerlink" title="分组查询："></a>分组查询：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">select  分组函数，列(要求出现在GROUP BY 后面)</span><br><span class="line">form 表</span><br><span class="line">【where 筛选条件】</span><br><span class="line">group by 分组的列表</span><br><span class="line">【order by 子句】</span><br></pre></td></tr></table></figure><p>注意：查询列表必须特殊，要求是分组函数和group by 后出现的字段。</p><p><strong>特点：</strong></p><p>1：和分组函数一同查询的字段必须是group by后出现的字段。</p><p>2：筛选分为两类：分组前筛选和分组后筛选</p><p>分组前筛选：原始表</p><p>分组后筛选：group by后的结果集</p><p>group by 前用关键字where，group by后用关键字 having</p><p>分组筛选不能放在where后面。</p><p>3：分组函数做条件肯定是放在having子句中。</p><p>能用分组前筛选的，优先考虑使用分组前筛选</p><p>4：group by 子句支持单个字段分组，多个字段分组(多个字段之间用逗号隔开没有顺序要求)，表达式或函数(较少使用)。</p><p>5：也可以添加排序（排序放在整个分组查询的最后)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">select 要查询的字段,分组函数 from 表</span><br><span class="line">where 筛选条件</span><br><span class="line">group by 分组的字段</span><br><span class="line">order by 排序的字段</span><br><span class="line"></span><br><span class="line">查询每个部门的员工个数：</span><br><span class="line">SELECT COUNT(*) FROM employees WHERE department_id &#x3D; 90;</span><br><span class="line">简单的分组：</span><br><span class="line">1：查询每个工种的员工的平均工资</span><br><span class="line">SELECT AVG(salary),job_id</span><br><span class="line">FROM emplyoees</span><br><span class="line">GROUP BY job_id;</span><br><span class="line"></span><br><span class="line">2：查询每个位置的部门个数</span><br><span class="line">SELECT COUNT(*),location_id</span><br><span class="line">FROM department</span><br><span class="line">GROUP BY location_id;</span><br><span class="line"></span><br><span class="line">3：实现分组前的筛选</span><br><span class="line">查询邮箱中包含a字符的每个部门的最高工资</span><br><span class="line">SELECT MAX(salary),manager_id</span><br><span class="line">FROM emplyoees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY manager_id;</span><br><span class="line"></span><br><span class="line">分组后筛选</span><br><span class="line">①：查询每个部门的员工个数</span><br><span class="line">SELECT COUNT(*),department_id</span><br><span class="line">FROM emplyoees</span><br><span class="line">GROUP BY departments_id;</span><br><span class="line"></span><br><span class="line">②：筛选①的结果，查询哪个部门的员工个数&gt;5</span><br><span class="line">SELECT COUNT(*),department_id</span><br><span class="line">FROM emplyoees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING COUNT(*)&gt;5;</span><br><span class="line"></span><br><span class="line">4：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</span><br><span class="line">SELECT job_id,MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY job_id</span><br><span class="line">HAVING MAX(salary)&gt;12000;</span><br><span class="line"></span><br><span class="line">5：领导编号&gt;102的每个领导手下的最低工资大于5000的领导编号和最低工资</span><br><span class="line">manager_id&gt;102</span><br><span class="line">SELECT manager_id,MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY manager_id</span><br><span class="line">HAVING MIN(salary)&gt;5000;</span><br><span class="line"></span><br><span class="line">6.添加排序</span><br><span class="line">例：每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序</span><br><span class="line">SELECT job_id,MAX(salary) m</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY job_id</span><br><span class="line">HAVING m&gt;6000</span><br><span class="line">ORDER BY m ;</span><br><span class="line"></span><br><span class="line">7.按多个字段分组</span><br><span class="line">例：查询每个工种每个部门的最低工资,并按最低工资降序</span><br><span class="line">SELECT MIN(salary),job_id,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id,job_id</span><br><span class="line">ORDER BY MIN(salary) DESC;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;查询：&quot;&gt;&lt;a href=&quot;#查询：&quot; class=&quot;headerlink&quot; title=&quot;查询：&quot;&gt;&lt;/a&gt;查询：&lt;/h2&gt;&lt;h6 id=&quot;基础查询：&quot;&gt;&lt;a href=&quot;#基础查询：&quot; class=&quot;headerlink&quot; title=&quot;基础查询：&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL基础</title>
    <link href="https://7heng.github.io/2021/03/23/MySQL%E5%9F%BA%E7%A1%80/"/>
    <id>https://7heng.github.io/2021/03/23/MySQL%E5%9F%BA%E7%A1%80/</id>
    <published>2021-03-23T11:09:53.000Z</published>
    <updated>2021-03-28T06:25:22.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库基础："><a href="#数据库基础：" class="headerlink" title="数据库基础："></a>数据库基础：</h1><p><strong>DB：</strong>    数据库，保存一组有组织的的数据的容器。</p><p><strong>DBMS：</strong>数据库管理系统，又称为数据库软件(产品)，用于管理DB中的数据。</p><p><strong>SQL：</strong>结构化查询语言，用于和DBMS通信的语言。</p><p><strong>DML：</strong>插入、修改、删除。</p><p><strong>DDL：</strong>库和表的管理、常见数据类型介绍、常见约束。</p><p><strong>TCL：</strong>事务和事务处理。</p><h2 id="数据库存储数据的特点："><a href="#数据库存储数据的特点：" class="headerlink" title="数据库存储数据的特点："></a>数据库存储数据的特点：</h2><p>​    1：将数据放到表中，表再放到库中。</p><p>​    2：一个数据库中可以有多个表，每个表都有一个名字，用来标识自己，表名具有唯一性。</p><p>​    3：表具有一些特性，这些特性定义了数据在表中如何存储。</p><p>​    4：表由列组成，也成为字段。所有表都是由以一个或多个列组成。</p><p>​    5：表中的数据是按行存储的。</p><h2 id="MySQL服务的启动和停止："><a href="#MySQL服务的启动和停止：" class="headerlink" title="MySQL服务的启动和停止："></a>MySQL服务的启动和停止：</h2><p>​    方式一：计算机–&gt;右键管理–&gt;服务</p><p>​    方式二：管理员身份运行DOS</p><p>​    net start 服务名  (启动服务)</p><p>​    net stop 服务名  (停止服务)</p><h2 id="MySQL服务的登录和退出："><a href="#MySQL服务的登录和退出：" class="headerlink" title="MySQL服务的登录和退出："></a>MySQL服务的登录和退出：</h2><p>​    方式一：通过MySQL自带的客户端（只限于root用户）</p><p>​    方式二：通过windows自带的客户端</p><p>​        登录：<code>mysql [ -h主机名 -p端口号 ] -u用户名 -p密码</code></p><h2 id="MySQL常用基本命令："><a href="#MySQL常用基本命令：" class="headerlink" title="MySQL常用基本命令："></a>MySQL常用基本命令：</h2><p>​    1：查看当前所有的数据库：    <code>show    databases;</code></p><p>​     2：打开指定的库：    <code>use 库名;</code></p><p>​    3：查看当前库的所有表：    <code>show tables;</code></p><p>​    4：查看其它库的所有表：<code>show table from 库名;</code></p><p>​    5：创建表：</p><p><code>create table 表明（</code></p><p><code>列名 列类型,</code></p><p><code>列名 列类型,</code></p><p><code>...</code>                                </p><p><code>）;</code></p><p>​    6：查看表结构：    <code>desc 表名;</code></p><h3 id="SQL语言的分类："><a href="#SQL语言的分类：" class="headerlink" title="SQL语言的分类："></a>SQL语言的分类：</h3><p>DQL（Data Query Language)：数据查询语言</p><p>​    <code>select</code></p><p>DML（Data Manipulate Language)：数据操作语言</p><p>​    <code>insert、update、delete</code></p><p>DDL（Data Define Languge）：数据定义语言<br>        <code>create、drop、alter</code><br>    TCL（Transaction Control Language）：事务控制语言<br>        <code>commit、rollback</code></p><h3 id="SQL的常见命令："><a href="#SQL的常见命令：" class="headerlink" title="SQL的常见命令："></a>SQL的常见命令：</h3><p><code>show databases;</code>    查看所有的数据库。</p><p>use 库名;    打开指定的库。</p><p><code>show tables from 库名;</code>    显示指定库中的所有表。</p><p><code>ceeate table 表名(</code></p><p>​                <code>字段名 字段类型，</code></p><p>​                <code>字段名 字段类型</code></p><p><code>)；</code>    创建表。</p><p><code>desc 表名;</code>    查看指定表的结构。</p><p><code>select * from 表名;</code>    显示表中所有数据。</p><h3 id="起别名"><a href="#起别名" class="headerlink" title="起别名:"></a>起别名:</h3><p><strong>(使用AS)：</strong><code>SELECT 100%98 AS 结果;</code></p><p><code>SELECT last_name AS 姓,first_name 名 FROM 表名;</code></p><p><strong>(使用空格)：</strong><code>SELECT last_name AS 姓,first_name AS 名 FROM 表名;</code></p><h3 id="去重："><a href="#去重：" class="headerlink" title="去重："></a>去重：</h3><p>例：查询员工表中涉及到的所有的部门编号</p><p><code>SELECT DISTINCT department_id FROM 表名;</code></p><h3 id="号："><a href="#号：" class="headerlink" title="+号："></a>+号：</h3><p><strong>java中的+号：</strong></p><p>1：运算符，两个操作数都为数值型。</p><p>2：连接符，只要有一个操作数为字符串。</p><p><strong>MySQL中的+号：</strong></p><p>仅有一个功能，运算符。</p><p><code>select 100+90;</code>两个操作数都为数值型，则做加法运算。</p><p><code>select &#39;123&#39;+90;</code> 只要其中一个为字符型,试图将字符型数值转换成数值型，如果转换成功，则继续做加法运算。</p><p><code>select &#39;heng&#39;+22;</code> 如果转换失败，则将字符型数值转换成0。</p><p><code>select null+10;</code> 只要其中一方为null,结果肯定为null。</p><h3 id="连接："><a href="#连接：" class="headerlink" title="连接："></a>连接：</h3><p>例：查询员工姓名和姓连接成一个字段，并显示为姓名。</p><p><code>SELECT (last_name,first_name) AS 姓名 FROM 表名;</code></p><p><strong>补充一个计算机中取余小知识：</strong></p><p><code>a % b = a - a/b*b;</code></p><p>​        </p><p>​    </p><p>​            </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库基础：&quot;&gt;&lt;a href=&quot;#数据库基础：&quot; class=&quot;headerlink&quot; title=&quot;数据库基础：&quot;&gt;&lt;/a&gt;数据库基础：&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;DB：&lt;/strong&gt;    数据库，保存一组有组织的的数据的容器。&lt;/p&gt;
&lt;p&gt;&lt;st</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>编码</title>
    <link href="https://7heng.github.io/2021/01/16/%E7%BC%96%E7%A0%81/"/>
    <id>https://7heng.github.io/2021/01/16/%E7%BC%96%E7%A0%81/</id>
    <published>2021-01-16T10:32:15.000Z</published>
    <updated>2021-03-25T13:44:51.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BCD码："><a href="#BCD码：" class="headerlink" title="BCD码："></a>BCD码：</h1><p>4个二进制位 (4bit) —-&gt; 1个十进制位，又因为4个二进制位有2的4次方种状态，也就是16种状态。</p><p>16种状态足够表示十进制的0~9，并且还有6种冗余。</p><h2 id="8421码："><a href="#8421码：" class="headerlink" title="8421码："></a>8421码：</h2><p>8421码的映射关系：</p><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="center">0000</td><td align="center">0001</td><td align="center">0010</td><td align="center">0011</td><td align="center">0100</td><td align="center">0101</td><td align="center">0110</td><td align="center">0111</td><td align="center">1000</td><td align="center">1001</td></tr></tbody></table><p>8421码在计算机中进行加法运算：</p><p>​    十进制：    5    +    8    =13</p><p>​    8421码：    0101    +    1000    =1101</p><p>​    因为1101不再映射表里，所以需要加上冗余的6，也就是0110</p><p>​    所以1101+0110=1 0011</p><p>​    0011在映射表里为3，在高位的1前面补0为0001</p><p>​    所以0001 0011在映射表里为13</p><p><strong>注：若相加结果在合法范围内，则无需修正</strong>。（因为8421码的二进制位的权值是固定不变的8421，所以8421码也成为<strong>有权码</strong>）</p><h2 id="余3码："><a href="#余3码：" class="headerlink" title="余3码："></a>余3码：</h2><p>余3码映射表：( 8421码 + 0011 (二进制) )</p><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="center">0011</td><td align="center">0100</td><td align="center">0101</td><td align="center">0110</td><td align="center">0111</td><td align="center">1000</td><td align="center">1001</td><td align="center">1010</td><td align="center">1011</td><td align="center">1100</td></tr></tbody></table><ul><li>余3码的四个二进制每一个二进制没有固定的权值，所以余3码也成为<strong>无权码</strong></li></ul><h2 id="2421码："><a href="#2421码：" class="headerlink" title="2421码："></a>2421码：</h2><p>2421码映射表：(与8421码不同是改变了权值的定义)</p><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="center">0000</td><td align="center">0001</td><td align="center">0010</td><td align="center">0011</td><td align="center">0100</td><td align="center">1011</td><td align="center">1100</td><td align="center">1101</td><td align="center">1110</td><td align="center">1111</td></tr></tbody></table><ul><li><p>2421码的二进制权值是固定的2421，也是<strong>有权码</strong></p></li><li><p>对于2421码来说，0~ 4范围内所有数字编码的第一位都为0，5~ 9范围内所有的数字编码的第一位都为1</p></li><li><p>上述的规定第一位是为了避免歧义，例如5可以表示为0101或1011，但规定了数字编码的第一位后就不会存在歧义。</p><h1 id="字符："><a href="#字符：" class="headerlink" title="字符："></a>字符：</h1><h2 id="ASCII码："><a href="#ASCII码：" class="headerlink" title="ASCII码："></a>ASCII码：</h2><p>数字、字母、符号共128个字符—&gt;7位二进制编码</p><p><img src="/images/Char/ASCII.png"></p><p>可印刷字符：32~126</p><p>数字：48(011 0000)~57(011 1001)</p><p>大写字母：65(100 0001)~90(101 1010)</p><p>小写字母：97(110 0001)~122(111 1010)</p><p>例：已知’A’的ASCII码的值为65，字符’H’存放在某存储单元M中，求M中存放的内容。</p><p>​    **注意：M中存放的是‘H’的ASCII码(二进制形式)**。</p><p>一：A是第一个字母，H是第8个字母，则H对应的码值=65+(8-1)=72；72对应二进制为100 1000，故M中存放的内容为0100 1000</p><p>二：A的码值65写成二进制为100 0001，A是第一个字母，H是第八个字母，故对应100 1000，M中存放的内容为0100 1000。</p><p>&emsp;&emsp;<strong>每个存储单元存放的内容为字节(Byte)的整数倍，即8的整数倍，例题假设存放1B</strong>。</p><h2 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h2><p><img src="/images/Char/Big.png"></p><p><img src="/images/Char/Small.png"></p><h2 id="汉字的表示和编码："><a href="#汉字的表示和编码：" class="headerlink" title="汉字的表示和编码："></a>汉字的表示和编码：</h2><p>GB 2312-80：汉字+各种符号共7445个</p><p>区位码：94个区，每区94个位置</p><p>例如：啊，在第16区，01位置。</p><p>将16转换为十六进制为10H，01转换为十六进制为01H，但是为了防止与其它编码冲突，所以在</p><p>16进制的基础上再加上20H，变成30H和21H.这就是国标码，但会与ASCII码冲突，所以再加上80H得到B0H和A1H,这就是汉字计内码，完成汉字在计算机中的存储。</p><h2 id="奇偶校验码："><a href="#奇偶校验码：" class="headerlink" title="奇偶校验码："></a>奇偶校验码：</h2><table><thead><tr><th align="center">信息</th><th align="center">A</th><th align="center">B</th><th align="center"></th></tr></thead><tbody><tr><td align="center">码字</td><td align="center">00</td><td align="center">01</td><td align="center">码距1</td></tr><tr><td align="center">码字(方案二)</td><td align="center">00</td><td align="center">11</td><td align="center">码距2</td></tr></tbody></table><p><strong>码距</strong>：两个合法码字对应位上数字的不同的个数</p><p>例如：原本A(00)因为跳变发送到B变成了(01),但因为码距为1，所以无法判断原本发的数据是正确还是错误。</p><p>而A(00)因为跳变变成了01，但码距为2，可以知道发生了错误，因为没有01，但却无法确定是哪一位发生了跳变。<strong>所以在整个方案中，有些编码是我们没有用到的，没有用到的编码在发生错误的时候可以帮我们指示错误原因。</strong></p><p><strong>奇校验码：整个校验位(有效信息位和校验位)中1的个数为奇数</strong>。</p><p><strong>偶校验码：整个校验位(有效信息位和校验位)中1的个数为偶数</strong>。</p><table><thead><tr><th align="center">奇偶校验位</th><th align="center">有效信息位</th></tr></thead><tbody><tr><td align="center">1位</td><td align="center">n位</td></tr></tbody></table><h1 id="海明码："><a href="#海明码：" class="headerlink" title="海明码："></a>海明码：</h1><p><strong>海明码设计思路：</strong><code>分组校验--&gt;多个校验位--&gt;校验位标注出错位置</code>。</p><p>例如：信息位1010</p><p>因为：2的K次方 ≥ n+k+1</p><p>所以：K = 3；</p><p><strong>对于n+k+1：海明码是检验信息中哪一位出错，所以原码n个，检验码k个，出现n+k个位置，k校验码对应2的k次方个状态，如k=3,对应000~ 111八个状态。如果八个状态都为错误状态,就需要一个表示正确状态，所以为n+k+1</strong>。</p><p>1：设信息位D4 D3 D2 D1(1010)共4位，检验位P3 P2 P1,共3位，对应的海明码为H7 H6 H5 H4 H3 H2 H1。</p><p>2：确定校验位的分布</p><table><thead><tr><th align="center">H7</th><th align="center">H6</th><th align="center">H5</th><th align="center">H4</th><th align="center">H3</th><th align="center">H2</th><th align="center">H1</th></tr></thead><tbody><tr><td align="center">D4</td><td align="center">D3</td><td align="center">D2</td><td align="center"><strong>P3</strong></td><td align="center">D1</td><td align="center"><strong>P2</strong></td><td align="center"><strong>P1</strong></td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr></tbody></table><p><strong>第二行校验位Pi放在海明码为2的(i-1)次方的位置上，信息位按顺序防到其余位置</strong>。</p><p>3：求校验位的值：</p><p>​    H3：3—&gt;0 1 1</p><p>​    H5：5—&gt;1 0 1</p><p>​    H6：6—&gt;1 1 0</p><p>​    H7：7—&gt;1 1 1</p><p>按列看，最左边的列1 1 0 1说明H3 H5 H7不为0，因此用D1 D2 D4进行异或得P1—&gt;0</p><p>第二列1 0 1 1说明H3 H6 H7不为0，因此用D1 D3 D4进行异或得P2—&gt;1</p><p>第三列0 1 1 1说明H5 H6 H7不为0，因此用D2 D3 D4进行异或得P3—&gt;0</p></li></ul><p>4：纠错</p><p>校验方程：</p><p>S1=P1⊕D1⊕D2⊕D4</p><p>S2=P2⊕D1⊕D3⊕D4</p><p>S3=P3⊕D2⊕D3⊕D4</p><p>接收到：1010010</p><p>S1=P1⊕D1⊕D2⊕D4 = 0⊕0⊕1⊕1=0</p><p>S2=P2⊕D1⊕D3⊕D4 = 1⊕0⊕0⊕1=0</p><p>S3=P3⊕D2⊕D3⊕D4 = 0⊕1⊕0⊕1=0</p><p>000无错误。</p><p>接收到：1010000</p><p>S1=P1⊕D1⊕D2⊕D4 = 0⊕0⊕1⊕1=0</p><p>S2=P2⊕D1⊕D3⊕D4 = 0⊕0⊕0⊕1=1</p><p>S3=P3⊕D2⊕D3⊕D4 = 0⊕1⊕0⊕1=0</p><p>010转换为二进制为2，则第2位出错,该为1010010</p><p>（格式如果变化，确定校验位得分布摆放位置变化，计算方法不变）</p><h1 id="CRC循环冗余码："><a href="#CRC循环冗余码：" class="headerlink" title="CRC循环冗余码："></a>CRC循环冗余码：</h1><table><thead><tr><th align="center">信息位</th><th align="center">校验位</th></tr></thead><tbody><tr><td align="center">K位</td><td align="center">R位</td></tr></tbody></table><p>例：设生成多项式为G(X) = x的三次方+X的2次方+1,信息码为101001，求对应的CRC码</p><p>​    1：确定K,R以及生成多项式对应的二进制码。</p><p>​    K = 信息码的长度 = 6，R = 生成多项式最高次幂 = 3 –&gt; 校验码位数N = K+ R =9</p><p>​    生成多项式G(X) = 1·(X^3)+1·(X^2)+0·(X^1)+1·(X^0),对应的二进制码1101</p><p>​    2：移位：</p><p>​    信息码左移R位，低位补0 —–&gt; 1101000</p><p>​    3：相除(模2除)：</p><p>​    对移位后的信息码，用生成多项式进行模2除法，产生余数</p><p>1101000 / 1101</p><p>模2除：看被除数的最高位是1还是0，根据最高位去上位。减法做不带进位的减法，进行异或运算(相同为0，不同为1),最终取得的余数为校验位。对应的CRC码就是信息码+校验位。</p><p><img src="/images/Char/CRC.png"></p><p>4：检错和纠错：</p><p>例：发送：101001001    记为C9C8C7C6C5C4C3C2C1</p><p>​        接收：101001001—–&gt;用1001进行模2除—-&gt;余数000，代表没出错。</p><p>​        接收：101001011—-&gt;用1101进行模2除—-&gt;余数为010，二进制转换为2，C2出错，但不是绝对，因为000只能代表8位，并不能完全表示。</p><table><thead><tr><th align="center">原循环冗余码</th><th align="center">出错一位后的循环冗余码</th><th align="center">出错位</th><th align="center">余数</th></tr></thead><tbody><tr><td align="center">101001 001</td><td align="center">101001 000</td><td align="center">1</td><td align="center">001</td></tr><tr><td align="center"></td><td align="center">101001 011</td><td align="center">2</td><td align="center">010</td></tr><tr><td align="center"></td><td align="center">101001 101</td><td align="center">3</td><td align="center">011</td></tr><tr><td align="center"></td><td align="center">101000 001</td><td align="center">4</td><td align="center">100</td></tr><tr><td align="center"></td><td align="center">101011 001</td><td align="center">5</td><td align="center">101</td></tr><tr><td align="center"></td><td align="center">101101 001</td><td align="center">6</td><td align="center">110</td></tr><tr><td align="center"></td><td align="center">100001 001</td><td align="center">7</td><td align="center">111</td></tr><tr><td align="center"></td><td align="center">111001 001</td><td align="center">8</td><td align="center">001</td></tr><tr><td align="center"></td><td align="center">001001 001</td><td align="center">9</td><td align="center">010</td></tr></tbody></table><p>假设信息位是K，校验位是R，那么CRC的位数就是R + K ，而R的校验位，可以表示的数从0到2R-1，而0用来表示正确的情况，那么一共有2R-1种错误码，其中每个错误码对应一位，因此我们可以得到一个公式，当满足2R - 1 &gt;= K+R的时候，CRC才具有纠错功能。而且我们可以发现余数是每7个一个循环，出错位1和出错位8的余数是一样的，出错位2和出错位9的余数是一样的，所以这也是为什么叫做循环冗余码的原因。</p><p>为什么一般我们不提及CRC的纠错功能，因为CRC一般用在计算机网络中，在以太网的MAC帧中，通常4字节的效验码（FCS）不但用来检验MAC帧的数据部分，还用来检验目的地址、原地址和类型字段（60~1514）字节，信息位远远大于校验位，因此我们一般不提及CRC的纠错功能，但这并不代表没有。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BCD码：&quot;&gt;&lt;a href=&quot;#BCD码：&quot; class=&quot;headerlink&quot; title=&quot;BCD码：&quot;&gt;&lt;/a&gt;BCD码：&lt;/h1&gt;&lt;p&gt;4个二进制位 (4bit) —-&amp;gt; 1个十进制位，又因为4个二进制位有2的4次方种状态，也就是16种状态。&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AD/DA数模转换</title>
    <link href="https://7heng.github.io/2020/12/17/AD-DA%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2/"/>
    <id>https://7heng.github.io/2020/12/17/AD-DA%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-12-17T09:30:42.000Z</published>
    <updated>2021-03-23T12:35:39.488Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="1：分辨率"><a href="#1：分辨率" class="headerlink" title="1：分辨率"></a>1：分辨率</h3><p>​    ADC的分辨率是指使输出数字量变化一个相邻数码所需要输入模拟电压的变化量。常用二进制的位数表示。例如12位ADC的分辨率就是12位。或者说，分辨率为满刻度 FS 的  1/2的12次方，一个10V满刻度的12位ADC能分辨输入电压变化最小值是 10V × (1/2的12次方) ≈ 2.4mv</p><p><strong>分辨率越高，价格越贵，适用于精度较高物体，反之亦然</strong>。</p><h3 id="2：量化误差"><a href="#2：量化误差" class="headerlink" title="2：量化误差"></a>2：量化误差</h3><p>​    ADC把模拟量变为数字量，用数字量近似表示模拟量，这个过程称为量化。</p><p>​    <strong>量化误差是ADC的有限位数对模拟量进行量化而引起的误差</strong>。</p><h3 id="3：偏移误差"><a href="#3：偏移误差" class="headerlink" title="3：偏移误差"></a>3：偏移误差</h3><p>​    偏移误差是指输入信号为零时，输出信号不为零的值，所以有时又称为零值误差。假定ADC没有非线性误差，则其转换特性曲线各阶段中点的连线必须是直线，这条直线与横轴相交点所对应的输入电压值就是偏移误差。</p><h3 id="4：满刻度误差"><a href="#4：满刻度误差" class="headerlink" title="4：满刻度误差"></a>4：满刻度误差</h3><p>​    满刻度误差又称为增益误差。ADC的满刻度误差是指满刻度输出数码所对应的实际输入电压与理想输入电压之差。</p><h3 id="5：线性度"><a href="#5：线性度" class="headerlink" title="5：线性度"></a>5：线性度</h3><p>​    线性度有时又称为非线性度，它是指转换器实际的转换特性与理想直线的最大偏差。</p><h3 id="6：绝对精度"><a href="#6：绝对精度" class="headerlink" title="6：绝对精度"></a>6：绝对精度</h3><p>​    在一个转换器中，任何数码所对应的实际模拟量输入与理论模拟输入之差的最大值，称为<strong>绝对精度</strong>。对于ADC而言，可以在一个阶梯的水平中点进行测量，它包括了所有的误差。</p><h3 id="7：转换速率"><a href="#7：转换速率" class="headerlink" title="7：转换速率"></a>7：转换速率</h3><p>​    ADC的转换速率是能够重复进行数据转换的速度，即每秒转换的次数。而完成每一次 A/D 转换所需的时间(包括稳定时间)，则是转换速率的倒数。</p><h2 id="AD的差分输入与单端输入："><a href="#AD的差分输入与单端输入：" class="headerlink" title="AD的差分输入与单端输入："></a>AD的差分输入与单端输入：</h2><p>​    单端输入，输入信号均以共同的地线为基准，这种输入方法主要应用于输入信号电压较高 (高于1V),信号源到模拟输入硬件的导线较短，且所有的输入信号共用一个基准地线，<strong>如果信号达不到这些标准，此时应该用差分输入</strong>。对于差分输入每一个输入信号都有自有的基准地线；由于共模噪声可以被导线所消除，从而减小了噪声误差。</p><p>​    <strong>单端输入时，时判断信号与GND的电压差；差分输入时，是判断两个信号线的电压差</strong>。</p><p>​    信号受干扰时，差分的两线会同时受影响，但电压差变化不大，(抗干扰性较佳) 而单端输入的一线变化时，GND不变，所以电压差变化较大（抗干扰性较差）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h3 id=&quot;1：分辨率&quot;&gt;&lt;a href=&quot;#1：分辨率&quot; class=&quot;headerlink&quot; title=&quot;1：分辨率&quot;&gt;&lt;/a&gt;1：分辨率&lt;/h3&gt;&lt;p&gt;​    ADC的分辨率是指使输出数字量变化一个相邻数码所需要输入模拟电压的变</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>IIC总线</title>
    <link href="https://7heng.github.io/2020/12/17/IIC%E6%80%BB%E7%BA%BF/"/>
    <id>https://7heng.github.io/2020/12/17/IIC%E6%80%BB%E7%BA%BF/</id>
    <published>2020-12-17T09:27:51.000Z</published>
    <updated>2021-03-23T12:35:32.015Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="常用的串行总线协议："><a href="#常用的串行总线协议：" class="headerlink" title="常用的串行总线协议："></a>常用的串行总线协议：</h2><p>目前常用的微机与外设之间进行数据传输的串行总线主要有：UART、1-Wire、IIC和SPI总线。</p><p>​    UART：是以异步方式进行通信（一条数据输入线，一条数据输出线）</p><p>​    1-wire：即单线总线，又叫单总线（只有一条线）</p><p>​    IIC：同步串行2线方式进行通信（一条时钟线，一条数据线）</p><p>​    SPI：同步串行3线方式进行通信（一条时钟线，一条数据据输入线，一条数据输出线）</p><h3 id="I²C串行总线的组成及工作原理："><a href="#I²C串行总线的组成及工作原理：" class="headerlink" title="I²C串行总线的组成及工作原理："></a>I²C串行总线的组成及工作原理：</h3><p>​    I²C总线是PHLIPS公司推出的一种<strong>串行总线</strong>，它只有<strong>两</strong>根双向信号线。一根是数据线SDA(Serial data I/o口)，另一根是时钟线SCL(Serial clock)</p><p>​    I²C总线上可以挂多个器件，而每个器件都有<strong>唯一的地址</strong>，这样可以标识通信目标。数据的通信的方式采用<strong>主从</strong>方式，主机负责主动联系从机，而从机则被动回应数据(从机无法主动发数据给主机，也无法主动向主机读取数据)</p><p><img src="/images/IIC/8.png"></p><p>在多主机系统中，可能同时有几个主机企图启动总线传送数据。为了避免混乱，I²C总线要通过总线仲裁，以决定由哪一台主机控制总线。</p><p>在80C51单片机应用系统的串行总线扩展中，我们经常遇到的是以80C51单片机为主机，其它接口为从机的主机情况。</p><p>I²C总线通过上拉电阻接正电源。当总线空闲时，两根线均为高电平。连接到总线上的任一器件输出的低电平，都将使总线的信号变低，即各器件的SDA及SCL都是<strong>线“与”关系</strong>。</p><h2 id="I²C总线传输协议："><a href="#I²C总线传输协议：" class="headerlink" title="I²C总线传输协议："></a>I²C总线传输协议：</h2><h3 id="数据位的有效性规定："><a href="#数据位的有效性规定：" class="headerlink" title="数据位的有效性规定："></a>数据位的有效性规定：</h3><p>​    SCL为高电平期间，数据线上的数据必须保持稳定，只有SCL信号为低电平期间，SDA的状态才允许变化。</p><p>​    <strong>I²C的起始信号和终止信号</strong>(起始信号和终止信号不受有效性规定)：</p><p>​    SCL为高电平期间，SDA线由高电平向低电平的变化表示起始信号；SCL为高电平期间，SDA线由低电平向高电平的变化表示终止信号(<strong>起始信号和终止信号由主机进行</strong>)</p><p><strong>当单片机不使用时钟线或数据线的时候，要进行释放，SCL(时钟线)在外同步中始终是由单片机去控制的，SDA(数据线)在不使用时需要进行释放(手动/程序)</strong></p><p>起始和终止信号都是由主机发出的，在起始信号产生后，主机就处于被占用的状态；在终止信号产生后，总线就属于空闲状态。</p><p>连接到I²C总线上的器件，若具有I²C总线的硬件接口，则很容易检测到起始和终止信号。</p><h3 id="从机内部的操作："><a href="#从机内部的操作：" class="headerlink" title="从机内部的操作："></a>从机内部的操作：</h3><p>​    接收器件收到一个完整的数据字节后，有可能需要完成一些其它工作，如处理内部中断服务等，可能无法立刻接收下一字节，这时接收器件可以将SCL线拉成低电平，从而使主机处于等待状态。直到接收器件准备好接收下一个字节时，再释放SCL线使之为高电平，从而使数据传送可以继续进行。</p><p><strong>I²C字节的传送与应答：</strong>每一个字节必须保证是8位长度，数据传送时，先传送最高位(MSB),每一个被传送的字节后面都必须跟随一位应答位(即一帧共有9位)</p><p><strong>应答位的作用：</strong>主机在发送数据时，每次发送一字节数据都需要读取从机应答位，当从机空闲时可以接收该字节数据时，从机会发出应答(一帧数据的第9位为 ‘ 0 ’),当主机正忙于其它工作的处理来不及接收主机发送的数据时，从机会发出非应答(一帧数据的第9位为 ‘ 1 ’)主机则应发出终止信号以结束数据的继续传送，主机通过从机发出的应答来判断从机是否成功接收数据。</p><p>当主机接收数据时，它收到最后一个数据字节后，必须向从机发出一个结束传送的信号，这个信号是由对从机的 “ 非应答 ” 来实现的。然后，从机释放SDA线，以允许主机产生终止信号。</p><h2 id="数据帧格式："><a href="#数据帧格式：" class="headerlink" title="数据帧格式："></a>数据帧格式：</h2><p>​    <strong>I²C总线上传送的数据信号是广义的，即包括地址信号，又包括真正的数据信号</strong>。</p><p>​    在起始信号后必须传送一个从机的地址(7位)，第8位是数据的传送方向位( R/T )，用 ‘ 0 ’ 表示主机发送数据(T)，“ 1 ” 表示主机接收数据(R)，<strong>每次数据传送总是由主机产生的终止信号结束</strong>。但是，**若主机希望继续占用总线进行新的数据传送。则可以不产生终止信号，马上再次发出起始信号对另一从机进行寻址 (多机通信)**。</p><p>在总线的一次数据传送过程中，可以有以下几种组合方式：</p><p>1：主机向从机发送数据，数据传送方向在整个传送过程中不变。<br><img src="/images/IIC/1.png"></p><p>2：主机在第一个字节后，立即从从机读取数据<br><img src="/images/IIC/2.png"></p><p>3：在传送过程中，当需要改变传送方向时，起始信号和从机地址都被重复产生一次，但两次读/写方向位正好反向<br><img src="/images/IIC/3.png"></p><p><strong>总线的寻址</strong>：</p><p>​    I²C总线协议有明确的规定：<strong>采用7位的寻址字节(寻址字节是起始信号后的第一个字节)</strong></p><p>​    (1)<strong>寻址字节的位定义</strong>：</p><p>​    </p><table><thead><tr><th>位</th><th align="center">7   6   5   4   3   2   1</th><th>0</th></tr></thead><tbody><tr><td></td><td align="center">从机地址</td><td>R/W</td></tr></tbody></table><p>D7~D1位组成从机的地址。D0位是数据传送的方向位，为 ‘ 0 ‘ 时表示主机向从机写数据。为 ‘ 1 ’ 时表示主机由从机读数据。</p><p><strong>主机发送</strong>地址时，总线上的每个从机都将这7位地址码与自己的地址进行比较，如果相同，则认为自己正被主机寻址，根据 R/T 位将自己确定为发送器或接收器。</p><p><strong>从机的地址</strong>由固定部分和可编程的部分组成。在一个系统中可能希望接入多个相同的从机主机地址中可编程部分决定了可接入总线该类器件的最大数目。如果一个从机的7位寻址位有4位是固定位，3位是可编程位，这时仅能寻址8个同样的器件，即可以有8个同样的器件介入到该 I²C 总线系统中。</p><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;常用的串行总线协议：&quot;&gt;&lt;a href=&quot;#常用的串行总线协议：&quot; class=&quot;headerlink&quot; title=&quot;常用的串行总线协议：&quot;&gt;&lt;/a&gt;常用的串行总线协议：&lt;/h2&gt;&lt;p&gt;目前常用的微机与外设之间进行数据传输的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>串口通信</title>
    <link href="https://7heng.github.io/2020/11/25/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
    <id>https://7heng.github.io/2020/11/25/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</id>
    <published>2020-11-25T12:42:44.000Z</published>
    <updated>2021-03-23T12:36:18.180Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>通信有串行通信和并行通信两种方式。在多微机系统以及现代测控系统中信息的交换多采用串行通信方式。</p><p><strong>并行通信：</strong>通常是将数据字节的各位用多条数据线同时进行传送。</p><ul><li>优点：控制简单、传输数据快。</li><li>缺点：由于传输线较多，长距离传送时成本高且接收方的各位同时接收存在困难。</li></ul><p><img src="/images/Com/1.png"></p><p><strong>串行通信：</strong>使用一条数据线，将数据一位一位地依次传输，每一位数据占据一个固定的时间长度。只需要少数几条线就可以在系统间交换信息，特别适用于计算机与计算机，计算机与外设直间的远距离通信。</p><ul><li>优点：传输线少，长距离传送时成本低。</li><li>缺点：数据的传送控制比并行通信复杂。</li></ul><p><img src="/images/Com/2.png"></p><p>串行通信又可分为<strong>异步通信</strong>和<strong>同步通信</strong>。</p><p>异步通信是以字符<strong>（构成的帧）</strong>为单位，进行传输，字符与字符之间的间隙<strong>（时间间隔）</strong>是任意的，但每个字符中的各位是以固定的时间传送的，即字符之间不一定有“ 位间隔 ”的整数倍的关系，<strong>但同一字符内的各位之间的距离均为“  位间隔 ”的整数倍。</strong></p><p><img src="/images/Com/3.png"></p><p><strong>异步通信</strong>是一种很常用的通信方式（效率较低），异步通信在发送字符时，发送端可以在任意时刻开始发送字符，因此必须在每一个字符的开始和结束的地方加上标志，即加上开始位和停止位，以便使接收端能够正确地将每一个字符接受下来。所传送地数据以字节为单位。每个字节前加上一位起始位，每个字节后面加上停止位。&emsp;&emsp;优点：异步通信地好处是通信设备简单、便宜，但传输效率较低。</p><p><strong>同步通信：</strong></p><p>同步通信时要建立发送发时钟对接收方时钟地直接控制，使双方达到完全同步。此时，传输数据的位之间的距离均为“ 位间隔  ”的整数倍，同时传送的字符间不留间隙，即<strong>保持同步</strong>关系，也<strong>保持字符同步关系</strong>。发送发对接收方的同步可以通过两种方法实现。</p><h4 id="传输速率："><a href="#传输速率：" class="headerlink" title="传输速率："></a>传输速率：</h4><p>比特率是<strong>每秒钟传输二进制代码的位数</strong>。单位是：位/秒（bps）。如每秒中传送240个字符，而每个字符格式包含10位（1个起始位，1个终止位，8个数据位）这时的比特率为：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>10位 × 240个/秒 = 2400 bps</strong></p><p><strong>传输距离与传输速率的关系：</strong></p><p>串行接口或终端直接传送串行信息位流的最大距离与传输速率及传输线的<strong>电气特性</strong>有关。当传输线使用每0.3m（约1英尺）有50PF的电容的非平衡屏蔽双绞线时，<strong>传输距离随传输速率的增加而减小</strong>。<strong>当比特率超过1000bps时，最大传输距离迅速下降，如9600bps时最大距离下降到只有76m（约250英尺）</strong>。</p><p><strong>采用RS-232C接口存在的问题（电气特性）：</strong></p><ol><li><p><strong>传输距离短、传输效率低</strong>：</p><p>&emsp;&emsp;RS-232C总线标准受电容允许值的约束，使用时传输距离一般不要超过15米（线路条件好时也不要超过几十米）。最高传送速率为20kpbs。</p><p>&emsp;&emsp;<strong>双绞线会形成分布电容，又叫寄生电容，受电气特性自动产生</strong>，因为在三极管和场效应管会自动产生，所以会影响开通与关断的速度。</p><p>&emsp;&emsp;<strong>电容：两个导体产生，与两个导体间的距离成反比，与导体的面积成正比</strong>。</p></li><li><p><strong>有电平偏移</strong>：</p><p>&emsp;&emsp;RS-232C总线标准要求收发双方共地。通信距离较大时，收发双方的地电位差别较大。在信号地上将有比较大的地电流并产生压降。</p></li><li><p><strong>抗干扰能力差</strong>：</p><p>&emsp;&emsp;RS-232C在电平转换时采用单端输入输出，在传输过程中当干扰和噪声混在正常的信号中，为了提高信噪比，RS-232C总线标准不得不采用比较大的电压和摆幅。</p></li></ol><p><strong>SBUF：</strong></p><p>&emsp;&emsp;在逻辑上，SBUF只有一个，它即表示发送寄存器，又表示接收寄存器，具有同一个单元地址99H。但在物理结构上，则有两个完全独立的SBUF，一个是发送缓冲寄存器SBUF，另一个是接收缓冲寄存器SBUF。如果<strong>CPU写SBUF</strong>，数据就会被送入<strong>发送寄存器</strong>准备发送；如果<strong>CPU读SBUF</strong>，则读入的数据一定<strong>来自接收缓冲器</strong>。即CPU对SBUF的读写，实际上是分别对访问上述两个不同的寄存器。</p><p><strong>（收） a = SBUF;</strong>&emsp;&emsp;&emsp;<strong>（发）SBUF =a;</strong></p><h4 id="串行口工作前需要对相关寄存器进行配置，设定其工作模式："><a href="#串行口工作前需要对相关寄存器进行配置，设定其工作模式：" class="headerlink" title="串行口工作前需要对相关寄存器进行配置，设定其工作模式："></a>串行口工作前需要对相关寄存器进行配置，设定其工作模式：</h4><p><img src="/images/Com/4.png"></p><ol><li>设定T1的<strong>工作方式</strong>（编程TMOD寄存器）；</li><li>计算T1的初值，装载TH1、TL1；</li><li>启动T1（编程TCON中的TR1位）；</li><li>确定<strong>串行口控制</strong>（编程SCON寄存器）；</li><li>如需串行口在中断方式工作时，需进行中断设置编程IE寄存器。</li></ol><p><img src="/images/Com/5.png"></p><p>当T1作为波特率发生器时，最典型的用法是<strong>使T1工作在自动再装入</strong>的<strong>8位定时器方式（即方式2，且TCON的 TR1 = 1，以启动定时器）。</strong>这时溢出率取决于TH1中的计数值。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>T1 溢出率 = fosc / { 12 × [ 256 - (TH1) ] }</strong></p><p><img src="/images/Com/6.png"></p><p><img src="/images/Com/7.png"></p><p><strong>fosc:外部晶振（11.0595）</strong></p><p><strong>自动再装：TL1、TH1的赋值。 TL1从初值开始加，加到255溢出后，会自动取TH1的初值。</strong></p><p><strong>产生波特率误差要为0，不能有误差！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;通信有串行通信和并行通信两种方式。在多微机系统以及现代测控系统中信息的交换多采用串行通信方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并行通信：&lt;/strong&gt;通常是将数据字节的各位用多条数据线同时进行传送。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>定时器/计数器</title>
    <link href="https://7heng.github.io/2020/11/16/%E5%AE%9A%E6%97%B6%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <id>https://7heng.github.io/2020/11/16/%E5%AE%9A%E6%97%B6%E8%AE%A1%E6%95%B0%E5%99%A8/</id>
    <published>2020-11-16T11:55:51.000Z</published>
    <updated>2021-03-23T12:36:13.134Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>51单片机有2个16位定时器/计数器：定时器0和定时器1。</p><p>这里所说的16位是指定时/计数器内部分别有16位的计数寄存器。</p><p>当工作在定时模式时，每经过一个机器周期的内部的16位计数寄存器的值就会加1，当这个寄存器装满时溢出。我们可以算出工作在定时模式时最高单次定时时间为65535×1.085μS=时间（单位μS）</p><p>当工作在技术器模式时，T0，T1每来一个脉冲计数寄存器加1。</p><p>65535： 16位的计数寄存器，最大为16个1，也就是65535。</p><p>最大定时： 65535×1.085=71105.475μS≈71.1mS</p><p>时钟周期：以11.0592MHZ为例，假如51单片机的时钟为11.0592MHZ，除以12后得到每秒执行的指令个数为条指令，取倒数将得到执行每条指令所需时间为1.085μS(一个周期)</p><h4 id="定时器作用："><a href="#定时器作用：" class="headerlink" title="定时器作用："></a>定时器作用：</h4><p>定时计数器可以用于精确事件定时，PWM脉宽调制，波形发生，信号时序测量的方面。</p><h4 id="使用51定时-技术器步骤："><a href="#使用51定时-技术器步骤：" class="headerlink" title="使用51定时/技术器步骤："></a>使用51定时/技术器步骤：</h4><ul><li>启动定时/计数器（通过TCON控制器）</li><li>设置定时/计数器（通过TMOD控制器）</li><li>查询定时/计数器是否溢出（读TCON内TF位）</li></ul><p><img src="/images/Time/0.png"></p><p>计数器：每来一个脉冲计数寄存器加1。一个高电平一个低电平形成一个脉冲。</p><p>TMOD控制器中C/T位为功能选择位：为0时为定时器，为1时为计数器。</p><blockquote><p>定时器举例：</p><p>TR0 = 1; &emsp;&emsp;&emsp;&emsp;// 定时器0工作</p><p>TMOD - 0X01;&emsp;&emsp;&emsp;&emsp;// 16位定时器/计数器</p><p>TH0 = 0X4B;   &emsp;&emsp;&emsp;&emsp;// (65535-46082) / 256 &emsp;&emsp; 高位赋值</p><p>TL0 = 0XFD;&emsp;&emsp;&emsp;&emsp;// (65535-46082）% 256&emsp;&emsp;低位赋值</p><p>if(TF0 == 1)&emsp;&emsp;&emsp;&emsp;&emsp;// 加满产生溢出;不用中断响应的情况下要软件清0。”置 ”1“ 为硬件置 “1” “</p></blockquote><p>例如：</p><p> &emsp;定时50毫秒（mS）= 50000 微秒(μS)&emsp;&emsp;//因为执行计数的加1为微秒级</p><p> &emsp;50000÷1.085≈46082；</p><p> &emsp;65535-46082 = 初值；</p><ul><li>如果同时使用定时器计数器，都需要对同一个寄存位赋值时，可以用 |=（或等于）符号，相当于两个值进行求和，这样可以同时利用定时器和计数器。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;51单片机有2个16位定时器/计数器：定时器0和定时器1。&lt;/p&gt;
&lt;p&gt;这里所说的16位是指定时/计数器内部分别有16位的计数寄存器。&lt;/p&gt;
&lt;p&gt;当工作在定时模式时，每经过一个机器周期的内部的16位计数寄存器的值就会加1，当这个寄</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>中断系统</title>
    <link href="https://7heng.github.io/2020/11/15/%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/"/>
    <id>https://7heng.github.io/2020/11/15/%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-11-15T12:30:29.000Z</published>
    <updated>2021-03-23T12:35:48.072Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="复位电路："><a href="#复位电路：" class="headerlink" title="复位电路："></a>复位电路：</h2><p><img src="http://www.elecfans.com/uploads/allimg/180105/160R15593-0.jpg"></p><p>复位电路的两个功能：</p><ul><li>上电复位（程序在裕兴期间可能会存在执行到一半突然断电的情况，再上电时必须为零从新开始，否则可能会出现错误，因此需要上电复位）</li><li>手动复位</li></ul><p>不运行程序的时候可以测试一下RST，如果处于高电平则是一直处于复位状态，用杜邦线将它接地即可开始运行。</p><p>RST（RESET）是复位信号输入端，当单片机运行时，在此引脚上持续两个机器周期的高电平时，就可以完成复位操作。</p><p>上电复位：</p><p>ECI：一个10μF的电容，当电容里电流每充满时，相当于断路状态，当电流充满，电流流经R2至地与RST（R2电阻限制流经ECI电容的电流大小，使得充电更为缓慢，当电容满时表现出通交隔直（通交流电隔直流电的状态）。因为电容充满电的状态大于两个时钟周期以上，所以RST会完成复位操作。电容充满电流不再流过，RST会通过R2流至地，变为0V，完成复位，开始正常工作。</p><p>手动复位：</p><p>按下S1按键，VCC经过R1通至RST两个机器周期的高电平，完成复位操作。</p><h3 id="中断："><a href="#中断：" class="headerlink" title="中断："></a>中断：</h3><p>计算机执行某程序时，发生了紧急事件或有特殊请求，CPU暂停某程序的执行，转而去处理上述事件或请求，处理完毕后再重新执行某程序的运行过程叫做中断。</p><p>中断分为四个步骤：</p><ul><li>中断请求–&gt;中断响应–&gt;中断处理–&gt;中断返回</li></ul><p>数据的输出/输出传送方式：</p><ul><li>无条件传送方式：一方对另一方来说总是准备好的。</li><li>查询传输方式（Look up）：传送前一方先查询另一方的状态，若已准备好就传送，否则就继续查询/等待。</li><li>中断传送方式（IRQ）：一方通过申请中断的方式与另一方进行数据传送。</li><li>直接存储器存取方式（DMA）：双方直接通过总线传送数据，不经CPU中转。适用于数量大高速通讯的设备，不占用CPU时间。</li></ul><p>中断系统结构：</p><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1076873358,2154005421&fm=26&gp=0.jpg"></p><h4 id="51子系列允许5个中断源："><a href="#51子系列允许5个中断源：" class="headerlink" title="51子系列允许5个中断源："></a>51子系列允许5个中断源：</h4><p>外部中断源（2个）：</p><ul><li>INTO—-由P3.2端口线引入，低电平或下降沿引起。</li><li>INT1—-由P3.3端口线引入，低电平或下降沿引起。</li></ul><p>这两个外部中断源标志和它们的触发方式控制由特殊功能寄存器TCON的低4位控制。</p><p>内部中断源（3个）：</p><ul><li>T0—-定时器/计数器0中断，由T0回零溢出引起。</li><li>T1—-定时器/计数器1中断，由T1回零溢出引起。</li><li>T1/R1—-串行中断i/O中断，串行端口完成一个帧字符发送/接收后引起。这3个内部中断源的控制分别锁存在特殊功能寄存器TCON和SCON中。</li></ul><h4 id="单片机同优先级中段内部查询顺序："><a href="#单片机同优先级中段内部查询顺序：" class="headerlink" title="单片机同优先级中段内部查询顺序："></a>单片机同优先级中段内部查询顺序：</h4><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;中断源&emsp;&emsp; &emsp;| &emsp;&emsp;中断级别</p><p>&nbsp;&nbsp;外部中断0 &emsp;中断入口0&emsp;&emsp;&emsp;&emsp;&emsp;最高</p><p>&nbsp;&nbsp;T0溢出中断&nbsp;&emsp;中断入口1</p><p>&nbsp;&nbsp;外部中断0&emsp;中断入口2</p><p>&nbsp;&nbsp;T1溢出中断&emsp;&nbsp;中断入口3</p><p>&nbsp;&nbsp;串行口中断&emsp;中断入口4&emsp;&emsp;&emsp;&emsp;&emsp;最低</p><h4 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h4><blockquote><p>开总中断；</p><p>开外部中断；</p><p>中断触发条件（低电平或跳变沿）</p></blockquote><p>中断函数：</p><blockquote><p>void function(&emsp;)&emsp;interrupt 2 &emsp;&emsp;&emsp;//中断处理函数，加关键字interrupt和入口号</p><p>{</p><p>中断处理语句；</p><p>}</p></blockquote><p>中断示例：</p><blockquote><p>//显示函数<br>void display()<br>{<br>    *<strong>****</strong><br>}</p><p>//定时器0初始化<br>void timer0Init()<br>{<br>    EA = 1;  //开总中断<br>    ET0 = 1;  //开定时器0中断<br>    TR0 = 1;   //定时器0工作<br>    TMOD = 0x01;   //16位<br>    TH0 = 0x4b;<br>    TL0 = 0xfd;  //延时时间<br>}<br>//主函数<br>void main()<br>{<br>    timer0Init();<br>    <strong>****</strong><br>}</p><p>//中断函数<br>void timor0() interrupt 1<br>{<br>    TH0 = 0x4b;<br>    TL0 = 0xfd;  //延时时间<br>    display();<br>} </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;复位电路：&quot;&gt;&lt;a href=&quot;#复位电路：&quot; class=&quot;headerlink&quot; title=&quot;复位电路：&quot;&gt;&lt;/a&gt;复位电路：&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://www.elecfans.com/uploa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>独立按键与矩阵键盘</title>
    <link href="https://7heng.github.io/2020/11/14/%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE%E4%B8%8E%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98/"/>
    <id>https://7heng.github.io/2020/11/14/%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE%E4%B8%8E%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98/</id>
    <published>2020-11-14T12:56:49.000Z</published>
    <updated>2021-03-23T12:36:08.735Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>单片机上使用的大部分都是轻触开关，轻触按键。</p><p>独立键盘：每个按键占用一个io口，当按键数量较多时，io口利用效率不高，但程序简单，适用于所需按键较少的场合。</p><p>矩阵键盘：电路连接复杂，但提高了io口的利用率，软件编程较复杂。适用于使用大量按键的场合。</p><p>独立按键：</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1605369130375&di=722c9e7cdf6e555ce1bd1cdc4e89e91c&imgtype=0&src=http://file.elecfans.com/web1/M00/BC/8C/pIYBAF67T1uAZUyPAABtB6TAq94163.jpg"></p><p>&emsp;&emsp;按键的一端与io口连接，另一端接地。通过控制io口输出高电平即可检测按键是否按下，当按下时io口会被拉低，松开后io口回到高电平。</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1605369468198&di=466d5acd491ae5e475abc7b87bb9782d&imgtype=0&src=http://6.eewimg.cn/news/uploadfile/2020/0225/1582610369554153.jpg"></p><p>&emsp;&emsp;准双向io口： 在准双向io口的管脚处接一个轻触独立按键，另一端接地。当内部输出为1时，经过非门变为0，G与S之间无正电压，场效应管不导通，因为内部有上拉电阻，所以D会被拉到5V，如果按键没有按下，那么此处还是为5V，如果按键按下，线路相当于直接接到地线上，那么会被拉低变为0V，因为电流会往阻抗低的地方流。</p><h4 id="按键特性："><a href="#按键特性：" class="headerlink" title="按键特性："></a>按键特性：</h4><p>&emsp;机械按键在按下或松开时会存在抖动现象。</p><blockquote><p>在编写程序时需要进行消除抖动</p></blockquote><h4 id="矩阵键盘："><a href="#矩阵键盘：" class="headerlink" title="矩阵键盘："></a>矩阵键盘：</h4><p>确定矩阵键盘上哪一个按键被按下可以采用列扫描和行扫描。列扫描时先把接在列上面的所有io口拉高，接在行上面的所有io口置低。（行扫描时先把接在行上面的所有io口拉高，接在列上面的所有io口置低）当其中有一列内任何一个按键按下那么整条列线都会被拉低。</p><h5 id="8×8LED点阵屏："><a href="#8×8LED点阵屏：" class="headerlink" title="8×8LED点阵屏："></a>8×8LED点阵屏：</h5><ul><li>行线为点阵屏LED灯的正极为共阳极点阵屏。</li><li>列线为点阵屏LED灯的正极为共阴极点阵屏。</li></ul><p>&emsp;&emsp;点阵屏动态显示相当于数码管动态显示，是一个一个亮来显示的，但是由于机器运行速度很快，而且人眼的延时效果，所以看着时同时在显示。</p><p>&emsp;&emsp;点阵屏驱动需要很多的io口，设计电路时应该尽可能节省io口的利用，所以驱动点阵屏</p><p>可以利用74HC595芯片通过级联来控制点阵屏。74HC595大大节省了io口的利用。</p><p>74HC595芯片是一种串入并出的芯片，是8位串行输入/输出或者并行输出的移位寄存器。（以压栈的方式进行工作）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;单片机上使用的大部分都是轻触开关，轻触按键。&lt;/p&gt;
&lt;p&gt;独立键盘：每个按键占用一个io口，当按键数量较多时，io口利用效率不高，但程序简单，适用于所需按键较少的场合。&lt;/p&gt;
&lt;p&gt;矩阵键盘：电路连接复杂，但提高了io口的利用率，软</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数码管</title>
    <link href="https://7heng.github.io/2020/11/13/%E6%95%B0%E7%A0%81%E7%AE%A1/"/>
    <id>https://7heng.github.io/2020/11/13/%E6%95%B0%E7%A0%81%E7%AE%A1/</id>
    <published>2020-11-13T13:50:38.000Z</published>
    <updated>2021-03-23T12:35:53.727Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>数码管：</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1605361170090&di=1e0ea0a40fc5bce489b8d45f8ed82559&imgtype=0&src=http://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/b999a9014c086e0631bbface01087bf40ad1cb20.jpg"></p><p>数码管根据内部连接的不同分为共阴极和共阳极。八段数码管内部有8颗LED组成，如果想要显示特定字形，只需控制相应的LED亮起，其它LED熄灭即可。</p><h4 id="判断数码管是共阴极还是共阳极"><a href="#判断数码管是共阴极还是共阳极" class="headerlink" title="判断数码管是共阴极还是共阳极:"></a>判断数码管是共阴极还是共阳极:</h4><p> &nbsp; &emsp;&nbsp;如果是共阴极，中间公共脚为GND，如果是共阳极，中间公共脚为VCC。</p><p> &emsp;&nbsp;&nbsp;用万用表黑笔脚接在公共脚上，红笔表假设接在a上，如果a恒亮，代表是一个共阴极数码管。如果a不亮，将黑表笔接在a脚，红表笔接在公共脚上，如果a恒亮，则为共阳极。(指针式万用表在电阻挡，红表笔输出负电压，是负极。黑表笔输出正电压，是正极。 &emsp;一般为红正极黑负极。)</p><h4 id="锁存器："><a href="#锁存器：" class="headerlink" title="锁存器："></a>锁存器：</h4><p><img src="http://www.elecfans.com/article/UploadPic/2008-4/2008411031937957.jpg"></p><p><img src="http://www.elecfans.com/article/UploadPic/2008-4/20084110314262946.jpg"></p><h4 id="上拉电阻的作用"><a href="#上拉电阻的作用" class="headerlink" title="上拉电阻的作用:"></a>上拉电阻的作用:</h4><p>&emsp;&emsp;上拉就是将不确定的信号通过一个电阻钳位在高电平，电阻同时起限流作用。下拉同理，也是将不确定的信号通过一个电阻钳位在低电平。</p><p>&emsp;&emsp;当P0口作为输入/输出口时，上电复位后处于开漏模式。P0口内部无上拉电阻，所以作io口必须外接10k~ 4.7k的上拉电阻。</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1605366286862&di=2677112b48636c43f39ae464924c4dd8&imgtype=0&src=http://pics6.baidu.com/feed/8694a4c27d1ed21b878053600e7482c350da3f8f.jpeg?token=dc2d75945facce9c7b435202621b3fc8"></p><h4 id="场效应管"><a href="#场效应管" class="headerlink" title="场效应管:"></a>场效应管:</h4><p><img src="https://dfsimg1.hqewimg.com/group1/M00/12/63/wKhk713mAyaAfEUWAAA_CTEWvaw730.jpg"></p><p>三个电极分别是：</p><ul><li>栅极 G</li><li>源计 S</li><li>漏极 D</li></ul><p>与三极管相比，场效应管具有很高的输入电阻。</p><p>准双向io口可以正常输出高低电平。</p><p>漏极开漏输出：</p><ul><li>可以输出低电频，但不可以输出高电频。（因此要加一个上拉电阻，才可以既能输出高电频又能输出低电频。&lt;源极S接地，G与S之间要有一个正偏，场效应管(D与S之间)才能导通&gt; ）</li></ul><blockquote><p>数码管输入数据时流程：</p><ul><li>打开位选锁存器</li><li>赋予数据</li><li>锁存位选数据，关闭位选锁存器</li><li>打开段选锁存器</li><li>赋予数据</li><li>锁存器段选数据，关闭段选锁存器</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;数码管：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1605361170090&amp;di=1e0ea0a40fc</summary>
      
    
    
    
    
  </entry>
  
</feed>
