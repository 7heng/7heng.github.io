<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Heng</title>
  
  
  <link href="https://7heng.github.io/atom.xml" rel="self"/>
  
  <link href="https://7heng.github.io/"/>
  <updated>2021-04-18T07:29:02.332Z</updated>
  <id>https://7heng.github.io/</id>
  
  <author>
    <name>7heng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java之Map接口</title>
    <link href="https://7heng.github.io/2021/04/18/java%E4%B9%8BMap%E6%8E%A5%E5%8F%A3/"/>
    <id>https://7heng.github.io/2021/04/18/java%E4%B9%8BMap%E6%8E%A5%E5%8F%A3/</id>
    <published>2021-04-18T05:43:31.000Z</published>
    <updated>2021-04-18T07:29:02.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Map接口继承树："><a href="#Map接口继承树：" class="headerlink" title="Map接口继承树："></a>Map接口继承树：</h2><p><img src="/images/Collection/Map_1.png"></p><h3 id="Map接口概述："><a href="#Map接口概述：" class="headerlink" title="Map接口概述："></a>Map接口概述：</h3><ul><li>Map 与Collection并列存在。用于保存具有<strong>映射关系</strong>的数据：key-value。</li><li>Map 中的 key 和 value 都可以是任何引用类型的数据。</li><li>Map 中的 key 用 Set 来存放，不允许重复，即同一个Map 对象所对应的类，须重写 hashCode() 和 equals() 方法。</li><li>常用 String 类作为Map的 “键”。</li><li>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value。</li><li>Map 接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中，<strong>HashMap是Map接口使用频率最高的实现类</strong>。</li></ul><h2 id="Map的实现类的结构："><a href="#Map的实现类的结构：" class="headerlink" title="Map的实现类的结构："></a>Map的实现类的结构：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">|----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y &#x3D; f(x)</span><br><span class="line">|----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value</span><br><span class="line">|----LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。</span><br><span class="line"></span><br><span class="line">原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</span><br><span class="line">对于频繁的遍历操作，此类执行效率高于HashMap。</span><br><span class="line"></span><br><span class="line">|----TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序</span><br><span class="line">底层使用红黑树</span><br><span class="line"></span><br><span class="line">|----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value</span><br><span class="line">|----Properties:常用来处理配置文件。key和value都是String类型</span><br><span class="line"></span><br><span class="line">HashMap的底层：数组+链表  （jdk7及之前）</span><br><span class="line"></span><br><span class="line">数组+链表+红黑树 （jdk 8）</span><br></pre></td></tr></table></figure><h2 id="Map结构的理解："><a href="#Map结构的理解：" class="headerlink" title="Map结构的理解："></a>Map结构的理解：</h2><ul><li>Map中的key：无序的、不可重复的，使用Set存储所有的key —–&gt; key所在的类要重写equals() 和 hashCode()    【以HashMap为例】。</li><li>Map中的value：无序的、不可重复的，使用Collection存储所有的value  —–&gt; value所在的类要重写equals()。</li><li>一个键值对：key–value 构成了一个 Entry 对象。</li><li>Map 中的entry：无序的、不可重复的，使用Set存储所有的entry。</li></ul><h2 id="HashMap的底层实现原理【以jdk7为例】"><a href="#HashMap的底层实现原理【以jdk7为例】" class="headerlink" title="HashMap的底层实现原理【以jdk7为例】"></a>HashMap的底层实现原理【以jdk7为例】</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">在实例化以后，底层创建了长度是<span class="number">16</span>的一维数组Entry[] table。</span><br><span class="line">...可能已经执行过多次put...</span><br><span class="line"></span><br><span class="line">map.put(key1,value1):</span><br><span class="line">首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到Entry数组中的存放位置。</span><br><span class="line">如果此位置上的数据为空，此时的key1-value1添加成功。-----情况<span class="number">1</span></span><br><span class="line">如果此位置上的数据不为空，（意味着此位置上存在一个或多个数据（以链表形式存在）），比较key1和已经存在的一个或多个数据的哈希值:</span><br><span class="line">如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。-----情况<span class="number">2</span></span><br><span class="line">如果key1的哈希值与已经存在的数据的哈希值相同，将要进一步比较，调用key1所在类的equnls(key2)方法进行比较:</span><br><span class="line">如果equals()返回<span class="keyword">false</span>：此时key1和value1添加成功。-----情况<span class="number">3</span></span><br><span class="line">如果equals()返回<span class="keyword">true</span>：使用value1替换value2。</span><br><span class="line"></span><br><span class="line">补充：关于情况<span class="number">2</span>和情况<span class="number">3</span>：此时key1-value1和原来的数据以链表的方式存储。</span><br><span class="line"></span><br><span class="line">在不断添加的过程中，会涉及到数组的扩容问题，当超出临界值（且要存放的位置非空）时扩容。默认的扩容方式：扩容为原来容量的<span class="number">2</span>倍，并将原有的数据赋值过来。</span><br><span class="line"></span><br><span class="line">JDK8相较于JDK7在底层实现方面的不同：</span><br><span class="line"><span class="number">1</span>：<span class="keyword">new</span> HashMap():底层没有创建一个长度为<span class="number">16</span>的数组。</span><br><span class="line"><span class="number">2</span>：JDK8 底层采用的数组是Node[]，而非Entry[]。</span><br><span class="line"><span class="number">3</span>：首次调用put()方法时，底层创建长度为<span class="number">16</span>的数组。</span><br><span class="line"><span class="number">4</span>：JDK7底层结构只有：数组+链表。JDK8底层结构：数组+链表+红黑树。</span><br><span class="line"><span class="number">4.1</span>：形成链表时，七上八下（JDK7：新的元素指向指向旧的元素。JDK8:旧的元素指向新的元素）</span><br><span class="line"><span class="number">4.2</span>：当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; <span class="number">8</span> 且当前数组长度 &gt; <span class="number">64</span> 时，此时索引位置上的所有数据改为使用红黑树存储。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HashMap源码中的重要常量："><a href="#HashMap源码中的重要常量：" class="headerlink" title="HashMap源码中的重要常量："></a>HashMap源码中的重要常量：</h2><ul><li><strong>DEFAULT_INITIAL_CAPACITY :</strong> HashMap的默认容量，16</li><li><strong>MAXIMUM_CAPACITY ：</strong> HashMap的最大支持容量，2^30</li><li><strong>DEFAULT_LOAD_FACTOR：</strong>HashMap的默认加载因子</li><li><strong>TREEIFY_THRESHOLD：</strong>Bucket中链表长度大于该默认值，转化为红黑树</li><li><strong>UNTREEIFY_THRESHOLD：</strong>Bucket中红黑树存储的Node小于该默认值，转化为链表</li><li><strong>MIN_TREEIFY_CAPACITY：</strong>桶中的Node被树化时最小的hash表容量。（当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。）</li><li><strong>table：</strong>存储元素的数组，总是2的n次幂</li><li><strong>entrySet：</strong>存储具体元素的集</li><li><strong>size：</strong>HashMap中存储的键值对的数量</li><li><strong>modCount：</strong>HashMap扩容和结构改变的次数。</li><li><strong>threshold：</strong>扩容的临界值，=容量*填充因子</li><li><strong>loadFactor：</strong>填充因子</li></ul><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap:"></a>LinkedHashMap:</h2><ul><li>LinkedHashMap 是 HashMap 的子类。</li><li>在HashMap 存储结构的基础上，使用了一对双向链表来记录添加元素的顺序。</li><li>与LinkedHashSet 类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致。</li></ul><h3 id="HashMap与LinkedHashMap的底层源码比较："><a href="#HashMap与LinkedHashMap的底层源码比较：" class="headerlink" title="HashMap与LinkedHashMap的底层源码比较："></a>HashMap与LinkedHashMap的底层源码比较：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--------------HashMap底层源码：</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line">Node&lt;K,V&gt; next; </span><br><span class="line">&#125;</span><br><span class="line">--------------LinkeHashMap底层源码：</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">Entry&lt;K,V&gt; before, after;</span><br><span class="line">Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line"><span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map常用方法："><a href="#Map常用方法：" class="headerlink" title="Map常用方法："></a>Map常用方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"> 添加、删除、修改操作：</span><br><span class="line"> <span class="function">Object <span class="title">put</span><span class="params">(Object key,Object value)</span>：将指定key-value添加到<span class="params">(或修改)</span>当前map对象中</span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map m)</span>:将m中的所有key-value对存放到当前map中</span></span><br><span class="line"><span class="function"> Object <span class="title">remove</span><span class="params">(Object key)</span>：移除指定key的key-value对，并返回value</span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>：清空当前map中的所有数据</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> 元素查询的操作：</span></span><br><span class="line"><span class="function"> Object <span class="title">get</span><span class="params">(Object key)</span>：获取指定key对应的value</span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span>：是否包含指定的key</span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span>：是否包含指定的value</span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>：返回map中key-value对的个数</span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>：判断当前map是否为空</span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>：判断当前map和参数对象obj是否相等</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> 元视图操作的方法：</span></span><br><span class="line"><span class="function"> Set <span class="title">keySet</span><span class="params">()</span>：返回所有key构成的Set集合</span></span><br><span class="line"><span class="function"> Collection <span class="title">values</span><span class="params">()</span>：返回所有value构成的Collection集合</span></span><br><span class="line"><span class="function"> Set <span class="title">entrySet</span><span class="params">()</span>：返回所有key-value对构成的Set集合</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 添加 删除 修改</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    map.put(<span class="string">&quot;AA&quot;</span>,<span class="number">123</span>);</span><br><span class="line">    map.put(<span class="number">45</span>,<span class="number">123</span>);</span><br><span class="line">    map.put(<span class="string">&quot;BB&quot;</span>,<span class="number">56</span>);</span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    map.put(<span class="string">&quot;AA&quot;</span>,<span class="number">87</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line"></span><br><span class="line">    Map map1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map1.put(<span class="string">&quot;CC&quot;</span>,<span class="number">123</span>);</span><br><span class="line">    map1.put(<span class="string">&quot;DD&quot;</span>,<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">    map.putAll(map1);</span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//remove(Object key)</span></span><br><span class="line">    Object value = map.remove(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    System.out.println(value);</span><br><span class="line">    System.out.println(map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//clear()</span></span><br><span class="line">    map.clear();<span class="comment">//与map = null操作不同</span></span><br><span class="line">    System.out.println(map.size());</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">&quot;AA&quot;</span>,<span class="number">123</span>);</span><br><span class="line">        map.put(<span class="number">45</span>,<span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">&quot;BB&quot;</span>,<span class="number">56</span>);</span><br><span class="line">        <span class="comment">// Object get(Object key)</span></span><br><span class="line">        System.out.println(map.get(<span class="number">45</span>));</span><br><span class="line">        <span class="comment">//containsKey(Object key)</span></span><br><span class="line">        <span class="keyword">boolean</span> isExist = map.containsKey(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">        System.out.println(isExist);</span><br><span class="line"></span><br><span class="line">        isExist = map.containsValue(<span class="number">123</span>);</span><br><span class="line">        System.out.println(isExist);</span><br><span class="line"></span><br><span class="line">        map.clear();</span><br><span class="line"></span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 元视图：俗称遍历。   </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">&quot;AA&quot;</span>,<span class="number">123</span>);</span><br><span class="line">        map.put(<span class="number">45</span>,<span class="number">1234</span>);</span><br><span class="line">        map.put(<span class="string">&quot;BB&quot;</span>,<span class="number">56</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历所有的key集：keySet()</span></span><br><span class="line">        Set set = map.keySet();</span><br><span class="line">            Iterator iterator = set.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//遍历所有的value集：values()</span></span><br><span class="line">        Collection values = map.values();</span><br><span class="line">        <span class="keyword">for</span>(Object obj : values)&#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//遍历所有的key-value</span></span><br><span class="line">        <span class="comment">//方式一：entrySet()</span></span><br><span class="line">        Set entrySet = map.entrySet();</span><br><span class="line">        Iterator iterator1 = entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">            Object obj = iterator1.next();</span><br><span class="line">            <span class="comment">//entrySet集合中的元素都是entry</span></span><br><span class="line">            Map.Entry entry = (Map.Entry) obj;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;----&gt;&quot;</span> + entry.getValue());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//方式二：</span></span><br><span class="line">        Set keySet = map.keySet();</span><br><span class="line">        Iterator iterator2 = keySet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator2.hasNext())&#123;</span><br><span class="line">            Object key = iterator2.next();</span><br><span class="line">            Object value = map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=====&quot;</span> + value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap:"></a>TreeMap:</h2><ul><li>TreeMap存储 Key-value对时，需要根据 key-value对进行排序。TreeMap 可以保证所有的 Key-Value 对处于有序状态。</li><li>TreeSet底层使用红黑树结构存储数据。</li><li>TreeMap的key排序：<ul><li>自然排序：TreeMap 的所有Key必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClassCastException。</li><li>定制排序：创建 TreeMap 时,传入一个Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 key 实现 Comparable 接口。</li></ul></li><li>TreeMap判断两个key相等的标准：两个key通过 commparTo() 方法或者compare() 方法返回0。</li></ul><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMapTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向TreeMap中添加key-value，要求key必须是由同一个类创建的对象</span></span><br><span class="line">    <span class="comment">//因为要按照key进行排序：自然排序 、定制排序</span></span><br><span class="line">    <span class="comment">//自然排序</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeMap map = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="string">&quot;Rose&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    </span><br><span class="line">        map.put(u1,<span class="number">98</span>);</span><br><span class="line">        map.put(u2,<span class="number">89</span>);</span><br><span class="line">        map.put(u3,<span class="number">76</span>);</span><br><span class="line">        map.put(u4,<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">        Set entrySet = map.entrySet();</span><br><span class="line">        Iterator iterator1 = entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">            Object obj = iterator1.next();</span><br><span class="line">            Map.Entry entry = (Map.Entry) obj;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;----&gt;&quot;</span> + entry.getValue());</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定制排序</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeMap map = <span class="keyword">new</span> TreeMap(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">                    User u1 = (User)o1;</span><br><span class="line">                    User u2 = (User)o2;</span><br><span class="line">                    <span class="keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入的类型不匹配！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="string">&quot;Rose&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    </span><br><span class="line">        map.put(u1,<span class="number">98</span>);</span><br><span class="line">        map.put(u2,<span class="number">89</span>);</span><br><span class="line">        map.put(u3,<span class="number">76</span>);</span><br><span class="line">        map.put(u4,<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">        Set entrySet = map.entrySet();</span><br><span class="line">        Iterator iterator1 = entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">            Object obj = iterator1.next();</span><br><span class="line">            Map.Entry entry = (Map.Entry) obj;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;----&gt;&quot;</span> + entry.getValue());</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hashtable："><a href="#Hashtable：" class="headerlink" title="Hashtable："></a>Hashtable：</h2><ul><li>Hashtable 是个古老的 Map 实现类，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的。</li><li>Hashtable 实现原理和 HashMap 相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以户用。</li><li>与HashMap不同，Hashtable 不允许使用 null 作为 key 和value。</li><li>与HashMap一样，Hashtable 也不能保证其中 key-value 对的顺序。</li><li>Hashtable 判断两个key相等、两个value相等的标准，与HashMap一致。</li></ul><h2 id="Properties："><a href="#Properties：" class="headerlink" title="Properties："></a>Properties：</h2><ul><li>Properties 类是 Hashtable 的子类，该对象用于处理属性文件。</li><li>由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型。</li><li>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法。</li></ul><p><strong>Demo</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">pros.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;jdbc.properties&quot;</span>));</span><br><span class="line">String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure><h2 id="Collections工具类："><a href="#Collections工具类：" class="headerlink" title="Collections工具类："></a>Collections工具类：</h2><ul><li><p>Collections 是一个操作 Set、List 和 Map 等集合的工具类。</p></li><li><p>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。</p></li><li><p><strong>排序操作</strong>：（均为static方法）</p><p>reverse(List)：反转 List 中元素的顺序</p><p>shuffle(List)：对 List 集合元素进行随机排序</p><p>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</p><p>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</p><p>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</p></li></ul><p><strong>Demo</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reverse(List)：反转 List 中元素的顺序</span></span><br><span class="line"><span class="comment">shuffle(List)：对 List 集合元素进行随机排序</span></span><br><span class="line"><span class="comment">sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</span></span><br><span class="line"><span class="comment">sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span></span><br><span class="line"><span class="comment">swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</span></span><br><span class="line"><span class="comment">Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</span></span><br><span class="line"><span class="comment">Object min(Collection)</span></span><br><span class="line"><span class="comment">Object min(Collection，Comparator)</span></span><br><span class="line"><span class="comment">int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</span></span><br><span class="line"><span class="comment">void copy(List dest,List src)：将src中的内容复制到dest中</span></span><br><span class="line"><span class="comment">boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="number">43</span>);</span><br><span class="line">        list.add(<span class="number">765</span>);</span><br><span class="line">        list.add(-<span class="number">97</span>);</span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//报异常：IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        List dest = new ArrayList();</span></span><br><span class="line"><span class="comment">//        Collections.copy(dest,list);</span></span><br><span class="line">        <span class="comment">//正确的：</span></span><br><span class="line">        List dest = Arrays.asList(<span class="keyword">new</span> Object[list.size()]);</span><br><span class="line">        System.out.println(dest.size());<span class="comment">//list.size();</span></span><br><span class="line">        Collections.copy(dest,list);</span><br><span class="line"></span><br><span class="line">        System.out.println(dest);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Collections 类中提供了多个 synchronizedXxx() 方法，</span></span><br><span class="line"><span class="comment">        该方法可使将指定集合包装成线程同步的集合，从而可以解决</span></span><br><span class="line"><span class="comment">        多线程并发访问集合时的线程安全问题</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//返回的list1即为线程安全的List</span></span><br><span class="line">        List list1 = Collections.synchronizedList(list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="number">43</span>);</span><br><span class="line">        list.add(<span class="number">765</span>);</span><br><span class="line">        list.add(<span class="number">765</span>);</span><br><span class="line">        list.add(<span class="number">765</span>);</span><br><span class="line">        list.add(-<span class="number">97</span>);</span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Collections.reverse(list);</span></span><br><span class="line"><span class="comment">//        Collections.shuffle(list);</span></span><br><span class="line"><span class="comment">//        Collections.sort(list);</span></span><br><span class="line"><span class="comment">//        Collections.swap(list,1,2);</span></span><br><span class="line">        <span class="keyword">int</span> frequency = Collections.frequency(list, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(frequency);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Map接口继承树：&quot;&gt;&lt;a href=&quot;#Map接口继承树：&quot; class=&quot;headerlink&quot; title=&quot;Map接口继承树：&quot;&gt;&lt;/a&gt;Map接口继承树：&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/Collection/Map_1.png&quot;&gt;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java集合三</title>
    <link href="https://7heng.github.io/2021/04/17/java%E9%9B%86%E5%90%88%E4%B8%89/"/>
    <id>https://7heng.github.io/2021/04/17/java%E9%9B%86%E5%90%88%E4%B8%89/</id>
    <published>2021-04-17T09:52:04.000Z</published>
    <updated>2021-04-18T07:19:55.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Collectin子接口之一：Set接口"><a href="#Collectin子接口之一：Set接口" class="headerlink" title="Collectin子接口之一：Set接口"></a>Collectin子接口之一：Set接口</h1><h3 id="Set接口概述："><a href="#Set接口概述：" class="headerlink" title="Set接口概述："></a>Set接口概述：</h3><ul><li>Set接口是Collection的子接口,Set接口没有提供额外的方法。</li><li>Set集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set集合中，则添加操作失败。</li><li>Set判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法。</li></ul><h3 id="Set实现类之一：HashSet"><a href="#Set实现类之一：HashSet" class="headerlink" title="Set实现类之一：HashSet"></a>Set实现类之一：HashSet</h3><ul><li><p>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。</p></li><li><p>HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。</p></li><li><p><strong>HashSet</strong> <strong>具有以下特点：</strong></p><ul><li>不能保证元素的排列顺序。</li><li>HashSet 不是线程安全的。</li><li>集合元素可以是 null。</li></ul></li><li><p><strong>HashSet</strong> <strong>集合判断两个元素相等的标准</strong>：两个对象通过 hashCode() 方法比较相</p><p>等，并且两个对象的 equals() 方法返回值也相等。 </p></li><li><p>对于存放在Set容器中的对象，<strong>对应的类一定要重写equals()和hashCode(Object</strong></p><p><strong>obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。</strong></p></li></ul><h3 id="向HashSet中添加元素的过程："><a href="#向HashSet中添加元素的过程：" class="headerlink" title="向HashSet中添加元素的过程："></a>向HashSet中添加元素的过程：</h3><ul><li><p>当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据hashCode 值，通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好）。 </p></li><li><p>如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果</p><p>为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了，</p><p>那么会通过链表的方式继续链接。 </p></li><li><p>如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相</p><p>等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。</p></li></ul><h3 id="HashSet结构图："><a href="#HashSet结构图：" class="headerlink" title="HashSet结构图："></a>HashSet结构图：</h3><p><img src="/images/Collection/Set_1.png"></p><h3 id="Set接口框架："><a href="#Set接口框架：" class="headerlink" title="Set接口框架："></a>Set接口框架：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">|----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”</span><br><span class="line">|----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储<span class="keyword">null</span>值</span><br><span class="line">|----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历</span><br><span class="line">|----TreeSet：可以按照添加对象的指定属性，进行排序</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>：对于频繁的遍历操作，LinkedHashSet效率高于HashSet。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>：Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>：要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()</span><br><span class="line">   要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码</span><br><span class="line">   重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Set：存储无序的、不可重复的数据</span><br><span class="line">    以HashSet为例说明：</span><br><span class="line">    <span class="number">1.</span> 无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。</span><br><span class="line"></span><br><span class="line">    <span class="number">2.</span> 不可重复性：保证添加的元素按照equals()判断时，不能返回<span class="keyword">true</span>.即：相同的元素只能添加一个。</span><br><span class="line"></span><br><span class="line">    添加元素的过程：以HashSet为例：</span><br><span class="line">        我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，</span><br><span class="line">        此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断</span><br><span class="line">        数组此位置上是否已经有元素：</span><br><span class="line">            如果此位置上没有其他元素，则元素a添加成功。 ---&gt;情况<span class="number">1</span></span><br><span class="line">            如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：</span><br><span class="line">                如果hash值不相同，则元素a添加成功。---&gt;情况<span class="number">2</span></span><br><span class="line">                如果hash值相同，进而需要调用元素a所在类的equals()方法：</span><br><span class="line">                       equals()返回<span class="keyword">true</span>,元素a添加失败</span><br><span class="line">                       equals()返回<span class="keyword">false</span>,则元素a添加成功。---&gt;情况<span class="number">3</span></span><br><span class="line"></span><br><span class="line">        对于添加成功的情况<span class="number">2</span>和情况<span class="number">3</span>而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。</span><br><span class="line">        jdk <span class="number">7</span> :元素a放到数组中，指向原来的元素。</span><br><span class="line">        jdk <span class="number">8</span> :原来的元素在数组中，指向元素a</span><br><span class="line">        总结：七上八下</span><br><span class="line"></span><br><span class="line">        HashSet底层：数组+链表的结构。</span><br><span class="line">------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Set set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        set.add(<span class="number">456</span>);</span><br><span class="line">        set.add(<span class="number">123</span>);</span><br><span class="line">        set.add(<span class="number">123</span>);</span><br><span class="line">        set.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        set.add(<span class="number">129</span>);</span><br><span class="line"></span><br><span class="line">        Iterator iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashSet的使用</span></span><br><span class="line">    <span class="comment">// LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个</span></span><br><span class="line">    <span class="comment">// 数据和后一个数据。</span></span><br><span class="line">    <span class="comment">// 优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Set set = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        set.add(<span class="number">456</span>);</span><br><span class="line">        set.add(<span class="number">123</span>);</span><br><span class="line">        set.add(<span class="number">123</span>);</span><br><span class="line">        set.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        set.add(<span class="number">129</span>);</span><br><span class="line"></span><br><span class="line">        Iterator iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TreeSet：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.向TreeSet中添加的数据，要求是相同类的对象。</span></span><br><span class="line"><span class="comment">    2.两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    3.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals().</span></span><br><span class="line"><span class="comment">    4.定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeSet set = <span class="keyword">new</span> TreeSet();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//失败：不能添加不同类的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        set.add(123);</span></span><br><span class="line"><span class="comment">//        set.add(456);</span></span><br><span class="line"><span class="comment">//        set.add(&quot;AA&quot;);</span></span><br><span class="line"><span class="comment">//   </span></span><br><span class="line"></span><br><span class="line">     set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//举例一：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        set.add(34);</span></span><br><span class="line"><span class="comment">//        set.add(-34);</span></span><br><span class="line"><span class="comment">//        set.add(43);</span></span><br><span class="line"><span class="comment">//        set.add(11);</span></span><br><span class="line"><span class="comment">//        set.add(8);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//举例二：</span></span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jim&quot;</span>,<span class="number">2</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Mike&quot;</span>,<span class="number">65</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>,<span class="number">33</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>,<span class="number">56</span>));</span><br><span class="line"></span><br><span class="line">    Iterator iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Comparator com = <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">        <span class="comment">//按照年龄从小到大排列</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">                User u1 = (User)o1;</span><br><span class="line">                User u2 = (User)o2;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入的数据类型不匹配&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TreeSet set = <span class="keyword">new</span> TreeSet(com);</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jim&quot;</span>,<span class="number">2</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Mike&quot;</span>,<span class="number">65</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Mary&quot;</span>,<span class="number">33</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>,<span class="number">33</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>,<span class="number">56</span>));</span><br><span class="line"></span><br><span class="line">    Iterator iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Collectin子接口之一：Set接口&quot;&gt;&lt;a href=&quot;#Collectin子接口之一：Set接口&quot; class=&quot;headerlink&quot; title=&quot;Collectin子接口之一：Set接口&quot;&gt;&lt;/a&gt;Collectin子接口之一：Set接口&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java集合二</title>
    <link href="https://7heng.github.io/2021/04/17/java%E9%9B%86%E5%90%88%E4%BA%8C/"/>
    <id>https://7heng.github.io/2021/04/17/java%E9%9B%86%E5%90%88%E4%BA%8C/</id>
    <published>2021-04-17T09:29:30.000Z</published>
    <updated>2021-04-18T07:19:36.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Collection子接口之一：List接口"><a href="#Collection子接口之一：List接口" class="headerlink" title="Collection子接口之一：List接口"></a>Collection子接口之一：List接口</h2><h3 id="List接口概述："><a href="#List接口概述：" class="headerlink" title="List接口概述："></a>List接口概述：</h3><ul><li>鉴于java中数组用来存储数据的局限性，我们通常使用List替代数组。</li><li>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</li><li>List容器中的元素对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li><li>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。</li></ul><h3 id="List接口框架"><a href="#List接口框架" class="headerlink" title="List接口框架"></a>List接口框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">|----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组,替换原有的数组</span><br><span class="line">|----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</span><br><span class="line">|----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</span><br><span class="line">|----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</span><br><span class="line"></span><br><span class="line"> -------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">2.</span> ArrayList的源码分析：</span><br><span class="line"></span><br><span class="line"><span class="number">2.1</span> jdk <span class="number">7</span>情况下：</span><br><span class="line"></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">//底层创建了长度是10的Object[]数组elementData</span></span><br><span class="line"></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//elementData[0] = new Integer(123);</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">11</span>);<span class="comment">//如果此次的添加导致底层elementData数组容量不够，则扩容。</span></span><br><span class="line"></span><br><span class="line">默认情况下，扩容为原来的容量的<span class="number">1.5</span>倍，同时需要将原有数组中的数据复制到新的数组中。</span><br><span class="line"> *</span><br><span class="line">结论：建议开发中使用带参的构造器：ArrayList list = <span class="keyword">new</span> ArrayList(<span class="keyword">int</span> capacity)</span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">2.2</span> jdk <span class="number">8</span>中ArrayList的变化：</span><br><span class="line"></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">//底层Object[] elementData初始化为&#123;&#125;.并没有创建长度为10的数组</span></span><br><span class="line"> *</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">后续的添加和扩容操作与jdk <span class="number">7</span> 无异。</span><br><span class="line"></span><br><span class="line"><span class="number">2.3</span> 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象</span><br><span class="line"></span><br><span class="line">的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> LinkedList的源码分析：</span><br><span class="line"></span><br><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList(); 内部声明了Node类型的first和last属性，默认值为<span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//将123封装到Node中，创建了Node对象。</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">其中，Node定义为：体现了LinkedList的双向链表的说法</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     E item;</span><br><span class="line">     Node&lt;E&gt; next;</span><br><span class="line">     Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">​```</span><br><span class="line"> Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line"> <span class="keyword">this</span>.item = element;</span><br><span class="line"> <span class="keyword">this</span>.next = next;</span><br><span class="line"> <span class="keyword">this</span>.prev = prev;</span><br><span class="line"> &#125;</span><br><span class="line">​```</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> ----------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> Vector的源码分析：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为<span class="number">10</span>的数组。</span><br><span class="line"></span><br><span class="line">在扩容方面，默认扩容为原来的数组长度的<span class="number">2</span>倍。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">面试题：ArrayList、LinkedList、Vector三者的异同？</span><br><span class="line"></span><br><span class="line">相同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据。</span><br><span class="line"></span><br><span class="line">不同：请阅读上文。</span><br></pre></td></tr></table></figure><h3 id="List接口中常用方法："><a href="#List接口中常用方法：" class="headerlink" title="List接口中常用方法："></a>List接口中常用方法：</h3><ul><li>void add(int index, Object ele):在index位置插入ele元素</li><li>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</li><li>Object get(int index):获取指定index位置的元素</li><li>int indexOf(Object obj):返回obj在集合中首次出现的位置</li><li>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</li><li>Object remove(int index):移除指定index位置的元素，并返回此元素</li><li>Object set(int index, Object ele):设置指定index位置的元素为ele</li><li>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="number">456</span>);</span><br><span class="line">        list.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        list.add(<span class="number">456</span>);</span><br><span class="line">        <span class="comment">//int indexOf(Object obj):返回obj在集合中首次出现的位置。如果不存在，返回-1.</span></span><br><span class="line">        <span class="keyword">int</span> index = list.indexOf(<span class="number">4567</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置。如果不存在，返回-1.</span></span><br><span class="line">        System.out.println(list.lastIndexOf(<span class="number">456</span>));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//Object remove(int index):移除指定index位置的元素，并返回此元素</span></span><br><span class="line">        Object obj = list.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//Object set(int index, Object ele):设置指定index位置的元素为ele</span></span><br><span class="line">        list.set(<span class="number">1</span>,<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的左闭右开区间的子集合</span></span><br><span class="line">        List subList = list.subList(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(subList);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="number">456</span>);</span><br><span class="line">        list.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        list.add(<span class="number">456</span>);</span><br><span class="line">    </span><br><span class="line">        System.out.println(list);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//void add(int index, Object ele):在index位置插入ele元素</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line">        List list1 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        list.addAll(list1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//list.add(list1);</span></span><br><span class="line">        System.out.println(list.size());<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Object get(int index):获取指定index位置的元素</span></span><br><span class="line">        System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">总结：常用方法</span><br><span class="line">增：add(Object obj)</span><br><span class="line">删：remove(<span class="keyword">int</span> index) / remove(Object obj)</span><br><span class="line">改：set(<span class="keyword">int</span> index, Object ele)</span><br><span class="line">查：get(<span class="keyword">int</span> index)</span><br><span class="line">插：add(<span class="keyword">int</span> index, Object ele)</span><br><span class="line">长度：size()</span><br></pre></td></tr></table></figure><h3 id="List遍历："><a href="#List遍历：" class="headerlink" title="List遍历："></a>List遍历：</h3><ul><li> Iterator迭代器方式</li><li>增强for循环</li><li>普通的循环</li></ul><pre><code>@Testpublic void test3()&#123;    ArrayList list = new ArrayList();    list.add(123);    list.add(456);    list.add(&quot;AA&quot;);<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：Iterator迭代器方式</span></span><br><span class="line">Iterator iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：增强for循环</span></span><br><span class="line"><span class="keyword">for</span>(Object obj : list)&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三：普通for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Collection子接口之一：List接口&quot;&gt;&lt;a href=&quot;#Collection子接口之一：List接口&quot; class=&quot;headerlink&quot; title=&quot;Collection子接口之一：List接口&quot;&gt;&lt;/a&gt;Collection子接口之一：List</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java比较器</title>
    <link href="https://7heng.github.io/2021/04/17/java%E6%AF%94%E8%BE%83%E5%99%A8/"/>
    <id>https://7heng.github.io/2021/04/17/java%E6%AF%94%E8%BE%83%E5%99%A8/</id>
    <published>2021-04-17T08:39:32.000Z</published>
    <updated>2021-04-18T07:18:50.261Z</updated>
    
    <content type="html"><![CDATA[<p>java中的对象，正常情况下，只能进行比较：== 或 != ，是不能使用 &gt; 或 &lt; 的，但是在开发场景中，我们需要多个对象进行排序，言外之意，就需要比较对象的大小。如何实现？使用两个接口中的任何一个：Comperable 或 Compartor。</p><p><strong>Comparable接口与Compartor的使用的对比：</strong></p><ul><li>Comparable接口的方式一旦一定：保证Comparable接口实现类的对象在任何位置都可以比较大小。</li><li>Compartor属于临时性的比较。</li></ul><p><strong>为何要重写Comparable接口：</strong></p><ol><li>基本数据类型和String类型数据，它们彼此的比较标准java语言本身已经提供好了。</li><li>用户自定义类对象之间比较的标准java语言本身是没有提供的。</li><li>所以如果一个容器中包含用户自定义类型的数据，并且我们需要对容器中元素进行排序或者查找某一元素时，我们就必须得到定制容器中元素与元素之间的标准。</li><li>凡是需要进行对象比较/排序的场合均可考虑实现Comparable接口。</li></ol><p><strong>Comparable接口的使用举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">自然排序：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。</span><br><span class="line"><span class="number">2.</span>像String、包装类重写compareTo()方法以后，进行了从小到大的排列</span><br><span class="line"><span class="number">3.</span> 重写compareTo(obj)的规则：</span><br><span class="line">    如果当前对象<span class="keyword">this</span>大于形参对象obj，则返回正整数，</span><br><span class="line">    如果当前对象<span class="keyword">this</span>小于形参对象obj，则返回负整数，</span><br><span class="line">    如果当前对象<span class="keyword">this</span>等于形参对象obj，则返回零。</span><br><span class="line"><span class="number">4.</span> 对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。</span><br><span class="line">   在compareTo(obj)方法中指明如何排序</span><br><span class="line">---------------------------------------------------------------------------   </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Goods[] arr = <span class="keyword">new</span> Goods[<span class="number">5</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovoMouse&quot;</span>,<span class="number">34</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dellMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;xiaomiMouse&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">65</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;microsoftMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr); <span class="comment">// 数组的排序方法，但因为是自定义类，所以需要自己重写ComparaTo(Obj)方法</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span>  <span class="title">Comparable</span></span>&#123;<span class="comment">// 实现Comparable接口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Goods&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指明商品比较大小的方式:按照价格从低到高排序,再按照产品名称从高到低排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;**************&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            Goods goods = (Goods)o;</span><br><span class="line">            <span class="comment">//方式一：</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line">               <span class="keyword">return</span> -<span class="keyword">this</span>.name.compareTo(goods.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//方式二：</span></span><br><span class="line"><span class="comment">//           return Double.compare(this.price,goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        return 0;</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Comparatot接口的使用举例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">定制排序：</span><br><span class="line"></span><br><span class="line">1.背景：</span><br><span class="line">当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，</span><br><span class="line">或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，</span><br><span class="line">那么可以考虑使用 Comparator 的对象来排序</span><br><span class="line">2.重写compare(Object o1,Object o2)方法，比较o1和o2的大小：</span><br><span class="line">如果方法返回正整数，则表示o1大于o2；</span><br><span class="line">如果返回0，表示相等；</span><br><span class="line">返回负整数，表示o1小于o2。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">    Arrays.sort(arr,<span class="keyword">new</span> Comparator()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照字符串从大到小的顺序排列</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> String &amp;&amp; o2 <span class="keyword">instanceof</span>  String)&#123;</span><br><span class="line">                String s1 = (String) o1;</span><br><span class="line">                String s2 = (String) o2;</span><br><span class="line">                <span class="keyword">return</span> -s1.compareTo(s2);<span class="comment">// 默认是重小到大排序，加-号改变排序方式。</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Goods[] arr = <span class="keyword">new</span> Goods[<span class="number">6</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovoMouse&quot;</span>,<span class="number">34</span>);</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dellMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;xiaomiMouse&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">65</span>);</span><br><span class="line">    arr[<span class="number">4</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">224</span>);</span><br><span class="line">    arr[<span class="number">5</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;microsoftMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">    Arrays.sort(arr, <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">        <span class="comment">//指明商品比较大小的方式:按照产品名称从低到高排序,再按照价格从高到低排序</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">                Goods g1 = (Goods)o1;</span><br><span class="line">                Goods g2 = (Goods)o2;</span><br><span class="line">                <span class="keyword">if</span>(g1.getName().equals(g2.getName()))&#123;</span><br><span class="line">                    <span class="keyword">return</span> -Double.compare(g1.getPrice(),g2.getPrice());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java中的对象，正常情况下，只能进行比较：== 或 != ，是不能使用 &amp;gt; 或 &amp;lt; 的，但是在开发场景中，我们需要多个对象进行排序，言外之意，就需要比较对象的大小。如何实现？使用两个接口中的任何一个：Comperable 或 Compartor。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java集合一</title>
    <link href="https://7heng.github.io/2021/04/16/java%E9%9B%86%E5%90%88%E4%B8%80/"/>
    <id>https://7heng.github.io/2021/04/16/java%E9%9B%86%E5%90%88%E4%B8%80/</id>
    <published>2021-04-16T13:27:41.000Z</published>
    <updated>2021-04-18T07:20:39.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：集合框架的概述"><a href="#一：集合框架的概述" class="headerlink" title="一：集合框架的概述"></a>一：集合框架的概述</h1><p>1：集合、数组都是对多个数据进行存储操作的结构，简称java容器。</p><p>说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt，.jpg，.avi，数据库中）</p><p>2：<strong>数组在存储多个数据方面的特点：</strong></p><ul><li>一旦初始化以后，其长度就确定了。</li><li>数组一旦定义好，其元素的类型也就确定了，我们也只能操作指定类型的数据了。<ul><li>比如：String[] arr;int[] arr1;object[] arr2;</li></ul></li></ul><p><strong>数组在存储多个数据方面的缺点：</strong></p><ul><li>一旦初始化以后，其长度就不可修改。</li><li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li><li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用。</li><li>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</li></ul><p><strong>Collection接口继承树：</strong></p><p><img src="/images/Collection/Collection_1.png"></p><h2 id="二：集合框架"><a href="#二：集合框架" class="headerlink" title="二：集合框架"></a>二：集合框架</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">|----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组</span><br><span class="line">|----ArrayList、LinkedList、Vector</span><br><span class="line"></span><br><span class="line">|----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”</span><br><span class="line">|----HashSet、LinkedHashSet、TreeSet</span><br><span class="line"></span><br><span class="line">|----Map接口：双列集合，用来存储一对(key - value)一对的数据   --&gt;高中函数：y = f(x)</span><br><span class="line">|----HashMap、LinkedHashMap、TreeMap、Hashtable、Properties</span><br></pre></td></tr></table></figure><h2 id="三：Collection接口中的方法的使用"><a href="#三：Collection接口中的方法的使用" class="headerlink" title="三：Collection接口中的方法的使用"></a>三：Collection接口中的方法的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//add(Object e):将元素e添加到集合coll中</span></span><br><span class="line">        coll.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">        coll.add(<span class="number">123</span>);<span class="comment">//自动装箱</span></span><br><span class="line">        coll.add(<span class="keyword">new</span> Date());</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//size():获取添加的元素的个数</span></span><br><span class="line">        System.out.println(coll.size());<span class="comment">//4</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//addAll(Collection coll1):将coll1集合中的元素添加到当前的集合中</span></span><br><span class="line">        Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll1.add(<span class="number">456</span>);</span><br><span class="line">        coll1.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">        coll.addAll(coll1);</span><br><span class="line">    </span><br><span class="line">        System.out.println(coll.size());<span class="comment">//6</span></span><br><span class="line">        System.out.println(coll);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//clear():清空集合元素</span></span><br><span class="line">        coll.clear();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//isEmpty():判断当前集合是否为空</span></span><br><span class="line">        System.out.println(coll.isEmpty());</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四：集合和数组之间的转换"><a href="#四：集合和数组之间的转换" class="headerlink" title="四：集合和数组之间的转换"></a>四：集合和数组之间的转换</h3><p><strong>集合—&gt;数组：toArray()</strong></p><p><strong>数组—&gt;集合：调用Arrays类的静态方法：asList()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    coll.add(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.hashCode():返回当前对象的哈希值</span></span><br><span class="line">    System.out.println(coll.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.集合 ---&gt;数组：toArray()</span></span><br><span class="line">    Object[] arr = coll.toArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拓展：数组 ---&gt;集合:调用Arrays类的静态方法asList()</span></span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    List arr1 = Arrays.asList(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">    System.out.println(arr1.size());<span class="comment">// 1注意：这里是new了一个数组，但数组在列表中是一个元素，在数组中是有两个元素。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">  Collection接口中声明的方法的测试</span><br><span class="line"> </span><br><span class="line">  结论：</span><br><span class="line"> 向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals().</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Person p = new Person(&quot;Jerry&quot;,20);</span></span><br><span class="line"><span class="comment">//        coll.add(p);</span></span><br><span class="line">        coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//1.contains(Object obj):判断当前集合中是否包含obj</span></span><br><span class="line">        <span class="comment">//我们在判断时会调用obj对象所在类的equals()。</span></span><br><span class="line">        <span class="keyword">boolean</span> contains = coll.contains(<span class="number">123</span>);</span><br><span class="line">        System.out.println(contains);</span><br><span class="line">        System.out.println(coll.contains(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>)));</span><br><span class="line"><span class="comment">//        System.out.println(coll.contains(p));//true</span></span><br><span class="line">        System.out.println(coll.contains(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>)));<span class="comment">//false --&gt;true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.containsAll(Collection coll1):判断形参coll1中的所有元素是否都存在于当前集合中。</span></span><br><span class="line">        Collection coll1 = Arrays.asList(<span class="number">123</span>,<span class="number">4567</span>);</span><br><span class="line">        System.out.println(coll.containsAll(coll1));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//3.remove(Object obj):从当前集合中移除obj元素。</span></span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">        coll.remove(<span class="number">1234</span>);</span><br><span class="line">        System.out.println(coll);</span><br><span class="line">    </span><br><span class="line">        coll.remove(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        System.out.println(coll);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//4. removeAll(Collection coll1):差集：从当前集合中移除coll1中所有的元素。</span></span><br><span class="line">        Collection coll1 = Arrays.asList(<span class="number">123</span>,<span class="number">456</span>);</span><br><span class="line">        coll.removeAll(coll1);</span><br><span class="line">        System.out.println(coll);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//5.retainAll(Collection coll1):交集：获取当前集合和coll1集合的交集，并返回给当前集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Collection coll1 = Arrays.asList(123,456,789);</span></span><br><span class="line"><span class="comment">//        coll.retainAll(coll1);</span></span><br><span class="line"><span class="comment">//        System.out.println(coll);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.equals(Object obj):要想返回true，需要当前集合和形参集合的元素都相同。</span></span><br><span class="line">        Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll1.add(<span class="number">456</span>);</span><br><span class="line">        coll1.add(<span class="number">123</span>);</span><br><span class="line">        coll1.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        coll1.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll1.add(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">        System.out.println(coll.equals(coll1));<span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五：Iterator"><a href="#五：Iterator" class="headerlink" title="五：Iterator()"></a>五：Iterator()</h3><p><strong>集合元素的遍历操作，使用迭代器Iterator接口</strong></p><ol><li>内部的方法：hasNext()和next()。</li><li>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</li><li>内部定义了remove()，可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()</li><li>如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException异常。</li></ol><p><strong>Iterator迭代器的执行原理</strong></p><p><img src="/images/Collection/Collection_2.png"></p><p><strong>Demo</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">        Iterator iterator = coll.iterator();</span><br><span class="line">        <span class="comment">//方式一：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        //报异常：NoSuchElementException</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        for(int i = 0;i &lt; coll.size();i++)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式三：推荐</span></span><br><span class="line">        <span class="comment">////hasNext():判断是否还有下一个元素</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            <span class="comment">//next():①指针下移 ②将下移以后集合位置上的元素返回</span></span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//错误方式一：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Iterator iterator = coll.iterator();</span></span><br><span class="line"><span class="comment">//        while((iterator.next()) != null)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//错误方式二：</span></span><br><span class="line">        <span class="comment">//集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</span></span><br><span class="line">        <span class="keyword">while</span> (coll.iterator().hasNext())&#123;</span><br><span class="line">            System.out.println(coll.iterator().next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//测试Iterator中的remove()</span></span><br><span class="line">    <span class="comment">//如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，</span></span><br><span class="line">    <span class="comment">// 再调用remove都会报IllegalStateException。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//删除集合中&quot;Tom&quot;</span></span><br><span class="line">        Iterator iterator = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            iterator.remove();</span></span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line"><span class="comment">//                iterator.remove();</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        iterator = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六：foreach"><a href="#六：foreach" class="headerlink" title="六：foreach"></a>六：foreach</h3><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">jdk 5.0 新增了foreach循环，用于遍历集合、数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       coll.add(<span class="number">123</span>);</span><br><span class="line">       coll.add(<span class="number">456</span>);</span><br><span class="line">       coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">       coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">       coll.add(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//for(集合元素的类型 局部变量 : 集合对象)</span></span><br><span class="line">       <span class="comment">//内部仍然调用了迭代器。</span></span><br><span class="line">       <span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">           System.out.println(obj);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">       <span class="comment">//for(数组元素的类型 局部变量 : 数组对象)</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//练习题</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;MM&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //方式一：普通for赋值</span></span><br><span class="line"><span class="comment">//        for(int i = 0;i &lt; arr.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//            arr[i] = &quot;GG&quot;;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：增强for循环</span></span><br><span class="line">        <span class="keyword">for</span>(String s : arr)&#123;</span><br><span class="line">            s = <span class="string">&quot;GG&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一：集合框架的概述&quot;&gt;&lt;a href=&quot;#一：集合框架的概述&quot; class=&quot;headerlink&quot; title=&quot;一：集合框架的概述&quot;&gt;&lt;/a&gt;一：集合框架的概述&lt;/h1&gt;&lt;p&gt;1：集合、数组都是对多个数据进行存储操作的结构，简称java容器。&lt;/p&gt;
&lt;p&gt;说</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>String类与StringBuffer和StringBuilder</title>
    <link href="https://7heng.github.io/2021/04/14/String%E7%B1%BB%E4%B8%8EStringBuffer%E5%92%8CStringBuilder/"/>
    <id>https://7heng.github.io/2021/04/14/String%E7%B1%BB%E4%B8%8EStringBuffer%E5%92%8CStringBuilder/</id>
    <published>2021-04-14T13:17:30.000Z</published>
    <updated>2021-04-18T07:22:37.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li>String字符串：使用一对” “引起来来标识。</li><li>String声明为final的，不可被继承。</li><li>String实现了Serializable接口：表示字符串是支持序列化的。<ul><li>实现了Comparable接口：表示String可以比较大小。</li></ul></li><li>String内部定义了final、char[]、value 用于存储字符串数据。</li><li>String：代表不可变的字符序列。简称：不可变性。<ul><li>体现：①：当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li><li>②：当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值。不能使用原有的value进行赋值。</li><li>③：当调用String的replace() 方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li></ul></li><li>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</li><li>字符串常量池是不会对相同内容的字符串开辟不同的空间的。</li></ul><p>**Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc&quot;</span>;<span class="comment">//字面量的定义方式</span></span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//比较s1和s2的地址值</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(s1);<span class="comment">//hello</span></span><br><span class="line">        System.out.println(s2);<span class="comment">//abc</span></span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;*****************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        String s3 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        s3 += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">        System.out.println(s3);<span class="comment">//abcdef</span></span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;*****************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        String s4 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String s5 = s4.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">        System.out.println(s4);<span class="comment">//abc</span></span><br><span class="line">        System.out.println(s5);<span class="comment">//mbc</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>String的实例化方式：</strong></p><ul><li>通过字面量定义的方式。</li><li>通过new + 构造器的方式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> 面试题：String s = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);方式创建对象，在内存中创建了几个对象？</span><br><span class="line">        两个:一个是堆空间中<span class="keyword">new</span>结构，另一个是<span class="keyword">char</span>[]对应的常量池中的数据：<span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过字面量定义的方式：此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。</span></span><br><span class="line">    String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    <span class="comment">//通过new + 构造器的方式:此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line">    String s4 = <span class="keyword">new</span> String(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">    System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s1 == s4);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;***********************&quot;</span>);</span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(p1.name.equals(p2.name));<span class="comment">//true</span></span><br><span class="line">    System.out.println(p1.name == p2.name);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    p1.name = <span class="string">&quot;Jerry&quot;</span>;</span><br><span class="line">    System.out.println(p2.name);<span class="comment">//Tom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>String的使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结论：</span></span><br><span class="line"><span class="comment">1.常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。</span></span><br><span class="line"><span class="comment">2.只要其中有一个是变量，结果就在堆中。</span></span><br><span class="line"><span class="comment">3.如果拼接的结果调用intern()方法，返回值就在常量池中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    String s3 = s2 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String s4 = <span class="string">&quot;javaEE&quot;</span>;<span class="comment">//s4:常量</span></span><br><span class="line">    String s5 = s4 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    System.out.println(s1 == s5);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">    String s4 = <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    String s5 = s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    String s6 = <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">    String s7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">    System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    String s8 = s6.intern();<span class="comment">//返回值得到的s8使用的常量值中已经存在的“javaEEhadoop”</span></span><br><span class="line">    System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>String与byte[]和char[]之间的转换：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    String 与 byte[]之间的转换</span></span><br><span class="line"><span class="comment">    编码：String --&gt; byte[]:调用String的getBytes()</span></span><br><span class="line"><span class="comment">    解码：byte[] --&gt; String:调用String的构造器</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    编码：字符串 --&gt;字节  (看得懂 ---&gt;看不懂的二进制数据)</span></span><br><span class="line"><span class="comment">    解码：编码的逆过程，字节 --&gt; 字符串 （看不懂的二进制数据 ---&gt; 看得懂）</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;abc123中国&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str1.getBytes();<span class="comment">//使用默认的字符集，进行编码。</span></span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">byte</span>[] gbks = str1.getBytes(<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用gbk字符集进行编码。</span></span><br><span class="line">        System.out.println(Arrays.toString(gbks));</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;******************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        String str2 = <span class="keyword">new</span> String(bytes);<span class="comment">//使用默认的字符集，进行解码。</span></span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    </span><br><span class="line">        String str3 = <span class="keyword">new</span> String(gbks);</span><br><span class="line">        System.out.println(str3);<span class="comment">//出现乱码。原因：编码集和解码集不一致！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String str4 = <span class="keyword">new</span> String(gbks, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        System.out.println(str4);<span class="comment">//没有出现乱码。原因：编码集和解码集一致！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    String 与 char[]之间的转换</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    String --&gt; char[]:调用String的toCharArray()</span></span><br><span class="line"><span class="comment">    char[] --&gt; String:调用String的构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;abc123&quot;</span>;  <span class="comment">//题目： a21cb3</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">char</span>[] charArray = str1.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">            System.out.println(charArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(arr);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    复习：</span></span><br><span class="line"><span class="comment">    String 与基本数据类型、包装类之间的转换。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    String --&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)</span></span><br><span class="line"><span class="comment">    基本数据类型、包装类 --&gt; String:调用String重载的valueOf(xxx)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        int num = (int)str1;//错误的</span></span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(str1);</span><br><span class="line"></span><br><span class="line">        String str2 = String.valueOf(num);<span class="comment">//&quot;123&quot;</span></span><br><span class="line">        String str3 = num + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">        System.out.println(str1 == str3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringBuffer："><a href="#StringBuffer：" class="headerlink" title="StringBuffer："></a>StringBuffer：</h2><p><strong>StringBuffer类由来</strong></p><ul><li>String类对象一旦创建就不可更改    </li><li>如果经常对字符串内容进行修改而使用String的话，就会导致即消耗空间又耗时间。</li><li>例子：<ul><li>String s1 = “abasdas”;        String str2 = “123”;</li><li>String s = s1 + s2;</li><li>删除str1中的字母d    </li></ul></li><li>StringBuffer对象的内容是可以改变的    </li><li>因此String类中没有修改字符串的方法，但是StringBuffer类中却有大量修改字符串的方法。</li></ul><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SBuffer</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.append(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sb =&quot;</span>+ sb);   <span class="comment">//  sb = abc123</span></span><br><span class="line">sb.insert(<span class="number">3</span>,<span class="string">&quot;--&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sb =&quot;</span>+ sb);  <span class="comment">//  sb = abc--123</span></span><br><span class="line">sb.delete(<span class="number">2</span>,<span class="number">6</span>);<span class="comment">//  把下标从2开始到下标为6-1的字符删除。  也即是6-2删除4个字符。</span></span><br><span class="line">System.out.println(<span class="string">&quot;sb = &quot;</span>+ sb);    <span class="comment">//  sb = ab23</span></span><br><span class="line">sb.reverse();</span><br><span class="line">System.out.println(<span class="string">&quot;sb = &quot;</span>+ sb);    <span class="comment">//  sb = 32ba</span></span><br><span class="line">String str = sb.toString();<span class="comment">//  转换为Strng对象。</span></span><br><span class="line">System.out.println(<span class="string">&quot;sb = &quot;</span>+ sb);<span class="comment">//  str = 32ba</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer的常用方法：</span><br><span class="line"></span><br><span class="line"><span class="function">StringBuffer <span class="title">append</span><span class="params">(xxx)</span>：提供了很多的<span class="title">append</span><span class="params">()</span>方法，用于进行字符串拼接</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>：删除指定位置的内容</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span>：把[start,end)位置替换为str</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, xxx)</span>：在指定位置插入xxx</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">reverse</span><span class="params">()</span> ：把当前字符序列逆转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>:返回一个从start开始到end索引结束的左闭右开区间的子字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        总结：</span></span><br><span class="line"><span class="function">        增：<span class="title">append</span><span class="params">(xxx)</span></span></span><br><span class="line"><span class="function">        删：<span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">        改：<span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">char</span> ch)</span> / <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span></span></span><br><span class="line"><span class="function">        查：<span class="title">charAt</span><span class="params">(<span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function">        插：<span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, xxx)</span></span></span><br><span class="line"><span class="function">        长度：<span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">        *遍历：<span class="keyword">for</span>() + charAt() / toString()</span><br><span class="line">     */</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuffer s1 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        s1.append(<span class="number">1</span>);</span><br><span class="line">        s1.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        s1.delete(2,4);</span></span><br><span class="line"><span class="comment">//        s1.replace(2,4,&quot;hello&quot;);</span></span><br><span class="line"><span class="comment">//        s1.insert(2,false);</span></span><br><span class="line"><span class="comment">//        s1.reverse();</span></span><br><span class="line">        String s2 = s1.substring(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s1.length());</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">对比String、StringBuffer、StringBuilder三者的效率：</span><br><span class="line">    从高到低排列：StringBuilder &gt; StringBuffer &gt; String</span><br><span class="line">     */</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始设置</span></span><br><span class="line">        <span class="keyword">long</span> startTime = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> endTime = <span class="number">0L</span>;</span><br><span class="line">        String text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//开始对比</span></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            buffer.append(String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuffer的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            builder.append(String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuilder的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            text = text + i;</span><br><span class="line">        &#125;</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;String的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小Tips：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">String、StringBuffer、StringBuilder三者的异同？</span><br><span class="line">String:不可变的字符序列；底层使用<span class="keyword">char</span>[]存储</span><br><span class="line">StringBuffer:可变的字符序列；线程安全的，效率低；底层使用<span class="keyword">char</span>[]存储</span><br><span class="line">StringBuilder:可变的字符序列；jdk5<span class="number">.0</span>新增的，线程不安全的，效率高；底层使用<span class="keyword">char</span>[]存储</span><br><span class="line"></span><br><span class="line">源码分析：</span><br><span class="line">String str = <span class="keyword">new</span> String();<span class="comment">//char[] value = new char[0];</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb1 = <span class="keyword">new</span> StringBuffer();<span class="comment">//char[] value = new char[16];底层创建了一个长度是16的数组。</span></span><br><span class="line">System.out.println(sb1.length());<span class="comment">//</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb2 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[&quot;abc&quot;.length() + 16];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//问题1. System.out.println(sb2.length());//3</span></span><br><span class="line"><span class="comment">//问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。</span></span><br><span class="line">         默认情况下，扩容为原来容量的<span class="number">2</span>倍 + <span class="number">2</span>，同时将原有数组中的元素复制到新的数组中。</span><br><span class="line"></span><br><span class="line">        指导意义：开发中建议大家使用：StringBuffer(<span class="keyword">int</span> capacity) 或 StringBuilder(<span class="keyword">int</span> capacity</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;String字符串：使用一对” “引起来来标识。&lt;/li&gt;
&lt;li&gt;String声明为final</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java包装类</title>
    <link href="https://7heng.github.io/2021/04/14/java%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>https://7heng.github.io/2021/04/14/java%E5%8C%85%E8%A3%85%E7%B1%BB/</id>
    <published>2021-04-14T12:16:01.000Z</published>
    <updated>2021-04-18T07:18:01.350Z</updated>
    
    <content type="html"><![CDATA[<ul><li>java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特性。</li></ul><p><img src="/images/java_Wrap/Wrap_1.png"></p><p><strong>Demo:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//String类型 ---&gt;基本数据类型、包装类：调用包装类的parseXxx(String s)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="comment">//错误的情况：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int num1 = (int)str1;</span></span><br><span class="line"><span class="comment">//Integer in1 = (Integer)str1;</span></span><br><span class="line"><span class="comment">//可能会报NumberFormatException</span></span><br><span class="line"><span class="keyword">int</span> num2 = Integer.parseInt(str1);</span><br><span class="line">System.out.println(num2 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String str2 = <span class="string">&quot;true1&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> b1 = Boolean.parseBoolean(str2);</span><br><span class="line">System.out.println(b1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本数据类型、包装类---&gt;String类型：调用String重载的valueOf(Xxx xxx)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//方式1：连接运算</span></span><br><span class="line">String str1 = num1 + <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">//方式2：调用String的valueOf(Xxx xxx)</span></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">12.3f</span>;</span><br><span class="line">String str2 = String.valueOf(f1);<span class="comment">//&quot;12.3&quot;</span></span><br><span class="line"></span><br><span class="line">Double d1 = <span class="keyword">new</span> Double(<span class="number">12.4</span>);</span><br><span class="line">String str3 = String.valueOf(d1);</span><br><span class="line">System.out.println(str2);</span><br><span class="line">System.out.println(str3);<span class="comment">//&quot;12.4&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * JDK 5.0 新特性：自动装箱 与自动拆箱</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int num1 = 10;</span></span><br><span class="line"><span class="comment">////基本数据类型--&gt;包装类的对象</span></span><br><span class="line"><span class="comment">//method(num1);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动装箱：基本数据类型 ---&gt;包装类</span></span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">Integer in1 = num2;<span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line">Boolean b2 = b1;<span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱：包装类---&gt;基本数据类型</span></span><br><span class="line">System.out.println(in1.toString());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num3 = in1;<span class="comment">//自动拆箱</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包装类---&gt;基本数据类型:调用包装类Xxx的xxxValue()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">Integer in1 = <span class="keyword">new</span> Integer(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i1 = in1.intValue();</span><br><span class="line">System.out.println(i1 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Float f1 = <span class="keyword">new</span> Float(<span class="number">12.3</span>);</span><br><span class="line"><span class="keyword">float</span> f2 = f1.floatValue();</span><br><span class="line">System.out.println(f2 + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本数据类型 ---&gt;包装类：调用包装类的构造器</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(num1.toString());</span></span><br><span class="line">Integer in1 = <span class="keyword">new</span> Integer(num1);</span><br><span class="line">System.out.println(in1.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer in2 = <span class="keyword">new</span> Integer(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(in2.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//报异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Integer in3 = new Integer(&quot;123abc&quot;);</span></span><br><span class="line"><span class="comment">//System.out.println(in3.toString());</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Float f1 = <span class="keyword">new</span> Float(<span class="number">12.3f</span>);</span><br><span class="line">Float f2 = <span class="keyword">new</span> Float(<span class="string">&quot;12.3&quot;</span>);</span><br><span class="line">System.out.println(f1);</span><br><span class="line">System.out.println(f2);</span><br><span class="line"></span><br><span class="line">Boolean b1 = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line">Boolean b2 = <span class="keyword">new</span> Boolean(<span class="string">&quot;TrUe&quot;</span>);</span><br><span class="line">System.out.println(b2);</span><br><span class="line">Boolean b3 = <span class="keyword">new</span> Boolean(<span class="string">&quot;true123&quot;</span>);</span><br><span class="line">System.out.println(b3);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Order order = <span class="keyword">new</span> Order();</span><br><span class="line">System.out.println(order.isMale);<span class="comment">//false</span></span><br><span class="line">System.out.println(order.isFemale);<span class="comment">//null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isMale;</span><br><span class="line">Boolean isFemale;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/java_Wrap/Wrap_1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Demo:&lt;/strong&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java之ToString</title>
    <link href="https://7heng.github.io/2021/04/14/java%E4%B9%8BToString/"/>
    <id>https://7heng.github.io/2021/04/14/java%E4%B9%8BToString/</id>
    <published>2021-04-14T11:56:45.000Z</published>
    <updated>2021-04-18T07:26:39.948Z</updated>
    
    <content type="html"><![CDATA[<p>tostring：</p><p>Object中的方法：</p><ul><li>当我们输出一个对象的引用时，实际上就是调用当前对象的tostring()。</li><li>Object类中的tostring()的定义：<ul><li>public String toString() {<pre><code>    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); &#125;</code></pre></li></ul></li><li>像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回实体内容”信息”。</li><li>自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”。</li></ul><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Customer cust1 = <span class="keyword">new</span> Customer(<span class="string">&quot;Tom&quot;</span>,<span class="number">21</span>);</span><br><span class="line">System.out.println(cust1.toString());<span class="comment">//com.heng.java1.Customer@15db9742--&gt;Customer[name = Tom,age = 21]</span></span><br><span class="line">System.out.println(cust1);<span class="comment">//com.atguigu.java1.Customer@15db9742--&gt;Customer[name = Tom,age = 21]</span></span><br><span class="line"></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;MM&quot;</span>);</span><br><span class="line">System.out.println(str);<span class="comment">//MM</span></span><br><span class="line"></span><br><span class="line">Date date = <span class="keyword">new</span> Date(<span class="number">4534534534543L</span>);</span><br><span class="line">System.out.println(date.toString());<span class="comment">//Mon Sep 11 08:55:34 GMT+08:00 2113</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;tostring：&lt;/p&gt;
&lt;p&gt;Object中的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当我们输出一个对象的引用时，实际上就是调用当前对象的tostring()。&lt;/li&gt;
&lt;li&gt;Object类中的tostring()的定义：&lt;ul&gt;
&lt;li&gt;public String to</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java之equals</title>
    <link href="https://7heng.github.io/2021/04/12/java%E4%B9%8Bequals/"/>
    <id>https://7heng.github.io/2021/04/12/java%E4%B9%8Bequals/</id>
    <published>2021-04-12T12:18:20.000Z</published>
    <updated>2021-04-18T07:26:14.643Z</updated>
    
    <content type="html"><![CDATA[<p>初学的小伙伴或许会对java中的<strong>equals</strong>和**==**有些混淆，不过请耐心看下面这篇文章，或许能帮您解决疑惑呦。</p><h3 id="：-运算符"><a href="#：-运算符" class="headerlink" title="==：(运算符)"></a>==：(运算符)</h3><p>1：可以使用在基本数据类型变量和引用数据类型变量中。</p><p>2：<strong>如果比较的是基本数据类型变量：</strong>比较两个变量保存的数据是否相等（不一定类型要相同）。</p><p>3：<strong>如果比价的是引用数据类型变量：</strong>比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体。</p><p>4：== 符号使用时，必须保证符号左右两边的变量类型一致。</p><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本数据类型</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">10.0</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//true</span></span><br><span class="line">System.out.println(i == d);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(i == b);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c = <span class="number">10</span>;</span><br><span class="line">System.out.println(i == c);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c1 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = <span class="number">65</span>;</span><br><span class="line">System.out.println(c1 == c2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用类型：</span></span><br><span class="line">Customer cust1 = <span class="keyword">new</span> Customer(<span class="string">&quot;Tom&quot;</span>,<span class="number">21</span>);</span><br><span class="line">Customer cust2 = <span class="keyword">new</span> Customer(<span class="string">&quot;Tom&quot;</span>,<span class="number">21</span>);</span><br><span class="line">System.out.println(cust1 == cust2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;****************************&quot;</span>);</span><br><span class="line">System.out.println(cust1.equals(cust2));<span class="comment">//false---&gt;true</span></span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Date date1 = <span class="keyword">new</span> Date(<span class="number">32432525324L</span>);</span><br><span class="line">Date date2 = <span class="keyword">new</span> Date(<span class="number">32432525324L</span>);</span><br><span class="line">System.out.println(date1.equals(date2));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="equels-方法"><a href="#equels-方法" class="headerlink" title="equels()方法"></a><strong>equels()方法</strong></h3><ul><li><p>Object类的equals方法：</p><ul><li><p>所有类都从Object类中继承了equals方法：</p><ul><li><p>Object类中equals 方法的源代码如下：</p><p>public boolean equals(Object obj) {</p><p>return this == obj;</p><p>}</p></li></ul></li><li><p>Object中的equals方法是直接判断this和obj本身的值是否相等，即可用来判断调用equals的对象和形参obj所引用的对象是否是同一对象，<strong>所谓同一对象就是指是否是内存中同一块存储单元</strong>，如果 this 和 obj 指向的是同一块内存对象，即返回true，如果 this 和 obj指向的不是同一块内存，即返回false。我们可以认为当不重写equals方法时，equals与==是相同的。</p></li></ul><p><strong>注意：即便是内容完全相等的两块不同的内存对象，也会返回false。</strong></p><p><strong>总结：</strong>如果是同一块内存，则Object中的equals方法返回true，如果是不同的内存，则返回false。</p><p><strong>何时需要重写equals方法：</strong></p><ol><li>用一个类构造出来的不同内存的两个对象，如果内存中的值相等，我们一般情况下也应该认为这两个对象相等，很明显Object中的equals()无法完成这样的重任，Object中的equals()方法只有在两个对象是同一块内存时，才返回true，这时候我们就有必要重写父类Object中的equals()方法。</li><li>如果希望不同内存但相同内容的两个对象equals时返回true，我们就需要重写父类的equals方法。</li></ol><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.i = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;      <span class="comment">//aa1调用equals方法，所以this.i指代。    aa2作为形参赋给obj，所以obj指向子类对象aa2。</span></span><br><span class="line">A aa = (A)obj;<span class="comment">//  当父类引用本身指向的就是一个子类对象时，才可以把父类引用强制转化为子类引用  （多态）</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.i == aa.i)   <span class="comment">//  if (当前对象的i和obj代表的i相等)</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Equals</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A aa1 = <span class="keyword">new</span> A(<span class="number">2</span>);</span><br><span class="line">A aa2 = <span class="keyword">new</span> A(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println( aa1.equals(aa2));  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;初学的小伙伴或许会对java中的&lt;strong&gt;equals&lt;/strong&gt;和**==**有些混淆，不过请耐心看下面这篇文章，或许能帮您解决疑惑呦。&lt;/p&gt;
&lt;h3 id=&quot;：-运算符&quot;&gt;&lt;a href=&quot;#：-运算符&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JDBC之Apache</title>
    <link href="https://7heng.github.io/2021/04/12/JDBC%E4%B9%8BApache/"/>
    <id>https://7heng.github.io/2021/04/12/JDBC%E4%B9%8BApache/</id>
    <published>2021-04-12T06:30:02.000Z</published>
    <updated>2021-04-18T07:32:42.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Apache-DBUtils实现CRUD操作"><a href="#Apache-DBUtils实现CRUD操作" class="headerlink" title="Apache-DBUtils实现CRUD操作"></a>Apache-DBUtils实现CRUD操作</h2><h4 id="Apache-DBUtils简介："><a href="#Apache-DBUtils简介：" class="headerlink" title="Apache-DBUtils简介："></a>Apache-DBUtils简介：</h4><ul><li>commons-dbutils 是 Apache 组织提供的一个开源的 JDBC 工具类，它是对JDBC的简单封装，学习成本极低，并且使用debutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</li><li>API介绍：<ul><li>org.apache.commons.dbutils.QueryRunner</li><li>org.apache.commons.dbutils.ResultSetHandler</li><li>工具类：org.apache.commons.dbutils.DbUtils   </li></ul></li></ul><h4 id="主要API的使用："><a href="#主要API的使用：" class="headerlink" title="主要API的使用："></a>主要API的使用：</h4><p><strong>DbUtils</strong></p><ul><li>Dbutils：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：<ul><li><strong>public static void close(…) throws java.sql.SQLEeception：</strong>DbUtils类提供了三个重载的方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li><li>public static void commitAndClose(Connection conn)throws SQLException)：用来提交连接的事务，然后关闭连接。</li><li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 </li><li>public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断。</li><li>public static void rollbackAndClose(Connection conn)throws SQLException</li><li>rollbackAndCloseQuietly(Connection)</li><li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li></ul></li></ul><p><strong>QueryRunner类：</strong></p><ul><li>该类简化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</li><li>QueryRunner类提供了两个构造器：<ul><li>默认的构造器。</li><li>需要一个javax.sql.DataSource 来作参数的构造器。</li></ul></li><li>QueryRunner类的主要方法：<ul><li><strong>更新</strong><ul><li>public int upadate(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li><li>……</li></ul></li><li><strong>插入</strong><ul><li>public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值。</li><li>……</li></ul></li><li><strong>批处理</strong><ul><li>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句。</li><li>public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：只支持INSERT语句</li><li>……</li></ul></li><li><strong>查询</strong><ul><li>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</li><li>……</li></ul></li></ul></li></ul><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试添加</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">String sql = <span class="string">&quot;insert into customers(name,email,birth)values(?,?,?)&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> count = runner.update(conn, sql, <span class="string">&quot;柯南&quot;</span>, <span class="string">&quot;Xinyi@qq.com&quot;</span>, <span class="string">&quot;1999-09-09&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;添加了&quot;</span> + count + <span class="string">&quot;条记录&quot;</span>);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">String sql = <span class="string">&quot;delete from customers where id &lt; ?&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> count = runner.update(conn, sql,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;删除了&quot;</span> + count + <span class="string">&quot;条记录&quot;</span>);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ResuleSetHandler接口及实现类："><a href="#ResuleSetHandler接口及实现类：" class="headerlink" title="ResuleSetHandler接口及实现类："></a>ResuleSetHandler接口及实现类：</h4><ul><li>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</li><li>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。</li><li>接口的主要实现类：<ul><li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li><li>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</li><li><strong>BeanHandler：</strong>将结果集中的第一行数据封装到一个对应的JavaBean实例中。</li><li><strong>BeanListHandler：</strong>将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</li><li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li><li>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</li><li><strong>MapHandler：</strong>将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</li><li><strong>MapListHandler：</strong>将结果集中的每一行数据都封装到一个Map里，然后再存放到List。</li><li><strong>ScalarHandler：</strong>查询单个值对象</li></ul></li></ul><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 测试查询:查询一条记录</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanHandler</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">   QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">   Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">   </span><br><span class="line">   String sql = <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   BeanHandler&lt;Customer&gt; handler = <span class="keyword">new</span> BeanHandler&lt;&gt;(Customer.class);</span><br><span class="line">   Customer customer = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">   System.out.println(customer);</span><br><span class="line">   JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 测试查询:查询多条记录构成的集合</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanListHandler</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryList</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">   QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">   Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">   </span><br><span class="line">   String sql = <span class="string">&quot;select id,name,email,birth from customers where id &lt; ?&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   BeanListHandler&lt;Customer&gt; handler = <span class="keyword">new</span> BeanListHandler&lt;&gt;(Customer.class);</span><br><span class="line">   List&lt;Customer&gt; list = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">   list.forEach(System.out::println);</span><br><span class="line">   </span><br><span class="line">   JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 自定义ResultSetHandler的实现类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryInstance1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">   QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">   Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">   </span><br><span class="line">   String sql = <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   ResultSetHandler&lt;Customer&gt; handler = <span class="keyword">new</span> ResultSetHandler&lt;Customer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Customer <span class="title">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;handle&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L));</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">   <span class="keyword">int</span> id = rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">   String name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">   String email = rs.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">   Date birth = rs.getDate(<span class="string">&quot;birth&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Customer(id, name, email, birth);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   Customer customer = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">   </span><br><span class="line">   System.out.println(customer);</span><br><span class="line">   </span><br><span class="line">   JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 使用ScalarHandler</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">   QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">   Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//测试一：</span></span><br><span class="line">   <span class="comment">//String sql = &quot;select count(*) from customers where id &lt; ?&quot;;</span></span><br><span class="line">   <span class="comment">//ScalarHandler handler = new ScalarHandler();</span></span><br><span class="line">   <span class="comment">//long count = (long) runner.query(conn, sql, handler, 20);</span></span><br><span class="line">   <span class="comment">//System.out.println(count);</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//测试二：</span></span><br><span class="line">   String sql = <span class="string">&quot;select max(birth) from customers&quot;</span>;</span><br><span class="line">   ScalarHandler handler = <span class="keyword">new</span> ScalarHandler();</span><br><span class="line">   Date birth = (Date) runner.query(conn, sql, handler);</span><br><span class="line">   System.out.println(birth);</span><br><span class="line">   </span><br><span class="line">   JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Apache-DBUtils实现CRUD操作&quot;&gt;&lt;a href=&quot;#Apache-DBUtils实现CRUD操作&quot; class=&quot;headerlink&quot; title=&quot;Apache-DBUtils实现CRUD操作&quot;&gt;&lt;/a&gt;Apache-DBUtils实现CRUD</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JDBC数据库连接池</title>
    <link href="https://7heng.github.io/2021/04/11/JDBC%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>https://7heng.github.io/2021/04/11/JDBC%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</id>
    <published>2021-04-11T11:33:13.000Z</published>
    <updated>2021-04-18T07:32:08.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><h3 id="1：JDBC数据库连接池的必要性"><a href="#1：JDBC数据库连接池的必要性" class="headerlink" title="1：JDBC数据库连接池的必要性"></a>1：JDBC数据库连接池的必要性</h3><ul><li>在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：<ul><li><strong>在主程序（如servlet、beans）中建立数据库连接。</strong></li><li><strong>进行sql操作。</strong></li><li><strong>断开数据库连接。</strong></li></ul></li><li>这种模式开发，存在的问题：<ul><li>普通的 JDBC 数据库连接使用DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码 (花费0.05s ~ 1s的时间)。需要数据库连接的候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用。</strong>若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li><li><strong>对于每一次的数据库连接，使用完后都要断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄露，最终将导致重启数据库。</li><li>这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。</li></ul></li></ul><h3 id="2：数据库连接池技术"><a href="#2：数据库连接池技术" class="headerlink" title="2：数据库连接池技术"></a>2：数据库连接池技术</h3><ul><li>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</li><li><strong>数据库连接池的基本思想：</strong>就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从”缓冲池”中取出一个，使用完毕之后再放回去。</li><li><strong>数据库连接池</strong>负责分配、管理和释放数据库连接，它<strong>允许应用重复使用一个现有的数据库连接，而不是重新建立一个。</strong></li><li>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<strong>最小数据库连接数来设定</strong>的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接超过最大连接数量时，这些请求将被加入到等待队列中。</li></ul><p><img src="/images/JDBC_1/Pool_1.png"></p><ul><li><strong>工作原理：</strong></li></ul><p><img src="/images/JDBC_1/Pool_1.png"></p><ul><li><strong>数据库连接池技术的优点</strong></li></ul><p><strong>1：资源重用：</strong></p><p>由于数据库连接得以重用，避免了频繁创建，释放接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p><p><strong>2：更快的系统反应速度：</strong></p><p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间。</p><p><strong>3：新的资源分配手段：</strong></p><p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源。</p><p><strong>4：统一的连接管理，避免数据库连接泄漏：</strong></p><p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露。</p><h3 id="3：多种开源的数据库连接池"><a href="#3：多种开源的数据库连接池" class="headerlink" title="3：多种开源的数据库连接池"></a>3：多种开源的数据库连接池</h3><ul><li>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：<ul><li><strong>DBCP</strong> 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。<strong>速度相对c3p0较快</strong>，但因自身存在BUG，Hibernate3已不再提供支持。</li><li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，<strong>速度相对较慢，稳定性还可以。</strong>hibernate官方推荐使用</li><li><strong>Proxool</strong> 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，<strong>稳定性较c3p0差一点</strong></li><li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快</li><li><strong>Druid</strong> 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快</li></ul></li><li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池。</li><li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></li><li>特别注意：<ul><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此<strong>整个应用只需要一个数据源即可。</strong></li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li></ul></li></ul><p><strong>Demo：</strong></p><h4 id="一：C3p0数据库连接池"><a href="#一：C3p0数据库连接池" class="headerlink" title="一：C3p0数据库连接池"></a>一：C3p0数据库连接池</h4><ul><li>获取连接方式一：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">ComboPooledDataSource cpds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">cpds.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>); </span><br><span class="line">cpds.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">cpds.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">cpds.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cpds.setMaxPoolSize(100);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Connection conn = cpds.getConnection();</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取连接方式二：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource cpds = <span class="keyword">new</span> ComboPooledDataSource(<span class="string">&quot;helloc3p0&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">Connection conn = cpds.getConnection();</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【c3p0-config.xml】</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;c3p0-config&gt;</span><br><span class="line">&lt;named-config name=<span class="string">&quot;helloc3p0&quot;</span>&gt;</span><br><span class="line">&lt;!-- 获取连接的<span class="number">4</span>个基本信息 --&gt;</span><br><span class="line">&lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;password&quot;&gt;abc123&lt;/property&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;jdbcUrl&quot;</span>&gt;jdbc:mysql:<span class="comment">///test&lt;/property&gt;</span></span><br><span class="line">&lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;</span><br><span class="line">&lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;</span><br><span class="line">&lt;property name=&quot;acquireIncrement&quot;&gt;5&lt;/property&gt;</span><br><span class="line">&lt;!-- 初始化数据库连接池时连接的数量 --&gt;</span><br><span class="line">&lt;property name=&quot;initialPoolSize&quot;&gt;5&lt;/property&gt;</span><br><span class="line">&lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;</span><br><span class="line">&lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt;</span><br><span class="line">&lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;</span><br><span class="line">&lt;property name=&quot;maxPoolSize&quot;&gt;10&lt;/property&gt;</span><br><span class="line">&lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;</span><br><span class="line">&lt;property name=&quot;maxStatements&quot;&gt;20&lt;/property&gt;</span><br><span class="line">&lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;</span><br><span class="line">&lt;property name=&quot;maxStatementsPerConnection&quot;&gt;5&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;/named-config&gt;</span><br><span class="line"></span><br><span class="line">&lt;/c3p0-config&gt;</span><br></pre></td></tr></table></figure><h4 id="二：DBCP数据库连接池"><a href="#二：DBCP数据库连接池" class="headerlink" title="二：DBCP数据库连接池"></a>二：DBCP数据库连接池</h4><ul><li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<ul><li>Commons-dbcp.jar：连接池的实现</li><li>Commons-pool.jar：连接池实现的依赖库</li></ul></li><li><strong>Tomcat 的连接池正是采用该连接池来实现的。</strong>该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li><li>配置属性说明</li></ul><table><thead><tr><th>属性</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>initialSize</td><td>0</td><td>连接池启动时创建的初始化连接数量</td></tr><tr><td>maxActive</td><td>8</td><td>连接池中可同时连接的最大的连接数</td></tr><tr><td>maxIdle</td><td>8</td><td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td></tr><tr><td>minIdle</td><td>0</td><td>连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td></tr><tr><td>maxWait</td><td>无限制</td><td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>开启池的Statement是否prepared</td></tr><tr><td>maxOpenPreparedStatements</td><td>无限制</td><td>开启池的prepared 后的同时最大连接数</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td></tr><tr><td>removeAbandonedTimeout</td><td>300</td><td>超过时间限制，回收没有用(废弃)的连接</td></tr><tr><td>removeAbandoned</td><td>false</td><td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td></tr></tbody></table><ul><li>获取连接方式一：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">BasicDataSource source = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">source.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">source.setUrl(<span class="string">&quot;jdbc:mysql:///test&quot;</span>);</span><br><span class="line">source.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">source.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">source.setInitialSize(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">Connection conn = source.getConnection();</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取连接方式二：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource source = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;dbcp.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">pros.load(is);</span><br><span class="line"><span class="comment">//根据提供的BasicDataSourceFactory创建对应的DataSource对象</span></span><br><span class="line">source = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Connection conn = source.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【dbcp.properties】</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=false</span></span><br><span class="line">username=root</span><br><span class="line">password=abc123</span><br><span class="line"></span><br><span class="line">initialSize=<span class="number">10</span></span><br><span class="line">#...</span><br></pre></td></tr></table></figure><h4 id="三：Druid（德鲁伊）数据库连接池"><a href="#三：Druid（德鲁伊）数据库连接池" class="headerlink" title="三：Druid（德鲁伊）数据库连接池"></a>三：Druid（德鲁伊）数据库连接池</h4><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，<strong>可以说是目前最好的连接池之一。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.druid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDruid</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Properties pro = <span class="keyword">new</span> Properties(); pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line">DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">Connection conn = ds.getConnection();</span><br><span class="line">System.out.println(conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【druid.properties】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test?rewriteBatchedStatements=true</span></span><br><span class="line">username=root</span><br><span class="line">password=<span class="number">123456</span></span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">initialSize=<span class="number">10</span></span><br><span class="line">maxActive=<span class="number">20</span></span><br><span class="line">maxWait=<span class="number">1000</span></span><br><span class="line">filters=wall</span><br></pre></td></tr></table></figure><ul><li>详细配置参数：</li></ul><table><thead><tr><th><strong>配置</strong></th><th><strong>缺省</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>name</td><td></td><td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)</td></tr><tr><td>url</td><td></td><td>连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td></tr><tr><td>username</td><td></td><td>连接数据库的用户名</td></tr><tr><td>password</td><td></td><td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></td></tr><tr><td>driverClassName</td><td></td><td>根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td></tr><tr><td>initialSize</td><td>0</td><td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td></tr><tr><td>maxActive</td><td>8</td><td>最大连接池数量</td></tr><tr><td>maxIdle</td><td>8</td><td>已经不再使用，配置了也没效果</td></tr><tr><td>minIdle</td><td></td><td>最小连接池数量</td></tr><tr><td>maxWait</td><td></td><td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td></tr><tr><td>maxOpenPreparedStatements</td><td>-1</td><td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td></tr><tr><td>validationQuery</td><td></td><td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td></tr><tr><td>testOnBorrow</td><td>true</td><td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td></tr><tr><td>testOnReturn</td><td>false</td><td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td></tr><tr><td>testWhileIdle</td><td>false</td><td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td></tr><tr><td>timeBetweenEvictionRunsMillis</td><td></td><td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td></tr><tr><td>numTestsPerEvictionRun</td><td></td><td>不再使用，一个DruidDataSource只支持一个EvictionRun</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td></td></tr><tr><td>connectionInitSqls</td><td></td><td>物理连接初始化的时候执行的sql</td></tr><tr><td>exceptionSorter</td><td></td><td>根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接</td></tr><tr><td>filters</td><td></td><td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td></tr><tr><td>proxyFilters</td><td></td><td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库连接池&quot;&gt;&lt;a href=&quot;#数据库连接池&quot; class=&quot;headerlink&quot; title=&quot;数据库连接池&quot;&gt;&lt;/a&gt;数据库连接池&lt;/h2&gt;&lt;h3 id=&quot;1：JDBC数据库连接池的必要性&quot;&gt;&lt;a href=&quot;#1：JDBC数据库连接池的必要性&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JDBC之DAO</title>
    <link href="https://7heng.github.io/2021/04/11/JDBC%E4%B9%8BDAO/"/>
    <id>https://7heng.github.io/2021/04/11/JDBC%E4%B9%8BDAO/</id>
    <published>2021-04-11T08:34:46.000Z</published>
    <updated>2021-04-18T07:33:35.229Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>DAO：</strong>Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO。</li><li><strong>作用：</strong>为了实现功能的模块化，更有利于代码的维护和升级。</li></ul><p><strong>思路：</strong></p><ul><li>首先创建一个实现共同操作类的DAO，我们称为BaseDAO。</li><li>创建每个表的接口，定义每个表独特的方法。</li><li>创建每个表的实现类，实现每个表的接口并继承BaseDAO，去重写接口中的方法，调用BaseDAO中的共同方法去完成。</li></ul><p><strong>Demo：</strong></p><p><strong>【BaseDAO】：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.ScalarHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 定义一个用来被继承的对数据库进行基本操作的Dao</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HanYanBing</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">   <span class="comment">// 定义一个变量来接收泛型的类型</span></span><br><span class="line">   <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BaseDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取子类的类型</span></span><br><span class="line">   Class clazz = <span class="keyword">this</span>.getClass();</span><br><span class="line">   <span class="comment">// 获取父类的类型</span></span><br><span class="line">   <span class="comment">// getGenericSuperclass()用来获取当前类的父类的类型</span></span><br><span class="line">   <span class="comment">// ParameterizedType表示的是带泛型的类型</span></span><br><span class="line">   ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass();</span><br><span class="line">   <span class="comment">// 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型</span></span><br><span class="line">   <span class="comment">// 这个方法会返回一个Type的数组</span></span><br><span class="line">   Type[] types = parameterizedType.getActualTypeArguments();</span><br><span class="line">   <span class="comment">// 获取具体的泛型的类型·</span></span><br><span class="line">   <span class="keyword">this</span>.type = (Class&lt;T&gt;) types[<span class="number">0</span>];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 通用的增删改操作</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      count = queryRunner.update(conn, sql, params);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 获取一个对象</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> T <span class="title">getBean</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">      T t = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      t = queryRunner.query(conn, sql, <span class="keyword">new</span> BeanHandler&lt;T&gt;(type), params);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">return</span> t;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 获取所有对象</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getBeanList</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">      List&lt;T&gt; list = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      list = queryRunner.query(conn, sql, <span class="keyword">new</span> BeanListHandler&lt;T&gt;(type), params);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">      Object count = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 调用queryRunner的query方法获取一个单一的值</span></span><br><span class="line">      count = queryRunner.query(conn, sql, <span class="keyword">new</span> ScalarHandler&lt;&gt;(), params);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>【BookDAO】：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库中查询出所有的记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向数据库中插入一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库中根据图书的id删除一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据图书的id从数据库中查询出一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据图书的id从数据库中更新一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取带分页的图书信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取带分页和价格范围的图书信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>【UserDAO】:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据User对象中的用户名和密码从数据库中获取一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> User 数据库中有记录 null 数据库中无此记录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据User对象中的用户名从数据库中获取一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 数据库中有记录 false 数据库中无此记录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向数据库中插入User对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>【BookDaoImpl.java】：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BookDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">Book</span>&gt; <span class="keyword">implements</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用BaseDao中得到一个List的方法</span></span><br><span class="line">List&lt;Book&gt; beanList = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;</span>;</span><br><span class="line">beanList = getBeanList(conn,sql);</span><br><span class="line"><span class="keyword">return</span> beanList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">&quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">&quot;DELETE FROM books WHERE id = ?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中通用增删改的方法</span></span><br><span class="line">update(conn,sql, bookId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">Book book = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;</span>;</span><br><span class="line">book = getBean(conn,sql, bookId);</span><br><span class="line"><span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">&quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line">String sql = <span class="string">&quot;select count(*) from books&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line"><span class="keyword">long</span> totalRecord = (<span class="keyword">long</span>) getValue(conn,sql);</span><br><span class="line"><span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">page.setTotalRecord((<span class="keyword">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line">String sql2 = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line"><span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">page.setList(beanList);</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line">String sql = <span class="string">&quot;select count(*) from books where price between ? and ?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line"><span class="keyword">long</span> totalRecord = (<span class="keyword">long</span>) getValue(conn,sql,minPrice,maxPrice);</span><br><span class="line"><span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">page.setTotalRecord((<span class="keyword">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line">String sql2 = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line"><span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">page.setList(beanList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>【UserDaoImpl.java】：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.User;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">User bean = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">&quot;select id,username,password,email from users where username = ? and password = ?&quot;</span>;</span><br><span class="line">bean = getBean(conn,sql, user.getUsername(), user.getPassword());</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">User bean = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">&quot;select id,username,password,email from users where username = ?&quot;</span>;</span><br><span class="line">bean = getBean(conn,sql, user.getUsername());</span><br><span class="line"><span class="keyword">return</span> bean != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line"><span class="comment">//写sql语句</span></span><br><span class="line">String sql = <span class="string">&quot;insert into users(username,password,email) values(?,?,?)&quot;</span>;</span><br><span class="line"><span class="comment">//调用BaseDao中通用的增删改的方法</span></span><br><span class="line">update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>【Book.java】:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图书类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Integer id;</span><br><span class="line">   <span class="keyword">private</span> String title; <span class="comment">// 书名</span></span><br><span class="line">   <span class="keyword">private</span> String author; <span class="comment">// 作者</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">double</span> price; <span class="comment">// 价格</span></span><br><span class="line">   <span class="keyword">private</span> Integer sales; <span class="comment">// 销量</span></span><br><span class="line">   <span class="keyword">private</span> Integer stock; <span class="comment">// 库存</span></span><br><span class="line">   <span class="keyword">private</span> String imgPath = <span class="string">&quot;static/img/default.jpg&quot;</span>; <span class="comment">// 封面图片的路径</span></span><br><span class="line">   <span class="comment">//构造器，get()，set()，toString()方法略</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>【Page.java】：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 页码类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> List&lt;T&gt; list; <span class="comment">// 每页查到的记录存放的集合</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_SIZE = <span class="number">4</span>; <span class="comment">// 每页显示的记录数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> pageNo; <span class="comment">// 当前页</span></span><br><span class="line">   <span class="comment">//private int totalPageNo; // 总页数，通过计算得到</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> totalRecord; <span class="comment">// 总记录数，通过查询数据库得到</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>【User.java】：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Integer id;</span><br><span class="line">   <span class="keyword">private</span> String username;</span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line">   <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DAO：&lt;/strong&gt;Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO。&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java枚举与注解</title>
    <link href="https://7heng.github.io/2021/04/10/java%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%B3%A8%E8%A7%A3/"/>
    <id>https://7heng.github.io/2021/04/10/java%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-04-10T08:26:31.000Z</published>
    <updated>2021-04-18T07:21:38.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="枚举："><a href="#枚举：" class="headerlink" title="枚举："></a>枚举：</h1><h3 id="一：枚举类的作用："><a href="#一：枚举类的作用：" class="headerlink" title="一：枚举类的作用："></a>一：枚举类的作用：</h3><ol><li>枚举类的理解：类的对象只有有限个，确定的，我们称之为枚举类。</li><li>当需要定义一组常量时，强烈建议使用枚举类。</li><li>如果枚举类中只有一个对象，则可以作为单例模式的实现方式。</li></ol><h3 id="二：定义枚举类："><a href="#二：定义枚举类：" class="headerlink" title="二：定义枚举类："></a>二：定义枚举类：</h3><ol><li>JDK5.0之前，自定义枚举类;</li><li>JDK5.0,增加了可以使用<strong>enum</strong>关键字定义枚举类;</li></ol><p><strong>枚举类的属性：</strong></p><ul><li>枚举类对象的属性不应允许被改动，所以应该使用Private final修饰。</li><li>枚举类的使用 private final 修饰的属性应该在构造器中为其赋值。</li><li>若枚举类显式的定义了带参数的构造器，则在列出枚举值时也必须对应的传入参数。</li></ul><p><strong>自定义枚举类：</strong></p><ol><li>私有化类的构造器，保证不能在类的外部创建其对象。</li><li>在类的内部创建枚举类的实例。声明为：<code>public static final</code></li><li>对象如果有实例变量，应该声明为private final,并在构造器中初始化。</li></ol><p><strong>使用enum定义枚举类：</strong></p><ol><li>使用enum定义的枚举类默认继承了java.lang.Enum类，因此不能再继承其它的类。</li><li>枚举类的构造器<strong>只能使用private</strong>权限修饰符。</li><li>枚举类的所有实例必须在枚举类中显示列出(, 分隔  ; 结尾)。列出的实例系统会<strong>自动添加public static final修饰</strong>。</li><li>必须在枚举类的第一行声明枚举类对象。</li></ol><p><em>Jdk1.5中可以在switch表达式中使用Enum定义的枚举类的对象作为表达式，case子句可以直接使用枚举值的名字，无需添加枚举类作为限定。</em></p><h3 id="三：Enum类中的常用方法："><a href="#三：Enum类中的常用方法：" class="headerlink" title="三：Enum类中的常用方法："></a>三：Enum类中的常用方法：</h3><ul><li>value()；返回枚举类型的对象数组。该方法可以很方便的遍历所有的枚举值。</li><li>valueOf(String str)；可以把一个字符串转换为对应的枚举类对象。要求字符串必须是枚举类对象的”名字”。如果不是，会有运行时异常：IllegalArgumentException。</li><li>toString()；返回当前枚举类对象常量的名称。</li></ul><p><img src="/images/Enum/enum_1.png"></p><h3 id="四：使用enum关键字定义的枚举类实现接口的情况："><a href="#四：使用enum关键字定义的枚举类实现接口的情况：" class="headerlink" title="四：使用enum关键字定义的枚举类实现接口的情况："></a>四：使用enum关键字定义的枚举类实现接口的情况：</h3><ul><li>实现接口，在enum类中实现抽象方法。</li><li>让枚举类的对象分别实现接口中的抽象方法。</li></ul><h4 id="Demo："><a href="#Demo：" class="headerlink" title="Demo："></a>Demo：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义枚举类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeasonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season spring = Season.SPRING;</span><br><span class="line">        System.out.println(spring);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有化类的构造器,并给对象属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName,String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.其他诉求1：提供toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用enum关键字定义枚举类并实现接口，再达到枚举类的对象分别实现接口中的抽象方法的eg。</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season1</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;宁夏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秋天不回来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大约在冬季&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.私有化类的构造器,并给对象属性赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season1</span><span class="params">(String seasonName,String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    //4.其他诉求1：提供toString()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public String toString() &#123;</span></span><br><span class="line"><span class="comment">//        return &quot;Season1&#123;&quot; +</span></span><br><span class="line"><span class="comment">//                &quot;seasonName=&#x27;&quot; + seasonName + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="comment">//                &quot;, seasonDesc=&#x27;&quot; + seasonDesc + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="comment">//                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void show() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;这是一个季节&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h1><h3 id="一：注解的使用："><a href="#一：注解的使用：" class="headerlink" title="一：注解的使用："></a>一：注解的使用：</h3><ul><li><p>JDK5.0新增的功能。</p></li><li><p>Annotation 其实就是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取。并执行相应的处理，通过使用Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。</p></li><li><p>在javaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在javaEE/Android中注占据了更重要的角色，例如用来配置应用程序的任何切面，代替javaEE旧版中所遗留的繁冗代码和XML配置等。</p></li></ul><h3 id="二：Annotation的使用示例："><a href="#二：Annotation的使用示例：" class="headerlink" title="二：Annotation的使用示例："></a>二：Annotation的使用示例：</h3><p>①：生成文档相关的注解。</p><p>②：在编译时进行格式检查（JDK内置的三个基本注释）</p><ul><li>@Override：限定重写父类的方法，该注解只能用于方法。</li><li>@Deprecated：用于表示所修饰的元素(类、方法等)已过时，通常是因为所修饰的结构危险或存在更好的选择。</li><li>@SuppressWarnings：抑制编译器警告等。</li></ul><p>③：跟踪代码依赖性，实现替代配置文件功能。</p><h4 id="常见的Annotation示例："><a href="#常见的Annotation示例：" class="headerlink" title="常见的Annotation示例："></a>常见的Annotation示例：</h4><ul><li><p>使用 Annotation 时要在其前面增加 @ 符号, 并<strong>把该</strong> <strong>Annotation</strong> <strong>当成</strong></p><p><strong>一个修饰符使用。</strong>用于修饰它支持的程序元素。</p></li><li><p><strong>示例一：生成文档相关的注解</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@author 标明开发该类模块的作者，多个作者之间使用,分割</span><br><span class="line"></span><br><span class="line">@version 标明该类模块的版本</span><br><span class="line"></span><br><span class="line">@see 参考转向，也就是相关主题</span><br><span class="line"></span><br><span class="line">@since 从哪个版本开始增加的</span><br><span class="line"></span><br><span class="line">@param 对方法中某参数的说明，如果没有参数就不能写</span><br><span class="line"></span><br><span class="line">@return 对方法返回值的说明，如果方法的返回值类型是void就不能写</span><br><span class="line"></span><br><span class="line">@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写</span><br><span class="line"></span><br><span class="line">其中</span><br><span class="line"></span><br><span class="line">@param @return 和 @exception 这三个标记都是只用于方法的。</span><br><span class="line"></span><br><span class="line">@param的格式要求：@param 形参名 形参类型 形参说明</span><br><span class="line"></span><br><span class="line">@return 的格式要求：@return 返回值类型 返回值说明</span><br><span class="line"></span><br><span class="line">@exception的格式要求：@exception 异常类型 异常说明</span><br><span class="line"></span><br><span class="line">@param和@exception可以并列多个</span><br></pre></td></tr></table></figure></li></ul><h3 id="三：如何自定义注解："><a href="#三：如何自定义注解：" class="headerlink" title="三：如何自定义注解："></a>三：如何自定义注解：</h3><ul><li><p>定义新的 Annotation 类型使用 <strong>@interface</strong> 关键字</p></li><li><p>自定义注解自动继承了<strong>java.lang.annotation.Annotation</strong> <strong>接口</strong></p></li><li><p>Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其</p><p>方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能</p><p>是八种基本数据类型、<strong>String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组</strong>。 </p></li><li><p>可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始</p><p>值可使用 <strong>default 关键字</strong></p></li><li><p>如果只有一个参数成员，建议使用<strong>参数名为value</strong></p></li><li><p>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认</p><p>值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value，</p><p>可以省略“value=” </p></li><li><p>没有成员定义的 Annotation 称为<strong>标记</strong>; 包含成员变量的 Annotation 称为元数</p><p>据 Annotation</p></li></ul><p><strong>注意：</strong>自定义注解必须配上注解的信息处理流程才有意义。</p><h3 id="四：JDK提供的四种元注解："><a href="#四：JDK提供的四种元注解：" class="headerlink" title="四：JDK提供的四种元注解："></a>四：JDK提供的四种元注解：</h3><p>元注解：对现有的注解进行解释说明的注解。</p><ul><li><p>Retention：指定所修饰的 Annotation 的生命周期：SOURCE\CLASS（默认行为）\RUNTIME 只有声明为RUNTIME生命周期的注解，才能通过反射获取。</p></li><li><p>Target:用于指定被修饰的 Annotation 能用于修饰哪些程序元素</p><p>———-出现的频率较低———-</p></li><li><p> Documented:表示所修饰的注解在被javadoc解析时，保留下来。</p></li><li><p>Inherited:被它修饰的 Annotation 将具有继承性。</p></li></ul><h3 id="五：JDK8中注解的新特性："><a href="#五：JDK8中注解的新特性：" class="headerlink" title="五：JDK8中注解的新特性："></a>五：JDK8中注解的新特性：</h3><ul><li>可重复注解：<ul><li>① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class</li><li>② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。</li></ul></li><li>类型注解：<ul><li>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）</li><li>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</li></ul></li></ul><h4 id="Demo：-1"><a href="#Demo：-1" class="headerlink" title="Demo："></a>Demo：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student();</span><br><span class="line">        p.walk();</span><br><span class="line">    </span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(num);</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123; &quot;unused&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetAnnotation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class clazz = Student.class;</span><br><span class="line">        Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; annotations.length;i++)&#123;</span><br><span class="line">            System.out.println(annotations[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk 8之前的写法：</span></span><br><span class="line"><span class="comment">//@MyAnnotations(&#123;@MyAnnotation(value=&quot;hi&quot;),@MyAnnotation(value=&quot;hi&quot;)&#125;)</span></span><br><span class="line"><span class="meta">@MyAnnotation(value=&quot;hi&quot;)</span></span><br><span class="line"><span class="meta">@MyAnnotation(value=&quot;abc&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人走路&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生走路&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;@<span class="title">MyAnnotation</span> <span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">throws</span> @MyAnnotation RuntimeException</span>&#123;</span><br><span class="line">    </span><br><span class="line">        ArrayList&lt;<span class="meta">@MyAnnotation</span> String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> num = (<span class="meta">@MyAnnotation</span> <span class="keyword">int</span>) <span class="number">10L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可重复注解eg：</span></span><br><span class="line"><span class="comment">// 自定义注解：MyAnnotation</span></span><br><span class="line"><span class="comment">// @Repeatable(MyAnnotations.class) 与MyAnnotations搭配实现可重复注解。</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Inherited</span></span><br><span class="line">   <span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line">   <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">   <span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">   <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment">// 自定义注解：MyAnnotations</span></span><br><span class="line"><span class="comment">// 实现可重复注解，需要与MyAnnotation的元注解相同。</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inherited</span></span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">    <span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations &#123;</span><br><span class="line"></span><br><span class="line">    MyAnnotation[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;枚举：&quot;&gt;&lt;a href=&quot;#枚举：&quot; class=&quot;headerlink&quot; title=&quot;枚举：&quot;&gt;&lt;/a&gt;枚举：&lt;/h1&gt;&lt;h3 id=&quot;一：枚举类的作用：&quot;&gt;&lt;a href=&quot;#一：枚举类的作用：&quot; class=&quot;headerlink&quot; title=&quot;一：枚</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法之查找</title>
    <link href="https://7heng.github.io/2021/04/09/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%9F%A5%E6%89%BE/"/>
    <id>https://7heng.github.io/2021/04/09/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%9F%A5%E6%89%BE/</id>
    <published>2021-04-09T12:04:56.000Z</published>
    <updated>2021-04-18T07:17:25.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性表的查找："><a href="#线性表的查找：" class="headerlink" title="线性表的查找："></a>线性表的查找：</h2><h3 id="一：顺序查找-线性查找-："><a href="#一：顺序查找-线性查找-：" class="headerlink" title="一：顺序查找(线性查找)："></a>一：顺序查找(线性查找)：</h3><p><strong>理解：</strong>顺序查找一个数据，找到该元素就返回其在数组中的下标，没找到则返回空。</p><p><strong>优点：</strong>算法简单，逻辑次序无要求，且不同存储结构均适用。</p><p><strong>缺点：</strong>ASL(平均查找长度)太长，时间效率低。</p><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSequentialSearch</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>,<span class="number">78</span>,<span class="number">34</span>,<span class="number">12</span>,<span class="number">64</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">62</span>,&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;请输入要查询的数字：&quot;</span>);</span><br><span class="line"> Scanner input=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"> <span class="keyword">int</span> input1=input.nextInt();</span><br><span class="line"> SequentialSearch(a,input1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SequentialSearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> input)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(arr[i]==input)&#123;</span><br><span class="line"> System.out.println(input+<span class="string">&quot;的位置为：&quot;</span>+i);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(i==arr.length-<span class="number">1</span>)</span><br><span class="line"> System.out.println(<span class="string">&quot;No Result!&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>O(n)</p><p><strong>空间复杂度：</strong>O(1)</p><p><strong>小Tips：</strong>可以添设”哨兵“，来加快速度。</p><h3 id="二：折半查找-二分或对分查找-："><a href="#二：折半查找-二分或对分查找-：" class="headerlink" title="二：折半查找(二分或对分查找)："></a>二：折半查找(二分或对分查找)：</h3><p><strong>理解：</strong>得到首元素的索引head，并求出数组长度length-1得到尾元素的索引end。利用首尾元素求出中间元素middle， [ (head + end) / 2 ] ,利用middle值与target值进行比较，如果相同，则返回。如果不同,middle&gt;target，则进行尾元素索引的更改,变为end=middle-1；如果middle&lt;target，则进行首元素索引的更改,变为head=middle+1；</p><p><strong>优点：</strong>效率比顺序查找高。</p><p><strong>缺点：</strong>只适用于有序表，且限于顺序存储结构(对线性表无效)。</p><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SearchUtils su = <span class="keyword">new</span> SearchUtils();</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">45</span>,<span class="number">67</span>,<span class="number">78</span>,<span class="number">98</span>,<span class="number">100</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = su.binarySearch(arr, <span class="number">44</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;res=&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> middle;</span><br><span class="line">        <span class="keyword">while</span> (head &lt;= end) &#123;</span><br><span class="line">            middle = (head + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//如果要查找的元素target小于中间位置的元素middle，指向数组的较大端的end索引重新指向中间索引middle的左边（middle-1）</span></span><br><span class="line">            <span class="keyword">if</span> (target &lt; arr[middle]) &#123;</span><br><span class="line">                end = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果要查找的元素target大于中间位置的元素middle，指向数组的较小端的head索引重新指向中间索引middle的右边（middle+1）</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt; arr[middle]) &#123;</span><br><span class="line">                head = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[middle] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(lg2^n)</p><h3 id="三：分块查找-索引顺序表的查找-："><a href="#三：分块查找-索引顺序表的查找-：" class="headerlink" title="三：分块查找(索引顺序表的查找)："></a>三：分块查找(索引顺序表的查找)：</h3><p><strong>理解：</strong>先将所有元素按大小进行分块，然后在块内进行查找。在分块时，块内的元素不一定是有序的，只要一个块内的元素在同一区间就行。用标准的语言描述是：算法的思想是将n个数据元素”按块有序”划分为m块,(m ≤ n)。每块中的关键字（元素）不一定有序，但前一块中的最大关键字必须小于后一块的最小关键字，即要求表示“分块有序”的。</p><p><strong>思想：</strong>首先查找索引表，因为索引表为有序表，所以可以利用顺序或折半查找，再在块内进行查找，因为块内可以无序，所以利用顺序查找，在块内查找到则显示查询成功，否则查找失败。</p><p><strong>e.g：索引表：</strong></p><table><thead><tr><th align="center">14</th><th align="center">34</th><th align="center">66</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">5</td><td align="center">10</td></tr></tbody></table><p><strong>元素表：</strong></p><table><thead><tr><th align="center">索引</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th><th align="center">10</th><th align="center">11</th><th align="center">12</th><th align="center">13</th><th align="center">14</th></tr></thead><tbody><tr><td align="center">值</td><td align="center">8</td><td align="center">14</td><td align="center">6</td><td align="center">9</td><td align="center">10</td><td align="center">22</td><td align="center">34</td><td align="center">18</td><td align="center">19</td><td align="center">31</td><td align="center">40</td><td align="center">38</td><td align="center">54</td><td align="center">66</td><td align="center">46</td></tr></tbody></table><p><strong>查找过程：</strong>先确定待查记录所在块(顺序或折半查找),再在块内查找(顺序查找)。</p><p><strong>查找效率：</strong>ASL=Lb（对索引表查找的ASL）+Lw（对块内查找的ASL）</p><p><strong>优点：</strong>插入删除比较容易，无需进行大量移动。</p><p><strong>缺点：</strong>要增加一个索引表的存储空间并对初始化索引表并对初始索引表进行排序运算。</p><p><strong>适用情况：</strong>如果线性表既要快速查找又经常动态变化，则可采用分块查找。</p><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SSTable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchIndex</span><span class="params">(IndexTable it, <span class="keyword">int</span> m, SSTable st, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = m -<span class="number">1</span>, mid, i;</span><br><span class="line">        <span class="keyword">int</span> b = n/m;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid=(low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (it.elem[mid].key &gt;= k) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (low &lt; m) &#123;</span><br><span class="line">            i = it.elem[low].start;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= it.elem[low].start + b -<span class="number">1</span> &amp;&amp; st.data[i] != k) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= it.elem[low].start + b -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">createSSTable</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.data[i] = a[i];</span><br><span class="line">            <span class="keyword">this</span>.length++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 索引表结点 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexItem</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">int</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 索引表 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexTable</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span>  IndexItem[] elem;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndexTable</span><span class="params">(<span class="keyword">int</span>[][] b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.elem = <span class="keyword">new</span> IndexItem[b.length];</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; b.length; i++)&#123;</span><br><span class="line">                elem[i] = <span class="keyword">new</span> IndexItem();</span><br><span class="line">                elem[i].key = b[i][<span class="number">0</span>];</span><br><span class="line">                elem[i].start = b[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">this</span>.length++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">8</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">31</span>, <span class="number">40</span>, <span class="number">38</span>, <span class="number">54</span>, <span class="number">66</span>, <span class="number">46</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] b = &#123;&#123;<span class="number">14</span>, <span class="number">0</span>&#125;,&#123;<span class="number">34</span>, <span class="number">5</span>&#125;,&#123;<span class="number">66</span>, <span class="number">10</span>&#125;&#125;;</span><br><span class="line">        SSTable st = <span class="keyword">new</span> SSTable();</span><br><span class="line">        IndexTable it = st.<span class="function">new <span class="title">IndexTable</span><span class="params">()</span></span>;</span><br><span class="line">        st.createSSTable(a);</span><br><span class="line">        it.createIndexTable(b);</span><br><span class="line">        <span class="keyword">int</span> x = st.searchIndex(it, b.length, st, a.length, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;要查找的元素不存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;查找成功，该元素在表中的位置为：&quot;</span> + (x + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数表的查找："><a href="#数表的查找：" class="headerlink" title="数表的查找："></a>数表的查找：</h2><ul><li>当表插入、删除等操作频繁时，为维护表的有序性，需要移动表中很多记录。</li></ul><p>改用动态查找表—几种特殊的树</p><ul><li><p>表结构在<strong>查找过程中动态生成</strong>。</p></li><li><p>对于给定值key，若表中存在，则成功返回；否则，插入关键字等于key的记录。</p></li></ul><h4 id="1：二叉排序树："><a href="#1：二叉排序树：" class="headerlink" title="1：二叉排序树："></a>1：二叉排序树：</h4><ul><li>又称二叉搜索树，二叉查找树。</li></ul><p><strong>定义：</strong></p><p>二叉排序树或是空树，或是满足如下性质的二叉树：</p><ol><li>若其<strong>左子树非空</strong>，则左子树上所有结点的值均<strong>小于根结点</strong>的值;</li><li>若其<strong>右子树非空</strong>，则右子树上所有节点的值均<strong>大于根节点</strong>的值;</li><li>其<strong>左右子树本身又各是一颗二叉排序树</strong>;</li></ol><p><strong>中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的递增有序序列</strong>。</p><h5 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h5><ul><li>若查找的关键字等于根节点，成功。</li><li>否则<ul><li>若小于根节点，查其左子树。</li><li>若大于根结点，查其右子树。</li></ul></li><li>在左右子数上的操作类似。</li></ul><p><strong>进阶思想：二叉排序树的递归查找</strong></p><ol><li>若二叉排序树为空，则查找失败，返回空指针。</li><li>若二叉树排序树非空，则给定值key与根节点的关键字。</li></ol><ul><li>若key等于根结点，则查找成功，返回根节点地址。</li><li>若key小于根结点，则进一步查找左子树。</li><li>若key大于根节点，则进一步查找右子树。</li></ul><p><strong>二叉树排序树的查找分析：</strong></p><p>二叉排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径。</p><ul><li><strong>比较的关键字次数=此节点所在层次数</strong> </li><li><strong>最多的比较次数=树的深度</strong></li><li>含有n个结点的二叉排序树的<strong>平均查找长度</strong>和树的<strong>形态</strong>有关。</li><li>尽量让二叉树的形态均衡，提高二叉排序树的查找效率。</li></ul><p><img src="/images/Tree/tree_1.png"></p><h5 id="插入："><a href="#插入：" class="headerlink" title="插入："></a>插入：</h5><ul><li>若二叉排序树为空，则插入结点作为根节点插入到空树中。</li><li>否则，继续在其左、右子树上查找<ul><li>树中已有，不再插入</li><li>树中没有<ul><li>查找直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或有孩子。</li></ul></li></ul></li></ul><p><strong>通俗一点的说法就是：</strong></p><p>①：如果空，则为根节点。</p><p>②：大于根结点，插入右子树。</p><p>③：小于根结点，插入左子树。</p><p><strong>二叉排序树的操作：—生成：</strong></p><ul><li>从空树出发，经过一系列的查找、插入操作之后，可生成一棵二叉排序树。</li><li><strong>一个无序列序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。</strong></li><li>插入的结点均为叶子结点，故无需移动其他结点。相当于在有序序列上插入记录而无需移动其他记录。</li></ul><p><strong>但是：</strong></p><ul><li>关键字的输入顺序不同，建立的二叉树排序树不同。</li></ul><h5 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h5><p>关于删除，相对来说要比查找和插入要麻烦一些，但是请耐心看下去。</p><ul><li>从二叉排序树中删除一个结点，不能把以该结点为根的子树都删去，只能删除该结点，并且还<strong>应保证删除后所得的二叉树仍然满足二叉排序树的性质不变</strong>。</li><li>由于中序遍历二叉排序树可以得到一个递增有序的序列。那么，在二叉排序树中删去一个结点相当于删去有序序列中的一个结点。<ul><li>将因删除结点而断开的二叉链表重新连接起来。</li><li>防止重新链接后树的高度增加。</li></ul></li></ul><p><strong>通俗一点的说法就是：</strong></p><p>①：被删除的为叶子结点，直接删去该结点。</p><p>②：被删除结点只有右孩子或左孩子，用其左子树或右子树替换它(结点替换)。其双亲结点的相应指针域的值改为”指向被删除结点的左子树或右子树”。</p><p>③：被删除的节点上既有左子树，又有右子树：</p><ul><li>(1)：用前驱结点去替换，然后删除要删除的结点。</li><li>(2)：用后继结点去替换，然后删除要删除的结点。</li><li>不管用前驱结点替换还是后继结点替换，都应该保存二叉树的性质;</li></ul><p><img src="/images/Tree/tree_2.png"></p><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * BinaryTree 的节点数据结构</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">private</span> String data = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">boolean</span> isVisited = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">private</span> TreeNode leftChild = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">private</span> TreeNode rightChild = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> key,String data)</span></span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.key = key;</span><br><span class="line">                <span class="keyword">this</span>.data = data;</span><br><span class="line">                <span class="keyword">this</span>.leftChild = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.rightChild = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取根节点</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.root = root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义根节点</span></span><br><span class="line">        <span class="keyword">private</span> TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">            root = <span class="keyword">new</span> TreeNode(<span class="number">10</span>,<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一棵二叉树</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBinaryTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">            TreeNode nodeB = <span class="keyword">new</span> TreeNode(<span class="number">8</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            TreeNode nodeC = <span class="keyword">new</span> TreeNode(<span class="number">12</span>,<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            TreeNode nodeD = <span class="keyword">new</span> TreeNode(<span class="number">7</span>,<span class="string">&quot;D&quot;</span>);</span><br><span class="line">            TreeNode nodeE = <span class="keyword">new</span> TreeNode(<span class="number">9</span>,<span class="string">&quot;E&quot;</span>);</span><br><span class="line">            TreeNode nodeF = <span class="keyword">new</span> TreeNode(<span class="number">22</span>,<span class="string">&quot;F&quot;</span>);</span><br><span class="line">            root.leftChild = nodeB;</span><br><span class="line">            root.rightChild = nodeC;</span><br><span class="line">            nodeB.leftChild = nodeD;</span><br><span class="line">            nodeB.rightChild = nodeE;</span><br><span class="line">            nodeC.rightChild = nodeF;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 前序遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                visited(node);</span><br><span class="line">                preOrder(node.leftChild);</span><br><span class="line">                preOrder(node.rightChild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 中序遍历</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                preOrder(node.leftChild);</span><br><span class="line">                visited(node);</span><br><span class="line">                preOrder(node.rightChild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 后序遍历</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                preOrder(node.leftChild);</span><br><span class="line">                preOrder(node.rightChild);</span><br><span class="line">                visited(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 非递归前序遍历</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonRecPreOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">            Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            TreeNode pNode = node;</span><br><span class="line">            <span class="keyword">while</span>(pNode != <span class="keyword">null</span> || stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(pNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    visited(pNode);</span><br><span class="line">                    stack.push(pNode);</span><br><span class="line">                    pNode = pNode.leftChild;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    pNode = stack.pop();</span><br><span class="line">                    pNode = pNode.rightChild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 非递归中序遍历</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonRecInOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">            Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            TreeNode pNode = node;</span><br><span class="line">            <span class="keyword">while</span>(pNode != <span class="keyword">null</span> || stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(pNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(pNode);</span><br><span class="line">                    pNode = pNode.leftChild;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    pNode = stack.pop();</span><br><span class="line">                    visited(pNode);</span><br><span class="line">                    pNode = pNode.rightChild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 非递归后序遍历</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> pNode</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonRecPostOrder</span><span class="params">(TreeNode pNode)</span></span>&#123;</span><br><span class="line">            Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            TreeNode node = pNode;</span><br><span class="line">            <span class="keyword">while</span>(pNode != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//左子树入栈</span></span><br><span class="line">                <span class="keyword">while</span>(pNode.leftChild != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(pNode);</span><br><span class="line">                    pNode = pNode.leftChild;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//当前节点无右子树或者右子树已输出</span></span><br><span class="line">                <span class="keyword">while</span>(pNode != <span class="keyword">null</span> &amp;&amp; (pNode.rightChild == <span class="keyword">null</span> || pNode.rightChild == node))&#123;</span><br><span class="line">                    visited(pNode);</span><br><span class="line"><span class="comment">//记录上一个已输出的节点</span></span><br><span class="line">                    node = pNode;</span><br><span class="line">                    <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                        pNode = stack.pop();</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//右子树入栈</span></span><br><span class="line">                stack.push(pNode);</span><br><span class="line">                pNode = pNode.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visited</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">            node.isVisited = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(node.data+<span class="string">&quot;,&quot;</span>+node.key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 计算树的高度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = height(node.leftChild);</span><br><span class="line">                <span class="keyword">int</span> j = height(node.rightChild);</span><br><span class="line">                <span class="keyword">return</span> (i&lt;j)?j+<span class="number">1</span>:i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 计算树的节点数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 树的节点数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>+size(node.leftChild)+size(node.rightChild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">            TreeNode root = binaryTree.root;</span><br><span class="line">            binaryTree.createBinaryTree(root);</span><br><span class="line">            System.out.println(binaryTree.height(root));</span><br><span class="line">            System.out.println(binaryTree.size(root));</span><br><span class="line">            binaryTree.preOrder(root);</span><br><span class="line">            System.out.println(<span class="string">&quot;*******&quot;</span>);</span><br><span class="line">            binaryTree.nonRecPreOrder(root);</span><br><span class="line">            System.out.println(<span class="string">&quot;*******&quot;</span>);</span><br><span class="line">            binaryTree.nonRecInOrder(root);</span><br><span class="line">            System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">            binaryTree.nonRecPostOrder(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2：平衡二叉树："><a href="#2：平衡二叉树：" class="headerlink" title="2：平衡二叉树："></a>2：平衡二叉树：</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线性表的查找：&quot;&gt;&lt;a href=&quot;#线性表的查找：&quot; class=&quot;headerlink&quot; title=&quot;线性表的查找：&quot;&gt;&lt;/a&gt;线性表的查找：&lt;/h2&gt;&lt;h3 id=&quot;一：顺序查找-线性查找-：&quot;&gt;&lt;a href=&quot;#一：顺序查找-线性查找-：&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JDBC事务</title>
    <link href="https://7heng.github.io/2021/04/08/JDBC%E4%BA%8B%E5%8A%A1/"/>
    <id>https://7heng.github.io/2021/04/08/JDBC%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-04-08T11:29:04.000Z</published>
    <updated>2021-04-18T07:31:19.840Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库事务介绍："><a href="#数据库事务介绍：" class="headerlink" title="数据库事务介绍："></a>数据库事务介绍：</h3><ul><li><strong>事务：</strong>一组逻辑单元，使数据从一种状态变换到另一种状态。</li><li><strong>事务处理（事务操作)：</strong>保证所有事务都为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被<strong>提交(commit)</strong>,那么这些修改就永久地保存下来；要么所有的事务都<strong>被提交(commit)</strong>;那么这些修改就永久地保存下来;要么数据库管理系统将放弃所作的所有修改，整个事务**回滚(rollback)**到最初状态。</li><li>为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。</li></ul><h3 id="JDBC事务处理："><a href="#JDBC事务处理：" class="headerlink" title="JDBC事务处理："></a>JDBC事务处理：</h3><ul><li><p>数据一旦提交，就不可回滚。</p></li><li><p>数据什么时候意味着提交？</p><ul><li><strong>当一个连接对象被创建时，默认情况下是自动提交事务：</strong>每次执行一个SQL语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li><li><strong>关闭数据库连接,数据就会自动的提交</strong>。如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li></ul></li><li><p><strong>JDBC程序中为了让多个 SQL 语句作为一个事务执行：</strong></p><ul><li>调用 Connection 对象的 **setAutoCommit(false);**以取消自动提交事务</li><li>在所有的SQL语句都成功执行后，调用 **commit();**方法提交事务</li><li>在出线异常时，调用 <strong>rollback();</strong> 方法回滚事务</li></ul><p><strong><em>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</em></strong></p><p>【例：用户AA向用户BB转账100】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJDBCTransaction</span><span class="params">()</span></span>&#123;</span><br><span class="line">Connection conn  = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 1.获取数据库连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"><span class="comment">// 2.开始事务</span></span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 3.进行数据库操作</span></span><br><span class="line">String sqsl1 = <span class="string">&quot;updata user_table set balance = balance -100 where user = ?&quot;</span>;</span><br><span class="line">updata(conn, sql1, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟网络异常</span></span><br><span class="line"><span class="comment">// System.out.println(10 / 0);</span></span><br><span class="line"></span><br><span class="line">String sql2 = <span class="string">&quot;updata user_table set balance = balance + 100 where user = ?&quot;</span>;</span><br><span class="line">updata (conn, sql2, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"><span class="comment">// 4.若没有异常，则提交事务</span></span><br><span class="line">conn.commit();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">// 5.若有异常，则回滚事务</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">conn.rollback();</span><br><span class="line">&#125;<span class="keyword">catch</span> (SQLException e1)&#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 6.恢复每次DML操作的自动提交功能</span></span><br><span class="line">conn.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7.关闭连接</span></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，对数据库操作的方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用事务以后的通用的增删改操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updata</span><span class="params">(Connection conn, String sql, Object... args)</span></span>&#123;</span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 1.获取PreparedStatement的实例(或：预编译SQL语句)</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 2.填充占位符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; args.length;i++)&#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>,args[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.执行sql语句</span></span><br><span class="line">ps.execute();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">// 4.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(<span class="keyword">null</span>,ps);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事务的ACID属性："><a href="#事务的ACID属性：" class="headerlink" title="事务的ACID属性："></a>事务的ACID属性：</h3><ol><li><p><strong>原子性（Atomicity)：</strong></p><p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p></li><li><p><strong>一致性（Consistency)：</strong></p><p>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p></li><li><p><strong>隔离性（lesolation)：</strong></p><p>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></li><li><p><strong>持久性（Durability)：</strong></p><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p></li></ol></li></ul><h3 id="数据库的并发问题："><a href="#数据库的并发问题：" class="headerlink" title="数据库的并发问题："></a>数据库的并发问题：</h3><ul><li>对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并问题：<ul><li><strong>脏读：</strong>对于两个事务T1，T2，T1读取了已经被T2更新但还<strong>没有提交</strong>的字段。之后，若T2回滚，T1读取的内容就是临时且无效的。</li><li><strong>不可重复读：</strong>对于两个事务T1，T2，T1读取了一个字段，然后T2<strong>更新</strong>了该字段。之后，T1再次读取同一个字段，值就不同了。</li><li><strong>幻读：</strong>对于两个事务T1，T2，T1从一个表中读取了一个字段，然后T2在该表中<strong>插入</strong>了一些新的行。之后，如果T1再次读取同一个表，就会多出几行。</li></ul></li><li><strong>数据库事务的隔离性：</strong>数据库系统必须具有隔离并发运行各个事物的能力，使它们不会相影响，避免各种并发问题。</li><li>一个事务与其它事务隔离的程序称为隔离级别。数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，<strong>隔离级别越高，数据一致性越好，但并发性越弱。</strong></li></ul><h3 id="四种隔离级别："><a href="#四种隔离级别：" class="headerlink" title="四种隔离级别："></a>四种隔离级别：</h3><p><img src="/images/JDBC_1/ACID_1.png"></p><ul><li>Oracle支持的2种事务隔离级别：<strong>READ COMMITED</strong>，SERIALIZABLE。 Oracle默认的事务隔离级别为：<strong>READ COMMITED</strong>。</li><li>MySQL支持4种事务隔离级别。MySQL默认的事务隔离级别为：REPEATABLE READ。</li></ul><h4 id="在MySQL种设置隔离级别："><a href="#在MySQL种设置隔离级别：" class="headerlink" title="在MySQL种设置隔离级别："></a>在MySQL种设置隔离级别：</h4><ul><li>每启动一个mySQL程序，就会获得一个单独的数据连接，每个数据库连接都有一个全局变量<code>@@tx_isolation</code>，表示当前的事务隔离级别。</li><li>查看当前的隔离级别：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECE @@tx_isolation;</span><br></pre></td></tr></table></figure><ul><li>设置当前MySQL 连接的隔离级别：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set transaction isolation level read commited;</span><br></pre></td></tr></table></figure><ul><li>设置数据库系统的全局的隔离级别：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure><ul><li><p>补充操作：</p><ul><li><p>创建MySQL数据库的用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user tom identified by &#39;heng7&#39;;</span><br></pre></td></tr></table></figure></li><li><p>授予权限</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#授予通过网络方式登录的heng用户，对所有库所有表的全部权限，密码设为heng777.</span><br><span class="line">grant all privileges on *.* to heng@&#39;%&#39;  identified by &#39;heng777&#39;; </span><br><span class="line"></span><br><span class="line"> #给heng用户使用本地命令行方式，授予idowhatido这个库下的所有表的插删改查的权限。</span><br><span class="line">grant select,insert,delete,update on idowhatido.* to heng@localhost identified by &#39;heng777&#39;; </span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>详细的数据库事务讲解请看另一篇文章：<a href="">https://7heng.github.io/2021/03/31/MySQL-TCL/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据库事务介绍：&quot;&gt;&lt;a href=&quot;#数据库事务介绍：&quot; class=&quot;headerlink&quot; title=&quot;数据库事务介绍：&quot;&gt;&lt;/a&gt;数据库事务介绍：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;事务：&lt;/strong&gt;一组逻辑单元，使数据从一种状态变换到另一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JBDC批量插入</title>
    <link href="https://7heng.github.io/2021/04/08/JBDC%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/"/>
    <id>https://7heng.github.io/2021/04/08/JBDC%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/</id>
    <published>2021-04-08T09:11:51.000Z</published>
    <updated>2021-04-18T07:27:27.655Z</updated>
    
    <content type="html"><![CDATA[<h3 id="批量插入："><a href="#批量插入：" class="headerlink" title="批量插入："></a>批量插入：</h3><p>批量执行SQL语句：当需要成批插入或者更新记录时，可以采用java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独处理更有效率。</p><p>JDBC的批量处理语句包括下面三个方法：</p><ul><li><strong>addBatch(String)：添加需要批处理的SQL语句或是参数</strong>。</li><li><strong>executeBatch()：执行批量处理语句</strong>。</li><li><strong>clearBatch()：清空缓存的数据</strong>。</li></ul><p>通常我们会遇到两种批量执行SQL语句的情况：</p><ul><li>多条SQL语句的批量处理;</li><li>一个SQL语句的批量传参;</li></ul><h3 id="高效的批量插入："><a href="#高效的批量插入：" class="headerlink" title="高效的批量插入："></a>高效的批量插入：</h3><p>举例：向数据表中插入20000条数据</p><ul><li>数据库中提供一个goods表，创建如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE goods&#123;</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">NAME VARCHAR(20)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="实现层次一：使用Statement"><a href="#实现层次一：使用Statement" class="headerlink" title="实现层次一：使用Statement"></a>实现层次一：使用Statement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取连接</span></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line">String sql = <span class="string">&quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;</span>+ i +<span class="string">&quot;)&quot;</span>;</span><br><span class="line">st.executeUpdate(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现层次二：使用PreparedStatement"><a href="#实现层次二：使用PreparedStatement" class="headerlink" title="实现层次二：使用PreparedStatement"></a>实现层次二：使用PreparedStatement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 获取连接</span></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line"><span class="comment">// sql插入语句，值用占位符替代</span></span><br><span class="line">String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.preparedStatement(sql);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i &lt;=<span class="number">20000</span>;i++)&#123;</span><br><span class="line">ps.setString(<span class="number">1</span>,<span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">ps.executeUpdata();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currenTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure><h4 id="实现层次三："><a href="#实现层次三：" class="headerlink" title="实现层次三："></a>实现层次三：</h4><p>修改1：使用addBatch()  /  executeBatch()  /  clearBatch()</p><p>修改2：mysql服务器默认是关闭处理的，我们需要通过一个参数，让mysql开启批处理的支持。</p><ul><li> ?rewriteBatchedStatements=true 写在配置文件的url后面</li></ul><p>修改3：使用更新的 mysql 驱动,mysql-connector-java-5.1.37-bin.jar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tsteInsert1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currenTimeMillis();</span><br><span class="line"><span class="comment">// 获取连接</span></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line"><span class="comment">// sql插入语句，值用占位符替代</span></span><br><span class="line">String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.preparedStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">ps.setString(<span class="number">1</span>,<span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1：&quot;攒&quot;sql</span></span><br><span class="line">ps.addBatch();</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// 2：执行</span></span><br><span class="line">ps.executeBatch();</span><br><span class="line"><span class="comment">// 3：清空</span></span><br><span class="line">ps.clearBatch();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimellis();</span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">// 20000条：6251000000条：14733</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">JDBCUtils.closeResource(conn,ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现层次四："><a href="#实现层次四：" class="headerlink" title="实现层次四："></a>实现层次四：</h4><ul><li>在层次三的的基础上操作</li><li>使用Connection 的 setAutoCommit (false）/ commit()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 获取连接</span></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.设置为不自动提交数据</span></span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// sql插入语句，值用占位符填充</span></span><br><span class="line">String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.“攒”sql</span></span><br><span class="line">ps.addBatch();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//2.执行</span></span><br><span class="line">ps.executeBatch();</span><br><span class="line"><span class="comment">//3.清空</span></span><br><span class="line">ps.clearBatch();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.提交数据</span></span><br><span class="line">conn.commit();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//1000000条:4978 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;批量插入：&quot;&gt;&lt;a href=&quot;#批量插入：&quot; class=&quot;headerlink&quot; title=&quot;批量插入：&quot;&gt;&lt;/a&gt;批量插入：&lt;/h3&gt;&lt;p&gt;批量执行SQL语句：当需要成批插入或者更新记录时，可以采用java的批量更新机制，这一机制允许多条语句一次性提交给数</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JDBC操作Blob类型</title>
    <link href="https://7heng.github.io/2021/04/08/JDBC%E6%93%8D%E4%BD%9CBlob%E7%B1%BB%E5%9E%8B/"/>
    <id>https://7heng.github.io/2021/04/08/JDBC%E6%93%8D%E4%BD%9CBlob%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-04-08T08:26:32.000Z</published>
    <updated>2021-04-18T07:29:33.894Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL-BLOB类型："><a href="#MySQL-BLOB类型：" class="headerlink" title="MySQL BLOB类型："></a>MySQL BLOB类型：</h3><ul><li>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</li><li>插入BLOB类型的数据必须使用PrepareStatement，因为BLOB类型的数据无法使用字符串拼写。</li><li>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</li></ul><p><img src="/images/JDBC_1/Blob_1.png"></p><ul><li>实际使用中根据需要存入的数据大小定义不同的Blob类型。</li><li>需要注意的是：如果存储的文件过大，数据库的性能会下降。</li><li>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数：<strong>max_allowed_packet=16M</strong>。同时注意：修改了my.ini文件之后，需要重新启动Mysql服务。</li></ul><h3 id="向数据表中插入大数据类型："><a href="#向数据表中插入大数据类型：" class="headerlink" title="向数据表中插入大数据类型："></a>向数据表中插入大数据类型：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取连接</span></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// sql插入语句，值用占位符替代</span></span><br><span class="line">String sql = <span class="string">&quot;insert into customer(name,emial,birth,photo)values(?,?,?,?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStaement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line">ps.setString(<span class="number">1</span>,<span class="string">&quot;路飞&quot;</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>,<span class="string">&quot;Cy7heng@163.com&quot;</span>);</span><br><span class="line">ps.setData(<span class="number">3</span>,<span class="keyword">new</span> Data(<span class="keyword">new</span> java.util.Data.getTime()));</span><br><span class="line"><span class="comment">//操作Bolb类型的变量</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;Suolong.PNG&quot;</span>);</span><br><span class="line">ps.setBlob(<span class="number">4</span>,fis);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">ps.execute();</span><br><span class="line"><span class="comment">//关闭</span></span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.CloseResource(conn,ps);</span><br></pre></td></tr></table></figure><h3 id="修改数据表中的Blob类型字段："><a href="#修改数据表中的Blob类型字段：" class="headerlink" title="修改数据表中的Blob类型字段："></a>修改数据表中的Blob类型字段：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取连接</span></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// sql更新语句，值用占位符替代 </span></span><br><span class="line">String sql = <span class="string">&quot;update customer set photo = ? where id = ?&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;luobin.png&quot;</span>);</span><br><span class="line">ps.setBlob(<span class="number">1</span>,fis);</span><br><span class="line">ps.setInt(<span class="number">2</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line">ps.execute();</span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn,ps);</span><br></pre></td></tr></table></figure><h3 id="从数据表读取大量数据类型："><a href="#从数据表读取大量数据类型：" class="headerlink" title="从数据表读取大量数据类型："></a>从数据表读取大量数据类型：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">&quot;SELECT id, name, email, birth, photo From customer WHERE id = ?&quot;</span>;</span><br><span class="line">conn = getConnection();</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="function">ps <span class="title">setInt</span><span class="params">(<span class="number">1</span>,<span class="number">8</span>)</span></span>;</span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">Integer id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">    String name = rs.getString(<span class="number">2</span>);</span><br><span class="line">String email = rs.getString(<span class="number">3</span>);</span><br><span class="line">    Date birth = rs.getDate(<span class="number">4</span>);</span><br><span class="line">Customer cust = <span class="keyword">new</span> Customer(id, name, email, birth);</span><br><span class="line">    System.out.println(cust);</span><br><span class="line">    <span class="comment">// 读取Blob类型的字段</span></span><br><span class="line">    Blob photo = rs.getBlob(<span class="number">5</span>);</span><br><span class="line">InputStream is = photo.getBinaryStream();</span><br><span class="line">OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;c.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> bytr[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    JDBCUtils.closeResource(conn,ps,rs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(is != <span class="keyword">null</span>)&#123;</span><br><span class="line">    is.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(os != <span class="keyword">null</span>)&#123;</span><br><span class="line">    os.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;MySQL-BLOB类型：&quot;&gt;&lt;a href=&quot;#MySQL-BLOB类型：&quot; class=&quot;headerlink&quot; title=&quot;MySQL BLOB类型：&quot;&gt;&lt;/a&gt;MySQL BLOB类型：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;MySQL中，BLOB是一个二进制大型对</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TCP协议</title>
    <link href="https://7heng.github.io/2021/04/07/TCP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://7heng.github.io/2021/04/07/TCP%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-04-07T10:37:47.000Z</published>
    <updated>2021-04-07T12:54:43.341Z</updated>
    
    <content type="html"><![CDATA[<h3 id="传输控制协议-Transmission-Control-Protocol-即TCP）应用场景："><a href="#传输控制协议-Transmission-Control-Protocol-即TCP）应用场景：" class="headerlink" title="传输控制协议(Transmission Control Protocol 即TCP）应用场景："></a>传输控制协议(Transmission Control Protocol 即TCP）应用场景：</h3><ul><li>应用程序要传输的报文大，就要分段传输，每段封装成一个数据包，在接收端将分段组装成完整的报文。</li><li>应用层协议需要交互多次。</li><li>功能：可靠传输（丢包自动重传、在接收端排序、流量控制、拥塞避免）。</li></ul><h3 id="用户数据包协议-User-Datagram-Protocol-即UDP）应用场景："><a href="#用户数据包协议-User-Datagram-Protocol-即UDP）应用场景：" class="headerlink" title="用户数据包协议(User Datagram Protocol 即UDP）应用场景："></a>用户数据包协议(User Datagram Protocol 即UDP）应用场景：</h3><ul><li>就是应用程序传输的报文小，不需要分段。</li><li>应用程序之间不需要多次交互。</li><li>屏幕广播软件、不可靠传输。</li><li>实时通信。</li></ul><h3 id="Tcp功能和首部："><a href="#Tcp功能和首部：" class="headerlink" title="Tcp功能和首部："></a>Tcp功能和首部：</h3><ul><li>Tcp为应用层协议提供可靠的的传输，在应用程序通信之间需要建立Tcp连接，客户端程序和服务端程序使用建立的Tcp连接实现双向通信，在通信过程Tcp实现可靠传输、流量控制、网络拥塞控制自动感知等功能，应用程序通信结束后，再释放Tcp连接。</li><li>Netstat -n 可以查看建立的的Tcp连接。</li></ul><h3 id="Tcp功能："><a href="#Tcp功能：" class="headerlink" title="Tcp功能："></a>Tcp功能：</h3><p>Tcp为应用程序通信提供可靠传输。在通信过程中实现以下功能：</p><ul><li>建立连接：在正式传输数据之前先建立Tcp连接，协商一些参数，比如告诉对方自己的接收缓存多大(单位：字节)，一个段最多承载多少自己的数据，是否支持选择性确认(SACK)。</li><li>可靠传输：发送端将文件以字节流的形式放入发送端缓存，接收端以字节流的形式从缓存读取。数据包丢失，超时后发送端会自动重传，没按顺序到达，会在接收端缓存排序。</li><li>拥塞避免：这整个通信过程网络有可能拥塞也有可能畅通，发送端开始发送数据时先感知网络是否拥堵，调整发送速度。</li><li>流量控制：如果发送端发送过块，接收端的应用程序有可能来不及从接收缓存读取数据，造成接收缓存满。接收端接收数据过程中可以告诉发送端发送快一点还是慢一点，是否需要暂停一会儿。</li><li>释放连接：发送完毕，还要告诉对方发送完毕，等对方收到确认才释放连接。</li></ul><h3 id="Tcp首部："><a href="#Tcp首部：" class="headerlink" title="Tcp首部："></a>Tcp首部：</h3><p><img src="/images/Tcp/TcpHead.png"></p><h3 id="序号和确认号的作用："><a href="#序号和确认号的作用：" class="headerlink" title="序号和确认号的作用："></a>序号和确认号的作用：</h3><p><img src="/images/Tcp/Tcp_1.png"></p><h3 id="Tcp流工作过程："><a href="#Tcp流工作过程：" class="headerlink" title="Tcp流工作过程："></a>Tcp流工作过程：</h3><p><img src="/images/Tcp/Tcp_2.png"></p><ul><li>最前面三个是建立Tcp连接的数据包，这三个数据包包含参数。Tcp连接建立后，可以实现全双工通信。POP使用该连接接收电子邮件，接收完毕后就要释放Tcp连接。最后四个数据包是释放Tcp连接的数据包。可以看到使用该连接邮件客户端可以向邮件服务器发送请求，邮件服务器也可以向客户端发送响应，不需要建立两个Tcp连接。</li></ul><h3 id="Tcp建立连接数据包："><a href="#Tcp建立连接数据包：" class="headerlink" title="Tcp建立连接数据包："></a>Tcp建立连接数据包：</h3><p><img src="/images/Tcp/Tcp_3.png"></p><ul><li>应用程序客户端向服务端程序发起请求，客户端计算机向服务端计算机发送建立Tcp连接的请求。</li><li>第3个数据包是客户端向服务器发送的第一个数据包，请求连接的数据包的特征：SYN（同步）标记位为1，ACK（确认）标记位为0，(意味着ACK无效，但WireShark上看到是0，因为这是客户端向服务器发送的第一个数据包，所以序号为0（seq=0）)。</li><li>该数据包Tcp首部的选项部分，指明客户端支持的最大报文段长度(Maximum Segment Size，MSS)和允许选择确认(Selective Acknowledgment，SACK)，连接请求数据包没有数据部分。</li></ul><h3 id="Tcp连接确认数据包："><a href="#Tcp连接确认数据包：" class="headerlink" title="Tcp连接确认数据包："></a>Tcp连接确认数据包：</h3><p><img src="/images/Tcp/Tcp_4.png"></p><ul><li>确认连接数据包的特征：SYN（同步）标记位为1，ACK（确认）标记位为1，这是服务器向客户端发送的第一个数据包，所以序号为0（seq=0),服务器收到了客户端的请求（seq=0),确认已经收到，发送的确认号为1，选项部分指明服务器支持的最大报文段长度（MSS）为1460。</li></ul><h3 id="Tcp连接确认的确认数据包："><a href="#Tcp连接确认的确认数据包：" class="headerlink" title="Tcp连接确认的确认数据包："></a>Tcp连接确认的确认数据包：</h3><p><img src="/images/Tcp/Tcp_5.png"></p><ul><li>客户端收到服务器的确认后，还需要向服务器发送一个确认，我们称之为确认的确认。这个确认数据包和以后通信的数据包，ACK标记位为1，SYN标记位为0。</li></ul><h3 id="建立Tcp连接的过程："><a href="#建立Tcp连接的过程：" class="headerlink" title="建立Tcp连接的过程："></a>建立Tcp连接的过程：</h3><p><img src="/images/Tcp/Tcp_6.png"></p><h4 id="两次握手会出现的问题："><a href="#两次握手会出现的问题：" class="headerlink" title="两次握手会出现的问题："></a>两次握手会出现的问题：</h4><ul><li>假如客户端以一条路径给服务端发送了一个请求，没等服务端返回连接确认又给服务端以另一条路径发送了第二个请求，服务端发回了第二个请求的确认，但如果此时服务端接收到了请求一，再发送请求一的确认，客户端将会忽略请求一的确认，而服务端则会等待客户端返回请求一的确认，因此服务端和客户端会互相一直等待。</li></ul><h4 id="三次握手解决问题："><a href="#三次握手解决问题：" class="headerlink" title="三次握手解决问题："></a>三次握手解决问题：</h4><ul><li>客户端给服务端会多发送一次确认的确认，例如上述两次握手，如果客户端一直没给服务端发确认的确认，服务端等待过后则会将请求一释放，不会造成一直等待的现象。</li></ul><h3 id="可靠传输的实现"><a href="#可靠传输的实现" class="headerlink" title="可靠传输的实现:"></a>可靠传输的实现:</h3><ul><li>Tcp发送的报文段是交给网络层传送的，我们知道，网络层只是尽最大努力将数据包发送到目的地，不考虑网络是否堵塞，数据包是否丢失。这就需要Tcp采取适当的措施才能使发送端和接收端之间的通信变得可靠。</li></ul><h3 id="Tcp可靠传输的实现-停止等待协议："><a href="#Tcp可靠传输的实现-停止等待协议：" class="headerlink" title="Tcp可靠传输的实现-停止等待协议："></a>Tcp可靠传输的实现-停止等待协议：</h3><p><img src="/images/Tcp/Tcp_7.png"></p><p><img src="/images/Tcp/Tcp_8.png"></p><ul><li>发送一个等待接收一个，超时则重传。</li><li>超时重传收到同样的数据包，丢弃发重复的，重新确认。</li><li>超时重传收到超时的数据确认包，收下但什么也不做。</li></ul><h3 id="连续ARQ协议和滑动窗口协议-改进的停止等待协议："><a href="#连续ARQ协议和滑动窗口协议-改进的停止等待协议：" class="headerlink" title="连续ARQ协议和滑动窗口协议-改进的停止等待协议："></a>连续ARQ协议和滑动窗口协议-改进的停止等待协议：</h3><p><img src="/images/Tcp/Tcp_9.png"></p><ul><li><p>窗口分组，直接发送一个窗口，收到确认则发送下一个窗口。</p></li><li><p><strong>连续ARQ：</strong>一个窗口里含有多个组，每次一个窗口会将多个组连续发送。</p></li><li><p><strong>滑动窗口：</strong>发送一个窗口等待时，窗口滑动到下一个多组。</p></li></ul><h4 id="以字节为单位的滑动窗口技术详解："><a href="#以字节为单位的滑动窗口技术详解：" class="headerlink" title="以字节为单位的滑动窗口技术详解："></a>以字节为单位的滑动窗口技术详解：</h4><p><img src="/images/Tcp/Tcp_10.png"></p><p><img src="/images/Tcp/Tcp_11.png"></p><h3 id="Tcp连接释放："><a href="#Tcp连接释放：" class="headerlink" title="Tcp连接释放："></a>Tcp连接释放：</h3><p><img src="/images/Tcp/Tcp_12.png"></p><ul><li>连接和关闭都是客户端发送请求。</li><li>Client–&gt;Server：客户端发送关闭连接，客户端变为FIN-WAIT-1状态。</li><li>Server–&gt;Client：服务端发送连接，变成CLOSE-WAIT状态。</li><li>Server–&gt;Client：CLOSE-WAIT被动关闭后向客户端发送连接，变成LAST-ACK状态。</li><li>Client–&gt;Server：客户端发送连接变成TIME-WAIT状态，服务端收到连接变成CLOSED关闭连接状态，客户端等待2MSL(2倍最长报文时间)后变成CLOSED关闭连接状态。</li></ul><p><strong>TIME-WAIT的意义：</strong></p><ul><li>如果最后Client–&gt;Server发送的连接丢失，Server向Client发送连接，Client必须是TIME-WAIT状态才能收到，如果是CLOSED状态，则无法收到，将会导致服务端一直无法关闭。所以Client会存在TIME-WAIT状态等待2MSL（2倍最长报文时间）来避免出现此错误。</li></ul><h3 id="Tcp连接状态："><a href="#Tcp连接状态：" class="headerlink" title="Tcp连接状态："></a>Tcp连接状态：</h3><p>下面是每一个TCP连接在任意时刻可能处于的状态，在Linux下可以在 <strong>netstat</strong>命令的最后一列（State列）里看到。</p><p>各个状态的含义如下：</p><ul><li><strong>CLOSED</strong> ：初始状态，表示TCP连接是“关闭着的”或“未打开的”。</li><li><strong>LISTEN</strong> ：表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接。</li><li><strong>SYN_RCVD</strong> ：表示接收到了SYN报文。在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat很难看到这种状态，除非故意写一个监测程序，将三次TCP握手过程中最后一个ACK报文不予发送。当TCP连接处于此状态时，再收到客户端的ACK报文，它就会进入到ESTABLISHED 状态。</li><li><strong>SYN_SENT</strong> ：这个状态与SYN_RCVD 状态相呼应，当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随即进入到SYN_SENT 状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT 状态表示客户端已发送SYN报文。</li><li><strong>ESTABLISHED</strong> ：表示TCP连接已经成功建立。</li><li><strong>FIN_WAIT_1</strong> ：这个状态得好好解释一下，其实FIN_WAIT_1 和FIN_WAIT_2 两种状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET进入到FIN_WAIT_1 状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2 状态。当然在实际的正常情况下，无论对方处于任何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1 状态一般是比较难见到的，而FIN_WAIT_2 状态有时仍可以用netstat看到。</li><li><strong>FIN_WAIT_2</strong> ：上面已经解释了这种状态的由来，实际上FIN_WAIT_2状态下的SOCKET表示半连接，即有一方调用close()主动要求关闭连接。注意：FIN_WAIT_2 是没有超时的（不像TIME_WAIT 状态），这种状态下如果对方不关闭（不配合完成4次挥手过程），那这个 FIN_WAIT_2 状态将一直保持到系统重启，越来越多的FIN_WAIT_2 状态会导致内核crash。</li><li><strong>TIME_WAIT</strong> ：表示收到了对方的FIN报文，并发送出了ACK报文。 TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment Lifetime，最大分段生存期，指一个TCP报文在Internet上的最长生存时间。每个具体的TCP协议实现都必须选择一个确定的MSL值，RFC 1122建议是2分钟，但BSD传统实现采用了30秒，Linux可以cat/proc/sys/net/ipv4/tcp_fin_timeout看到本机的这个值），然后即可回到CLOSED 可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</li><li><strong>CLOSING</strong> ：这种状态在实际情况中应该很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING 状态表示一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是当双方几乎在同时close()一个SOCKET的话，就出现了双方同时发送FIN报文的情况，这是就会出现CLOSING 状态，表示双方都正在关闭SOCKET连接。</li><li><strong>CLOSE_WAIT</strong> ：表示正在等待关闭。怎么理解呢？当对方close()一个SOCKET后发送FIN报文给自己，你的系统毫无疑问地将会回应一个ACK报文给对方，此时TCP连接则进入到CLOSE_WAIT状态。接下来呢，你需要检查自己是否还有数据要发送给对方，如果没有的话，那你也就可以close()这个SOCKET并发送FIN报文给对方，即关闭自己到对方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。简单地说，当你处于CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。</li><li><strong>LAST_ACK</strong> ：当被动关闭的一方在发送FIN报文后，等待对方的ACK报文的时候，就处于LAST_ACK 状态。当收到对方的ACK报文后，也就可以进入到CLOSED 可用状态了。</li></ul><h3 id="释放Tcp连接的四个数据包："><a href="#释放Tcp连接的四个数据包：" class="headerlink" title="释放Tcp连接的四个数据包："></a>释放Tcp连接的四个数据包：</h3><p><img src="/images/Tcp/Tcp_13.png"></p><h3 id="抓包分析Tcp可靠传输的实现："><a href="#抓包分析Tcp可靠传输的实现：" class="headerlink" title="抓包分析Tcp可靠传输的实现："></a>抓包分析Tcp可靠传输的实现：</h3><p><strong>快重传：</strong></p><p><img src="/images/Tcp/Tcp_14.png"></p><h3 id="网速对确认频率的影响："><a href="#网速对确认频率的影响：" class="headerlink" title="网速对确认频率的影响："></a>网速对确认频率的影响：</h3><p><strong>网速慢，接收端确认频率提高。</strong></p><p><img src="/images/Tcp/Tcp_15.png"></p><h3 id="小Tips："><a href="#小Tips：" class="headerlink" title="小Tips："></a>小Tips：</h3><p>在Tcp的协议下，会存在一些Network attack。</p><ul><li><strong>SYN攻击：</strong>攻击者向服务端发送一个不是本机的的源IP地址去请求连接，服务端去向源IP地址的客户端发送确认请求，并等待确认请求的确认，但是源IP地址的客户端并未给服务端发送过请求连接，因此不会发送确认的确认请求连接。但攻击者会模拟大量的伪IP地址给服务端让它去获取IP地址的确认的确认请求连接，此时服务端会变得非常繁忙，占用大量的CPU资源，从而造成宕机的情况。</li><li><strong>Land攻击：</strong>攻击者以服务端的IP为源IP一直向服务端发送请求，导致服务端会向自己一直发送确认，从而造成CPU资源大量被占用，造成宕机的情况。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;传输控制协议-Transmission-Control-Protocol-即TCP）应用场景：&quot;&gt;&lt;a href=&quot;#传输控制协议-Transmission-Control-Protocol-即TCP）应用场景：&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JDBC实现CURD操作</title>
    <link href="https://7heng.github.io/2021/04/04/JDBC%E5%AE%9E%E7%8E%B0CURD%E6%93%8D%E4%BD%9C/"/>
    <id>https://7heng.github.io/2021/04/04/JDBC%E5%AE%9E%E7%8E%B0CURD%E6%93%8D%E4%BD%9C/</id>
    <published>2021-04-04T07:41:52.000Z</published>
    <updated>2021-04-18T07:30:31.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用PreparedStatement实现CRUD操作："><a href="#使用PreparedStatement实现CRUD操作：" class="headerlink" title="使用PreparedStatement实现CRUD操作："></a>使用PreparedStatement实现CRUD操作：</h2><h3 id="操作和访问数据库："><a href="#操作和访问数据库：" class="headerlink" title="操作和访问数据库："></a><strong>操作和访问数据库：</strong></h3><ul><li><p>数据库连接被用于向数据库服务器发送命令和sql语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。</p></li><li><p>在java.sql包中有3个接口分别定义了对数据库的调用的不同方式：</p><ul><li>Statement：用于执行静态sql语句并返回它所生成结果的对象。</li><li>PrepartedStatement：SQL语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。</li><li>CallbleStatement：用于执行SQL存储过程。</li></ul><p><img src="/images/JDBC_1/Curd.png"></p></li></ul><h4 id="使用Statment操作数据表的弊端："><a href="#使用Statment操作数据表的弊端：" class="headerlink" title="使用Statment操作数据表的弊端："></a>使用Statment操作数据表的弊端：</h4><ul><li>通过调用Connection对象的createStatement()方法创建该对象。该对象用于执行静态的SQL语句，并且返回执行过程。</li><li>Statment 接口中定义了下列方法用于执行SQL语句：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">excuteUpdate</span><span class="params">(String sql)</span>：执行更新操作INSERT、UPDATE、DELETE</span></span><br><span class="line"><span class="function">ResultSet <span class="title">executeQuery</span><span class="params">(String sql)</span>：执行查询操作SELECT</span></span><br></pre></td></tr></table></figure><ul><li><p>但是使用Staement操作数据表存在弊端：</p><ul><li><strong>问题一：存在拼串操作，繁琐</strong>。</li><li><strong>问题二：存在SQL注入问题</strong>。</li></ul></li><li><p>SQL注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的SQL语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’)，从而利用系统的SQL引擎完成恶意行为的做法。</p></li><li><p>对于java而言，要防范SQL注入，只要用PreparedStatement(从Statment扩展而来)取代Statement就可以了。</p></li><li><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatmentTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Statment的弊端：需要拼写sql语句，并且存在SQL注入的问题。</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLogin</span><span class="params">()</span></span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;用户名：&quot;</span>);</span><br><span class="line">String userName = scan.mextLine();</span><br><span class="line">System.out.print(<span class="string">&quot;密 码&quot;</span>);</span><br><span class="line">String password = scan.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">// SELECT user.password FROM user_table WHERE USER = &#x27;1&#x27; or &#x27;AND&#x27; PASSWORD = &#x27;=&#x27;1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;;</span></span><br><span class="line">        String sql = <span class="string">&quot;SELECT user,password FROM user_table WHERE USER = &#x27;&quot;</span> + userName + <span class="string">&quot;&#x27; AND PASSWORD = &#x27;&quot;</span> + password + <span class="string">&quot;&#x27;&#x27;&quot;</span>;</span><br><span class="line">        User user = get(sql,User.class);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名或密码错误!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Statement实现对数据表的查询条件</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt;<span class="function">T <span class="title">get</span><span class="params">(String sql,Class&lt;T&gt; calzz)</span></span>&#123;</span><br><span class="line">T t = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Connection conn <span class="keyword">null</span>;</span><br><span class="line">Statment st = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 1.加载配置文件</span></span><br><span class="line">InputStream is = StatmentTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">pros.load(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.读取配置信息</span></span><br><span class="line">String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">String password = pro.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">String driverClass = pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.加载驱动</span></span><br><span class="line">Class。forName(driverClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获取连接</span></span><br><span class="line">conn = DriverManger.getConnection(url,user,password);</span><br><span class="line"></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">rs = st.executeQury(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集的元数据</span></span><br><span class="line">ResultSetMetaDate rsmd = rs.getMetaData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集的列数</span></span><br><span class="line"><span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">t = clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line"><span class="comment">// //1. 获取列的名称</span></span><br><span class="line"><span class="comment">// String columnName = rsmd.getColumnName(i+1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取列的别名</span></span><br><span class="line">String columnName = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 根据列名获取对应数据表中的数据</span></span><br><span class="line">Object columnVal = rs.getObject(columnName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将数据表中得到的数据，封装进对象</span></span><br><span class="line">Field field = clazz.getDeclaredField(columnName);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(t, columnVal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line"><span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">st.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>综上：</p><p><img src="/images/JDBC_1/Curd1.png"></p></li></ul><h4 id="PreparedStatment的使用："><a href="#PreparedStatment的使用：" class="headerlink" title="PreparedStatment的使用："></a>PreparedStatment的使用：</h4><p><strong>PreparedStatment介绍：</strong></p><ul><li>可以通过调用Connection对象的preparedStatement(String sql)方法获取 PreparedStatement对象。</li><li><strong>PreparedStatment 接口是 Statement 的子接口，它表示一条编译过的 SQL 语句。</strong></li><li>PreparedStatement 对象所代表的SQL语句中的参数用问号(?)来表示，调用PreparedStatement对象的 setXxx() 方法来设置这些参数，setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数值。</li></ul><h4 id="PreparedStatement-VS-Statement"><a href="#PreparedStatement-VS-Statement" class="headerlink" title="PreparedStatement  VS  Statement  :"></a>PreparedStatement  VS  Statement  :</h4><ul><li>代码的可读性和可维护性。</li><li><strong>PreparedStatement 能最大可能提高性能：</strong><ul><li>DBServer会对<strong>预编译</strong>语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u></li><li>(语法检查、语义检查、翻译成二进制命令，缓存)</li></ul></li><li>PreparedStatement 可以防止 SQL 注入。</li></ul><h4 id="java与SQL对应数据类型转换表："><a href="#java与SQL对应数据类型转换表：" class="headerlink" title="java与SQL对应数据类型转换表："></a>java与SQL对应数据类型转换表：</h4><table><thead><tr><th>Java类型</th><th>SQL类型</th></tr></thead><tbody><tr><td>boolean</td><td>BIT</td></tr><tr><td>byte</td><td>TINYINT</td></tr><tr><td>short</td><td>SMALLINT</td></tr><tr><td>int</td><td>INTEGER</td></tr><tr><td>long</td><td>BIGINT</td></tr><tr><td>String</td><td>CHAR,VARCHAR,LONGVARCHAR</td></tr><tr><td>byte   array</td><td>BINARY  ,    VAR BINARY</td></tr><tr><td>java.sql.Date</td><td>DATE</td></tr><tr><td>java.sql.Time</td><td>TIME</td></tr><tr><td>java.sql.Timestamp</td><td>TIMESTAMP</td></tr></tbody></table><h4 id="使用PreparedStatement实现增、删、改操作："><a href="#使用PreparedStatement实现增、删、改操作：" class="headerlink" title="使用PreparedStatement实现增、删、改操作："></a>使用PreparedStatement实现增、删、改操作：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的增删、删、改操作 (体现一：增、删、改。体现二：针对不同的表)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String sql,Obkect ... args)</span></span>&#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 1.获取数据库的连接</span></span><br><span class="line">conn - JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.获取PreparedStament的实例（或预编译sql语句）</span></span><br><span class="line">ps = conn.PrepareStatment(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.填充占位符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; args.length;i++)&#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.执行sql语句</span></span><br><span class="line">ps.execyte();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">pe.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">// 5.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用PreparedStatement实现查询操作："><a href="#使用PreparedStatement实现查询操作：" class="headerlink" title="使用PreparedStatement实现查询操作："></a>使用PreparedStatement实现查询操作：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的针对于不同表的查询：返回一个对象 (Version 1.0)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object ... args)</span></span>&#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">PreparedStatment ps = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取数据库的连接</span></span><br><span class="line">conn = conn.preparedStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.预编译sql语句，得到PreparedStatement对象。</span></span><br><span class="line">ps = conn.prepareStatemtnt(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.填充占位符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++)&#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.执行excuterQuery(),得到结果集，ResultSet。</span></span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.得到结果集的元数据：ResultSetMetaData。</span></span><br><span class="line">ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值。</span></span><br><span class="line"><span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">T t = clazz.newInstance();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;<span class="comment">// 遍历每一个列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取列值</span></span><br><span class="line">Object columnVal = rs.getObject(i + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 获取列的别名:列的别名，使用类的属性名充当</span></span><br><span class="line">String columnLabel = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 6.2使用反射，给对象的相应属性赋值</span></span><br><span class="line">Field field = clazz.getDeclaredField(columnLabel);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(t, columnVal);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 7.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入的问题。</span><br></pre></td></tr></table></figure><h4 id="ResultSet与ResuleSetMetaData"><a href="#ResultSet与ResuleSetMetaData" class="headerlink" title="ResultSet与ResuleSetMetaData:"></a>ResultSet与ResuleSetMetaData:</h4><h5 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet:"></a>ResultSet:</h5><ul><li><p>查询需要掉用PreparedStatment的 executeQury() 方法，查询结果是一个ResuleSet对象</p></li><li><p>ResultSet对象以逻辑表格的形式封装了执行数据库操作的结果集，RsultSet 接口由数据厂商提供实现。</p></li><li><p>ResultSet 返回的实际上就是一张数据表，有一个指针指向数据表的第一条记录的前面。</p></li><li><p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之间，可以通过ResultSet 对象的 next() 方法移动到下一行。调用next()方法检测下一行是否有效。若有效，该方法返回true，且指针下移，相当于lterator对象的hashNext()和next()方法的结合体。</p></li><li><p>当指针指向一行时，可以通过调用getXxx(int index)或getXxx(int columnName)获取每一列的值。</p><ul><li>例如：getlnt(1)，getString(“name”)</li><li>注意：java与数据库交互涉及到相关的java API 中的索引都从1开始。</li></ul></li><li><p>ResuletSet 接口的常用方法：</p><ul><li>boolean next()</li><li>getString()</li><li>…</li></ul><p><img src="/images/JDBC_1/Result"></p></li></ul><h5 id="ResultSetMetaData"><a href="#ResultSetMetaData" class="headerlink" title="ResultSetMetaData:"></a>ResultSetMetaData:</h5><ul><li>可用于获取关于ResultSet 对象中列的类型和属性信息的对象</li><li>ResultSetMetaData meta = rs.getMetaData();<ul><li><strong>getColumnName</strong>(int column)： 获取指定列的名称。</li><li><strong>getColumnLabel</strong>(int column)：获取指定列的别名</li><li>getColumnTypeName(int column)：获取指定列的数据库特定的类型名称。</li><li>getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。</li><li><strong>isNullable</strong>(int column)：指示指定列中的值是否可以为null。</li><li>isAutolncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。</li></ul></li></ul><h3 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h3><p>1：<strong>得到结果后，如何知道该结果集中有那些列？列名是什么？</strong></p><ul><li>需要使用一个描述ResultSet 的对象，即ResultSetMetData。</li></ul><p>2：<strong>关于ResultSetMetaData:</strong></p><ul><li><p><strong>如何获取 ResultSetMetaData：</strong>调用ResultSet 的 getMetaData() 方法即可。</p></li><li><p><strong>获取ResultSet 中 有多少列：</strong>调用ResultSetMetaData 的 getColumnCount() 方法。</p></li><li><p><strong>获取 ResultSet 每一列的列的别名是什么：</strong>调用ResultSetMetaData 的getColumnLable() 方法。</p></li></ul><p>3：<strong>资源的释放：</strong></p><ul><li>释放ResultSet，Statement，Connection。</li><li>数据库的连接(Connection)是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是<strong>尽量晚创建，尽量早释放</strong>。</li><li>可以在finally中关闭，保证即使其他代码出现异常，资源也一定能被关闭。</li></ul><h3 id="JDBC-API小结："><a href="#JDBC-API小结：" class="headerlink" title="JDBC API小结："></a>JDBC API小结：</h3><ul><li><p>两种思想：</p><ul><li><p>面向接口编程的思想</p></li><li><p>ORM思想(object relational mapping)</p><ul><li>一个数据表对应一个java类。</li><li>表中的一条记录对应java类的一个对象。</li><li>表中的一个字段对应java类的一个属性。</li></ul><p>sql是需要结合列名和表名的属性名来写。注意起别名。</p></li></ul></li><li><p>两种技术：</p><ul><li>JDBC结果集的元数据：ResultSetMetaData<ul><li>获取列数：getColumnCount()</li><li>获取列的别名：getColumnLabel()</li></ul></li><li>通过反射，创建指定类的对象，获取指定的属性并赋值。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用PreparedStatement实现CRUD操作：&quot;&gt;&lt;a href=&quot;#使用PreparedStatement实现CRUD操作：&quot; class=&quot;headerlink&quot; title=&quot;使用PreparedStatement实现CRUD操作：&quot;&gt;&lt;/a&gt;使用</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JDBC获取数据库连接</title>
    <link href="https://7heng.github.io/2021/04/03/JDBC%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/"/>
    <id>https://7heng.github.io/2021/04/03/JDBC%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/</id>
    <published>2021-04-03T13:11:58.000Z</published>
    <updated>2021-04-18T07:15:26.499Z</updated>
    
    <content type="html"><![CDATA[<h6 id="一：Driver接口实现类"><a href="#一：Driver接口实现类" class="headerlink" title="一：Driver接口实现类"></a>一：Driver接口实现类</h6><p><strong>Driver接口介绍：</strong></p><ul><li><p>java.sql.Driver接口时所有JDBC驱动程序需要实现的接口，这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p></li><li><p>在程序中不需要直接去访问实现了Driver接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。</p><ul><li>Oracle的驱动：Oracle.jdbc.driver.OracleDriver</li><li>mysql的驱动：com.mysql.jdbc.Driver</li></ul></li></ul><h6 id="二：加载与注册JDBC驱动"><a href="#二：加载与注册JDBC驱动" class="headerlink" title="二：加载与注册JDBC驱动"></a>二：加载与注册JDBC驱动</h6><ul><li><p>加载驱动：加载JDBC驱动需要调用Class类的静态方法forName(),向其传递要加载的JDBC驱动的类名</p><ul><li>Class.forName(“com.mysql.jdbc.Driver”);</li></ul></li><li><p>注册驱动：DriverManager类是驱动程序管理器类，负责管理驱动程序</p><ul><li><p><strong>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</strong></p></li><li><p>通常不用显示调用DriverManager类的registerDriver()方法来注册驱动程序类的实例，因为Driver接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用DriverManager.registerDriver()方法来注册自身的一个实例，下图是MySQL的Driver实现类的源码：</p><p><img src="/images/JDBC_1/Driver.png"></p></li></ul></li></ul><h6 id="三：URL"><a href="#三：URL" class="headerlink" title="三：URL"></a>三：URL</h6><ul><li>JDBC URL用于标识一个被注册的驱动程序，驱动程序管理器通过这个URL选择正确的驱动程序，从而建立到数据库的连接。</li><li>JDBC URL的标准由三部分组成，各部分间用冒号分隔。<ul><li><strong>jdbc:子协议：子名称</strong></li><li><strong>协议：</strong>JDBC URL中的协议总是jdbc</li><li><strong>子协议：</strong>子协议用于标识一个数据库驱动程序</li><li><strong>子名称：</strong>一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了<strong>定位数据库</strong>提供足够的信息，包含主机名(对应服务端的ip地址)，<strong>端口号</strong>，<strong>数据库名</strong>。</li></ul></li></ul><p><img src="/images/JDBC_1/URL.png"></p><ul><li><p>几种常用数据库的JDBC URL</p><p>MySQL的连接URL编写方式：</p><ul><li><p>jdbc:mysql://主机名称:mysql服务端口号/数据库名称？参数=值&amp;参数=值</p></li><li><p>jdbc:mysql://localhost:3306/7heng</p></li><li><p>jdbc:mysql://localhost:3306/7heng?useUnicode=true&amp;characterEncoding=utf8（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</p></li><li><p>jdbc:mysql://locahost:3306/7heng?user=root&amp;password=7777777</p></li><li><p>Oracle9i的连接URL编写方式：</p><ul><li>jdbc:oracle:thin:@主机名称:oracle服务端口：数据库名称</li><li>jdbc:oracle:thin:@localhost:1521:7heng</li></ul></li><li><p>SQLServer的连接URL编写方式：</p><ul><li>jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</li><li>jdbc:sqlserver://localhost:1433:DatabaseName=7heng</li></ul></li></ul></li></ul><h6 id="四：用户名和密码："><a href="#四：用户名和密码：" class="headerlink" title="四：用户名和密码："></a>四：用户名和密码：</h6><ul><li>user,password可以用”属性名=属性值”方式告诉数据库。</li><li>可以调用DriverManger类的getConnection()方法建立到数据库的连接。</li></ul><p><strong>数据库连接方式举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">连接方式一：</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnectionl</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//1：提供java.sql.Driver接口实现类的对象</span></span><br><span class="line">Driver driver = <span class="keyword">null</span>;</span><br><span class="line">driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2：提供url，指明具体操作的数据</span></span><br><span class="line">String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3:提供Properties的对象，指明用户名和密码</span></span><br><span class="line">Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">info.setProperty(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">info.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;7777777&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4:调用driver的connect(),获取连接</span></span><br><span class="line">Connerction conn = driver.conner(url.info);</span><br><span class="line"></span><br><span class="line">System.out,println(conn);</span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：上述代码中显示出现了第三方数据的API</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">连接方式二：</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection2</span><span class="params">()</span></span>&#123;</span><br><span class="line">​<span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//1.实例化Driver</span></span><br><span class="line">Sting ClassName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">Class clazz = Class.forName(className);</span><br><span class="line">Driver driver = (Driver)clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.提供url,指明具体操作的数据</span></span><br><span class="line">String url = <span class="string">&quot;jdbc://mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3。提供url,指明具体操作的数据</span></span><br><span class="line">Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">info.setProperty(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">info.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;ccc7&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.调用driver的connect().获取连接</span></span><br><span class="line">Connection conn = driver.connect(url,info);</span><br><span class="line">System.out.println(conn);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e,printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：相较于方式一，这里使用反射实例化Driver,不在代码中体现第三方数据库的API,体现了面向接口编程的思想。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">连接方式三：</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">String password = <span class="string">&quot;ccc7&quot;</span>;</span><br><span class="line">String driverName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.实例化Driver</span></span><br><span class="line">Class clazz = clazz.forName(driverName);</span><br><span class="line">Driver driver = (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.注册驱动</span></span><br><span class="line">DriverManager.registerDriver(driver);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.获取连接</span></span><br><span class="line">Connection conn = DriverManager.getConnection(url,user,password);</span><br><span class="line">System.out.println(conn);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：使用DriverManager实现数据库的连接，体会获取连接必要的<span class="number">4</span>个基本要素。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">连接方式四：</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 1.数据库连接的4个基本要素：</span></span><br><span class="line">String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">String passwprd = <span class="string">&quot;ccc7&quot;</span>;</span><br><span class="line">String driverName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.加载驱动（①实例化Driver ②注册驱动）</span></span><br><span class="line">class.forName(driverName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Driver driver = (Driver) clazz.newInstance();</span></span><br><span class="line">        <span class="comment">// 3.注册驱动</span></span><br><span class="line">        <span class="comment">//DriverManager.registerDriver(driver);</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：</span></span><br><span class="line"><span class="comment">        static &#123;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">            &#125; catch (SQLException var1) &#123;</span></span><br><span class="line"><span class="comment">                throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.获取连接</span></span><br><span class="line">        Connection conn = DriverManager.getConnection(url,user,password);</span><br><span class="line">        System.out.println(conn);    </span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">连接方式五(完结版!)：</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">// 1.加载配置文件</span></span><br><span class="line">InputStream is = </span><br><span class="line">ConnectionTest.Class.getClassLoader(). getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">    pros.load(is);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.读取配置信息</span></span><br><span class="line">    String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    String driverClass = pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.加载驱动</span></span><br><span class="line">    Class.forName(driverClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.获取连接</span></span><br><span class="line">    Connection conn = DriverManager.getConnection(url,user,passwprd);</span><br><span class="line">    System.out.println(conn);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其中，配置文件声明在工程的src目录下：【jdbc.properties】</span><br><span class="line">user=root</span><br><span class="line">password=abc123</span><br><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test</span></span><br><span class="line">driverClass=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">说明：使用配置文件的方式保存配置信息，在代码中加载配置文件。</span><br><span class="line">使用配置文件的好处：</span><br><span class="line">①：实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码。</span><br><span class="line">②：如果修改了配置信息，省去重新编译的过程。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;一：Driver接口实现类&quot;&gt;&lt;a href=&quot;#一：Driver接口实现类&quot; class=&quot;headerlink&quot; title=&quot;一：Driver接口实现类&quot;&gt;&lt;/a&gt;一：Driver接口实现类&lt;/h6&gt;&lt;p&gt;&lt;strong&gt;Driver接口介绍：&lt;/stron</summary>
      
    
    
    
    
  </entry>
  
</feed>
