<!DOCTYPE html>
<html lang="zh-Hans">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="Collectin子接口之一：Set接口Set接口概述：
Set接口是Collection的子接口,Set接口没有提供额外的方法。
Set集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set集合中，则添加操作失败。
Set判断两个对象是否相同不是使用 == 运算符，而是根据 equals">
    

    <!--Author-->
    
        <meta name="author" content="7heng">
    

    <!-- Title -->
    
    <title>java集合三 | Heng</title>

    <!-- Bootstrap Core CSS -->
    <link href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Custom Fonts -->
    <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Noto+Serif:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- jQuery -->
    <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
    <!-- Bootstrap -->
    <script src="//cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Heng" type="application/atom+xml">
</head>

<body>

    <!-- Content -->
    <section class="article-container">
    <!-- Back Home -->
    <a class="nav-back" href="/">
    <i class="fa fa-puzzle-piece"></i>
</a>

        <!-- Page Header -->
        <header class="intro-header">
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <div class="post-heading">
                            <h1>
                                java集合三
                            </h1>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <!-- Post Content -->
        <article>
            <div class="container">
                <div class="row">
                    <!-- Post Main Content -->
                    <div class="post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <h1 id="Collectin子接口之一：Set接口"><a href="#Collectin子接口之一：Set接口" class="headerlink" title="Collectin子接口之一：Set接口"></a>Collectin子接口之一：Set接口</h1><h3 id="Set接口概述："><a href="#Set接口概述：" class="headerlink" title="Set接口概述："></a>Set接口概述：</h3><ul>
<li>Set接口是Collection的子接口,Set接口没有提供额外的方法。</li>
<li>Set集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set集合中，则添加操作失败。</li>
<li>Set判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法。</li>
</ul>
<h3 id="Set实现类之一：HashSet"><a href="#Set实现类之一：HashSet" class="headerlink" title="Set实现类之一：HashSet"></a>Set实现类之一：HashSet</h3><ul>
<li><p>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。</p>
</li>
<li><p>HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。</p>
</li>
<li><p><strong>HashSet</strong> <strong>具有以下特点：</strong></p>
<ul>
<li>不能保证元素的排列顺序。</li>
<li>HashSet 不是线程安全的。</li>
<li>集合元素可以是 null。</li>
</ul>
</li>
<li><p><strong>HashSet</strong> <strong>集合判断两个元素相等的标准</strong>：两个对象通过 hashCode() 方法比较相</p>
<p>等，并且两个对象的 equals() 方法返回值也相等。 </p>
</li>
<li><p>对于存放在Set容器中的对象，<strong>对应的类一定要重写equals()和hashCode(Object</strong></p>
<p><strong>obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。</strong></p>
</li>
</ul>
<h3 id="向HashSet中添加元素的过程："><a href="#向HashSet中添加元素的过程：" class="headerlink" title="向HashSet中添加元素的过程："></a>向HashSet中添加元素的过程：</h3><ul>
<li><p>当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据hashCode 值，通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好）。 </p>
</li>
<li><p>如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果</p>
<p>为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了，</p>
<p>那么会通过链表的方式继续链接。 </p>
</li>
<li><p>如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相</p>
<p>等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。</p>
</li>
</ul>
<h3 id="HashSet结构图："><a href="#HashSet结构图：" class="headerlink" title="HashSet结构图："></a>HashSet结构图：</h3><p><img src="/images/Collection/Set_1.png"></p>
<h3 id="Set接口框架："><a href="#Set接口框架：" class="headerlink" title="Set接口框架："></a>Set接口框架：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">	|----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”</span><br><span class="line">		|----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值</span><br><span class="line">			|----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历</span><br><span class="line">		|----TreeSet：可以按照添加对象的指定属性，进行排序</span><br><span class="line">		</span><br><span class="line">1：对于频繁的遍历操作，LinkedHashSet效率高于HashSet。</span><br><span class="line"></span><br><span class="line">2：Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。</span><br><span class="line"></span><br><span class="line">3：要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()</span><br><span class="line">   要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码	</span><br><span class="line">   重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Set：存储无序的、不可重复的数据</span><br><span class="line">    以HashSet为例说明：</span><br><span class="line">    1. 无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。</span><br><span class="line"></span><br><span class="line">    2. 不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。</span><br><span class="line"></span><br><span class="line">    添加元素的过程：以HashSet为例：</span><br><span class="line">        我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，</span><br><span class="line">        此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断</span><br><span class="line">        数组此位置上是否已经有元素：</span><br><span class="line">            如果此位置上没有其他元素，则元素a添加成功。 ---&gt;情况1</span><br><span class="line">            如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：</span><br><span class="line">                如果hash值不相同，则元素a添加成功。---&gt;情况2</span><br><span class="line">                如果hash值相同，进而需要调用元素a所在类的equals()方法：</span><br><span class="line">                       equals()返回true,元素a添加失败</span><br><span class="line">                       equals()返回false,则元素a添加成功。---&gt;情况3</span><br><span class="line"></span><br><span class="line">        对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。</span><br><span class="line">        jdk 7 :元素a放到数组中，指向原来的元素。</span><br><span class="line">        jdk 8 :原来的元素在数组中，指向元素a</span><br><span class="line">        总结：七上八下</span><br><span class="line"></span><br><span class="line">        HashSet底层：数组+链表的结构。</span><br><span class="line">------------------------------------------------------------------------------------------------------</span><br><span class="line">public class SetTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test1()&#123;</span><br><span class="line">        Set set &#x3D; new HashSet();</span><br><span class="line">        set.add(456);</span><br><span class="line">        set.add(123);</span><br><span class="line">        set.add(123);</span><br><span class="line">        set.add(&quot;AA&quot;);</span><br><span class="line">        set.add(&quot;CC&quot;);</span><br><span class="line">        set.add(new User(&quot;Tom&quot;,12));</span><br><span class="line">        set.add(new User(&quot;Tom&quot;,12));</span><br><span class="line">        set.add(129);</span><br><span class="line"></span><br><span class="line">        Iterator iterator &#x3D; set.iterator();</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; LinkedHashSet的使用</span><br><span class="line">    &#x2F;&#x2F; LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个</span><br><span class="line">    &#x2F;&#x2F; 数据和后一个数据。</span><br><span class="line">    &#x2F;&#x2F; 优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void test2()&#123;</span><br><span class="line">        Set set &#x3D; new LinkedHashSet();</span><br><span class="line">        set.add(456);</span><br><span class="line">        set.add(123);</span><br><span class="line">        set.add(123);</span><br><span class="line">        set.add(&quot;AA&quot;);</span><br><span class="line">        set.add(&quot;CC&quot;);</span><br><span class="line">        set.add(new User(&quot;Tom&quot;,12));</span><br><span class="line">        set.add(new User(&quot;Tom&quot;,12));</span><br><span class="line">        set.add(129);</span><br><span class="line"></span><br><span class="line">        Iterator iterator &#x3D; set.iterator();</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>TreeSet：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public class TreeSetTest &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">    1.向TreeSet中添加的数据，要求是相同类的对象。</span><br><span class="line">    2.两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    3.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals().</span><br><span class="line">    4.定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals().</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test1()&#123;</span><br><span class="line">        TreeSet set &#x3D; new TreeSet();</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F;失败：不能添加不同类的对象</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        set.add(123);</span><br><span class="line">&#x2F;&#x2F;        set.add(456);</span><br><span class="line">&#x2F;&#x2F;        set.add(&quot;AA&quot;);</span><br><span class="line">&#x2F;&#x2F;   </span><br><span class="line"></span><br><span class="line">     set.add(new User(&quot;Tom&quot;,12));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;举例一：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        set.add(34);</span><br><span class="line">&#x2F;&#x2F;        set.add(-34);</span><br><span class="line">&#x2F;&#x2F;        set.add(43);</span><br><span class="line">&#x2F;&#x2F;        set.add(11);</span><br><span class="line">&#x2F;&#x2F;        set.add(8);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;举例二：</span><br><span class="line">    set.add(new User(&quot;Tom&quot;,12));</span><br><span class="line">    set.add(new User(&quot;Jerry&quot;,32));</span><br><span class="line">    set.add(new User(&quot;Jim&quot;,2));</span><br><span class="line">    set.add(new User(&quot;Mike&quot;,65));</span><br><span class="line">    set.add(new User(&quot;Jack&quot;,33));</span><br><span class="line">    set.add(new User(&quot;Jack&quot;,56));</span><br><span class="line"></span><br><span class="line">    Iterator iterator &#x3D; set.iterator();</span><br><span class="line">    while(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">    Comparator com &#x3D; new Comparator() &#123;</span><br><span class="line">        &#x2F;&#x2F;按照年龄从小到大排列</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Object o1, Object o2) &#123;</span><br><span class="line">            if(o1 instanceof User &amp;&amp; o2 instanceof User)&#123;</span><br><span class="line">                User u1 &#x3D; (User)o1;</span><br><span class="line">                User u2 &#x3D; (User)o2;</span><br><span class="line">                return Integer.compare(u1.getAge(),u2.getAge());</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                throw new RuntimeException(&quot;输入的数据类型不匹配&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TreeSet set &#x3D; new TreeSet(com);</span><br><span class="line">    set.add(new User(&quot;Tom&quot;,12));</span><br><span class="line">    set.add(new User(&quot;Jerry&quot;,32));</span><br><span class="line">    set.add(new User(&quot;Jim&quot;,2));</span><br><span class="line">    set.add(new User(&quot;Mike&quot;,65));</span><br><span class="line">    set.add(new User(&quot;Mary&quot;,33));</span><br><span class="line">    set.add(new User(&quot;Jack&quot;,33));</span><br><span class="line">    set.add(new User(&quot;Jack&quot;,56));</span><br><span class="line"></span><br><span class="line">    Iterator iterator &#x3D; set.iterator();</span><br><span class="line">    while(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



                            <!-- Meta -->
                            <div class="post-meta">
                                <hr>
                                <br>
                                <div class="post-tags">
                                    
                                </div>
                                <div class="post-date">
                                    2021-04-17
                                </div>
                            </div>
                    </div>

                    <!-- Comments -->
                    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <!-- Disqus Comments -->


                    </div>
                </div>
            </div>
        </article>
</section>

<!-- Image viewer-->

    <!-- Custom picture view-->
    <link href="/css/viewer.min.css" rel="stylesheet" />
    <script
      src="/js/viewer.min.js"
      type="text/javascript"
      charset="utf-8"
    ></script>
    
    <script type="text/javascript">
      // set image viewer
      Viewer.setDefaults({
        zoomRatio: [0.5],
        navbar: false,
        toolbar: false,
        button: false,
        title: [2, (image, imageData) => `${image.alt}`],
        show: function() {
          this.viewer.zoomTo(0.5);
        }
      });
      var imageList = document.getElementsByTagName("img");
      Array.prototype.forEach.call(imageList, element => {
        var viewer = new Viewer(element);
      });
    </script>

    
    <!-- Scripts -->
    <script type="text/javascript">
    console.log("© zchen9 🙋 2015-" + new Date().getFullYear());
</script>
  
    <!-- Google Analytics -->
    

    <!-- Service Worker -->
    <!-- if using service worker -->

    
</body>

</html>